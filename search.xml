<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[solving linux problem]]></title>
    <url>%2F2017%2F11%2F05%2Flinux_problem%2F</url>
    <content type="text"><![CDATA[解决各种linux问题。 挂载硬盘 找到硬盘编号 ls /dev/sd* 结果一般为： /dev/sda /dev/sda1 /dev/sda2 /dev/sda3 /dev/sdb 后面跟很多数字的是系统盘，上面的例子中系统盘是/dev/sda；那么/dev/sdb就是新安装的备份盘。 root下，执行parted /dev/sdb以建立分区列表 mklabel gpt #(有不同选项，如MS-DOS gpt Mac) 3T/4T盘必须要手动建立分区列表 mkpart + Enter键 ext4 + Enter键 &quot;Start&quot;&quot; 2048s + Enter键 &quot;End&quot; -1s + Enter键 #（s是单位2048s留给分区列表） 可选步骤，对齐分区以最优化硬盘性能： align-check TYPE + Enter键 opt + Enter键 &quot;partition number?&quot; 1 + Enter键 mkfs.ext4 /dev/sdb/ # 格式化硬盘 mount # 挂载 123mkdir /home/your_name/backup #建立文件夹mount -t ext4 /dev/sdb /home/your_name/backup #挂载文件夹chown -R your_name:your_name /home/your_name/backup 修改/etc/fstab # 设置开机后自动挂载备份硬盘 得到硬盘的UUID： 12[root@node34 ~]$ uuidgen /dev/sdac6af66d2-f6dc-4a4b-8d83-40ce2b8d0b75 打开/etc/fstabe，加入备份盘的UUID： UUID=c6af66d2-f6dc-4a4b-8d83-40ce2b8d0b75 /home/your_name/backup/ ext4 defaults 1 2]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy notes]]></title>
    <url>%2F2017%2F10%2F31%2Fnumpy%2F</url>
    <content type="text"><![CDATA[The fundamental package for scientific computing with Python. numpy 帮助：np.info(np.random) ndarray学习 numpy中的ndarray方法和属性 ndarray.mean(axis=None, dtype=None, out=None)：返回指定轴的数组元素均值 ndarray.var(axis=None, dtype=None, out=None, ddof=0)：返回数组的方差，沿指定的轴。 ndarray.std(axis=None, dtype=None, out=None, ddof=0)：沿给定的轴返回数则的标准差 ndarray.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)：返回沿对角线的数组元素之和 ndarray.diagonal(offset=0, axis1=0, axis2=1)：返回对角线的所有元素。 最大/小值 ndarray.argmin(axis=None, out=None):返回指定轴最小元素的索引。 darray.min(axis=None, out=None)：返回指定轴的最小值 flat/flatten ndarray.flat 和 ndarray.T 一样不是函数调用 12345 &gt;&gt;&gt; x = X.flat &gt;&gt;&gt; x&lt;numpy.flatiter object at 0x9e82278&gt; # 不直接返回一维数组 # 但可直接索引 flatten()是函数调用，可以指定平坦化的参数。 123456789101112 可选参数，order：（1）’C’：C-style，行序优先（2）’F’：Fortran-style，列序优先（3）’A’：保持（4）默认为’C’+ ndarray.transpose(*axes) :返回矩阵的转置矩阵+ ndarray.take(indices, axis=None, out=None, mode=’raise’):获得数组的指定索引的数据，如： ```python &gt;&gt;&gt; a.take([1,3],axis=1) #提取1，3列的数据array([[ 1, 3],[ 5, 7],[ 9, 11]]) 构造矩阵 arange()/linspace() numpy.zeros，numpy.ones，numpy.eye, numpy.full((2,2),7) 123456789101112 &gt;&gt;&gt; print np.zeros((3,4))[[ 0. 0. 0. 0.] [ 0. 0. 0. 0.] [ 0. 0. 0. 0.]] &gt;&gt;&gt; print np.ones((3,4))[[ 1. 1. 1. 1.] [ 1. 1. 1. 1.] [ 1. 1. 1. 1.]] &gt;&gt;&gt; print np.eye(3)[[ 1. 0. 0.] [ 0. 1. 0.] [ 0. 0. 1.]] numpy下的vstack和hstack函数： vstack、hstack是浅拷贝 1234567 &gt;&gt;&gt; a = np.ones((2,2)) &gt;&gt;&gt; b = np.eye(2) &gt;&gt;&gt; print np.vstack((a,b))[[ 1. 1.] [ 1. 1.] [ 1. 0.] [ 0. 1.]] numpy.linalg 12345 &gt;&gt;&gt; import numpy.linalg as nplg &gt;&gt;&gt; a = np.array([[1,0],[2,3]]) &gt;&gt;&gt; print nplg.eig(a)(array([ 3., 1.]), array([[ 0. , 0.70710678], [ 1. , -0.70710678]])) comparison a == b #逐个元素比较 a &lt; 2 np.array_equal(a,b) arithmetic operation +, -, *, / #element-wise np.dot(a,b) # matrix multiply I/O np.save(‘myarray’,a) np.savez(‘myarray.npz’,a,b) np.save(‘myarray.npy’,a) np.loadtxt/savetxt/genfromtxt]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python notes]]></title>
    <url>%2F2017%2F10%2F02%2Fpython_notes%2F</url>
    <content type="text"><![CDATA[Python features a dynamic type system and automatic memory management and supports multiple programming paradigms.[1] Python Syntax Python doc builtin functions (import builtins) abs() dict() help() min() setattr() all() dir() hex() next() slice() any() divmod() id() object() sorted() ascii() enumerate() input() oct() staticmethod() bin() eval() int() open() str() bool() exec() isinstance() ord() sum() bytearray() filter() issubclass() pow() super() bytes() float() iter() print() tuple() callable() format() len() property() type() chr() frozenset() list() range() vars() classmethod() getattr() locals() repr() zip() compile() globals() map() reversed() __import__() complex() hasattr() max() round() delattr() hash() memoryview() set() sum() sum(iterable[, start]) ，iterable max() max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable,key=keyfunc). 几个例子 next(iterator[, default]) all()/any() Return True if all elements of the iterable are true (or if the iterable is empty). Equivalent to: 12345def all(iterable): for element in iterable: if not element: return False return True filter 把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。 python3起，filter 函数返回的对象从列表改为 filter object（迭代器）。 1234def is_odd(n): return n % 2 == 1[item for item in filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]) ] getattr()/setattr()/hasattr()/delattr() getattr(x, ‘foobar’) is equivalent to x.foobar All these function are similar. See docs for more. vars() From python doc: Return the __dict__ attribute for a module, class, instance, or any other object with a __dict__ attribute. enumerate 如果mylist是一个二维数组： 12for i,line in enumerate(mylist): ... line是元组 staticmethod(function) PS: @classmethod means: when this method is called, we pass the class as the first argument instead of the instance of that class (as we normally do with methods). This means you can use the class and its properties inside that method rather than a particular instance. @staticmethod means: when this method is called, we don’t pass an instance of the class to it (as we normally do with methods). This means you can put a function inside a class but you can’t access the instance of that class (this is useful when your method does not use the instance). classmethod涉及类，不涉及类的实例；staticmethod两者都不涉及，但与类有紧密的联系 ref: Python——类属性/实例属性 Python——类属性/实例属性 Python类属性，实例属性 #非常好 123456C.__name__ # 类C的名字（字符串）C.__doc__ # 类C的文档字符串C.__bases__ # 类C的所有父类构成的元组C.__dict__ # 类C的属性C.__module__ # 类C定义所在的模块C.__class__ # 实例C对应的类 module.file 含有module的路径！ 操作符特性：a, b = b, a+b Take the calculation of Fibinacci: a, b = b, a+b # a and a+b will be computed separately print print(end='str') dict mydict.iterm() 将项以list返回 for key,val in myd3.iterm(): iteriterms()返回迭代器，节省内存 Only for python2 file f.readline()/readlines()/write()/writelines() readline()#每次读入一行 readlines() #以list的形式存储每一行 write() #自动换行 writelines() #不自动换行 f.closed 注意closed是一个变量，值为True/False list comprehension two fold list comprehension 12content = f.readlines()word_list=[word for line in content for word in line.split()] string 1. strip(s[, chars]) 去掉首尾的字符 默认情况下strip() 去掉首尾的whitespace 【whitespace include \n, \t and \r】。 The charsargument is not a prefix or suffix; rather, all combinations of its values are stripped: 12 &gt;&gt;&gt; 'www.example.com'.strip('cmowz.') 'example' 2. format ‘{0:.2f} {1:s} {2:d}’.format( v0[,v1[v2…] ) 可以使用关键词 应用时转化：{!s}、{!r} 旧式字符串格式化符号是 %，如：{0:%.4f} custom object(define __format__ in a class) 12345class HAL9000(object): def __format__(self, format): if (format == 'open-the-pod-bay-doors'): return "I'm afraid I can't do that." return 'HAL 9000' datetime 12from datetime import datetime'&#123;:%Y-%m-%d %H:%M&#125;'.format(datetime(2001, 2, 3, 4, 5)) named placeholder use key to hold the place. input the dictionary as elements 1234data = &#123;'first': 'Hodor', 'last': 'Hodor!'&#125;'&#123;first&#125; &#123;last&#125;'.format(**data)# or'&#123;first&#125; &#123;last&#125;'.format(first='Hodor', last='Hodor!') Getitem and Getattr Parametrized formats 3. rjust(width[, fillchar]) 【ljust(), center() is similar】 4. zfill(n) 左侧填充0至n位 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串。如果指定的长度小于字符串的长度则返回原字符串。 5. split(str=&quot;&quot;, num=string.count(str)) # str and num is not a kewword num – 分割次数。 注意split后常会产生空字符 6. join 12out.write(" ".join(mylist))# 用" "链接mylist中的iterm 7. encode()/decode() str.encode(encoding=“utf-8”, errors=“strict”) 设置不同错误的处理方案。默认为 ‘strict’,意为编码错误引起一个UnicodeError。 其他可能得值有 ‘ignore’, ‘replace’, ‘xmlcharrefreplace’, ‘backslashreplace’ 以及通过 codecs.register_error() 注册的任何值。 ternary operator 1result='5 is larger than 3' if 5&gt;3 else '5 is not larger than 3' CLI python -c &quot;print('hello world')&quot; python -m mymodule sys.path is changed it’s equal to python mymodule.py module re module 1. replace(str1, str2) sys module sys.version/version_info(version_info is a object) os module 1. os.path os.path模块 os.path.exist determine if a file or dir exists os.remove remove a file; if file does not exists, an Error will be throwed out. os.rmdir remove a dir os.path.splitext(path) Split the pathname path into a pair (root, ext) os.path.basename(your_path) 2. os.popen shell cmd is executed in background and you can’t change it inplemented by subprocess.Popen, so why not you use subprocess? [python doc]( https://docs.python.org/3.5/library/os.html?highlight=os.popen#os.popen) time &amp; calendar Python 日期和时间 runoob time.time() Return the current time in seconds since the Epoch. mktime(tupletime) localtime() Convert seconds since the Epoch to a time tuple expressing local time. When ‘seconds’ is not passed in, convert the current time instead. strftime() strftime(format[, tuple]) -&gt; string strptime() strptime(string, format) -&gt; struct_time Parse a string to a time tuple according to a format specification. time.sleep(secs) calendar.isleap(year) calendar.weekday(year,month,day) subprocess module python doc 1. For cmd that needn’t stdout subprocess.run(&quot;cp standard_py/*py .&quot;, shell=True, check=True) shell=True you can use a string instead of a series of args! check=True throw an Error if shell cmd exit wrong! 2. For cmd needing stdout An example: 12ret = subprocess.run("ls standard_py/*py", shell=True, check=True, universal_newlines=True, stdout=PIPE)print(ret.stdout, end="") universal_newlines=True stdout Captured stdout from the child process. A bytes sequence, or a string if run() was called with universal_newlines=True. None if stdout was not captured. stdout=PIPE without this argument, stdout will be printed as stdout of python script, instead of captured, as from python doc: This(ct: means run) does not capture stdout or stderr by default. To do so, pass PIPE for the stdout and/or stderr arguments. glob module The glob module finds all the pathnames matching a specified pattern glob.glob(pathname, *, recursive=False) glob.iglob(pathname, recursive=False) Return an iterator which yields the same values as glob() collections module 廖雪峰 Counter PIL img = Image.open(‘origin.png’) #支持多种格式 注意：类似于.htm和.html，.jpg和.jpeg没有区别，只是两种写法 font font = ImageFont.truetype(&quot;FreeMono.ttf&quot;, 28, encoding=&quot;unic&quot;) img2.save('./test_image_data/cat_001_blur.jpeg','jpeg') #save(‘path’,‘format’) resize()、rotate()、convert(mode=‘your_mode’) Coordinates (0, 0) in the upper left corner. draw = ImageDraw.Draw(img) 123#img is from:#img = Image.open(&apos;./test_image_data/cat_001.jpg&apos;)draw.text((width - add_width, 0), number, font=font, fill=fillcolor) # first parameter is the start point of the draw random doc random.seed(a=None, version=2) functions for integers random.randrange(start, stop[, step]) random.randint(a, b) return a random integer N such that a &lt;= N &lt;= b. Alias for randrange(a, b+1). real-valued distributions random.random() Return the next random floating point number in the range [0.0, 1.0). random.uniform(a, b) random.gauss(mu, sigma) other useful things ipython “?” 帮助，?save 会给出save命令的用法 conda minicoda 使用conda管理python环境 anaconda Anaconda使用总结 conda install scipy #安装scipy conda list #列出已安装的包 pip Usage：pip --help for more info error Could not fetch URL https://pypi.python.org/simple/pytest-cov/… 123 Could not fetch URL https://pypi.python.org/simple/pytest-cov/: There was a problem confirming the ssl certificate: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:600) - skipping Could not find a version that satisfies the requirement pytest-cov (from versions: )No matching distribution found for pytest-cov 解决： 1pip install --trusted-host pypi.python.org pytest-xdist 工程能力 工程/OOP setting all instance variables in the __init__ is cleaner 工厂函数 见python核心编程：工厂函数看上去有点像函数，实质上他们是类，当你调用它们时，实际上是生成了该类型的一个实例，就像工厂生产货物一样. debug 要融汇的方法[2]： 回答先在本地重现的就算了吧……那么容易就能重现通常说明最基本的代码逻辑覆盖测试都没做好。相比起C/C++来说，动态语言还是比较幸福的，异常都有详细的堆栈，只要打印到日志里就行了，错误信息通常也比较明确。要点在于该打印的日志一点都不能少，严禁在出现异常的时候只打印错误信息而不打堆栈。但归根结底来说，发现和解决bug靠的是良好的程序结构，必要的defensive（关键函数的参数合法性校验等），自动化的测试流程，线上调试只是亡羊补牢。 test pytest比较好！从它入门 ！ unittest vs pytest vs nose Pytest vs Unittest vs Nose 【详细的对比】 待读！： Writing unit tests in Python: How do I start? Improve Your Python: Understanding Unit Testing python自动化测试 【先读】 最完整的自动化测试流程 python缺点 efficiency slow than java global lock, which makes multi-threads suck hard to distribution (compare to JAVA et al., python is dependent to package) easily decompiled 和其他语言的对比 ruby ruby最大的优势在于Ruby on Rails 我的经验 都说python有很多包、方便，然而包里有可能有很多坑（bug or bad practice），比如Pillow中遇到过**karg的滥用。这些特点使得python很容易开发原型，但很难构建稳定、高效、一致的大型应用。 有不少不符合直觉的&quot;feature&quot;[3] 例如： 1234567 &gt;&gt;&gt; a = ([1], [2]) &gt;&gt;&gt; a[0] += [3]Traceback (most recent call last): File "", line 1, in TypeError: 'tuple' object does not support item assignment &gt;&gt;&gt; a([1, 3], [2]) reference Python ↩ 老程序员解bug有那些通用套路？ ↩ 有哪些明明是 bug，却被说成是 feature 的例子？ ↩]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vmd笔记]]></title>
    <url>%2F2017%2F09%2F29%2Fvmd%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[什么是VMD？[1] VMD is a molecular visualization program for displaying, animating, and analyzing large biomolecular systems using 3-D graphics and built-in scripting. VMD官网的图片示例展览 本文定位：本文不适合作为入门教程，适合于在进阶阶段作为参考。本文偏重于VMD脚本；图形界面(GUI)上的操作因为比较简单，讨论的较少。 显示 console中，输入命令且不加参数，就会显示帮助信息 tcl语言作为脚本语言，tcl语法可以参考TCL脚本入门教程【当然没必要学完】 如何进入console：Extension -&gt; Tk Console 例子： console% measure结果见图 console% mol pbc… pbc pbc是周期性边界条件的缩写（periodic boundary condition） pbc wrap -all 【将粒子折回盒子内】 画盒子 pbc box -on 【画出盒子】 pbc box -center origin 【设定盒子中心的位置】 pbc box -center origin -style tubes -width 1 -color gray pbc join res -border 5 【接上由于pbc导致的盒子边界处的断键】 display display projection orthographic 【相当于在display选项卡中选择orthographic】 display distance x 设置东西与屏幕的距离，越大则分子离屏幕越近，相当于放大。不可太小比如几十，否则有凸镜的效果 背景设置为白色 （Graphics-&gt;Colors-&gt;Categories栏-&gt;选Display-&gt;再在name栏选Background）时，图像会显得比较浅。修正这个问题的方法是：去掉Display-&gt;Depth Cueing graphics graphics top list【to show a list of number, standing for the ID of each object】 graphics top text {40 0 20} “my drawing objects” # 文字 graphics top info ID # The detailed information about each object graphics top delete ID box is also considered as graphics in VMD draw shapes【画图形】[2] graphics top color COLORID【先设定颜色后画图形才能设定成功】【colorid for each color can be found in Graphics -&gt; Colors -&gt; menu 】 graphics top sphere {10 10 10} radius 10 resolution 80 graphics top line {10 0 0} {0 0 0} width 5 style dashed graphics top material transparent graphics top delete all/ID【delete shapes】 NOTE: vmd看gromacs文件（*.gro）时，会把单位自动换位埃，比如在.gro文件中，坐标为1，则vmd中坐标为10，画图形时，可能会用到 colorinfo colors 显示有多少种预置颜色，比如red 旋转 rotate x by/to 90 Script 基本命令 ~/.vmdrc ： 配置文件 logfile my.log 在console中输入此命令,可以将你在图形界面中的操作保存成脚本，存储在my.log中 有用又简单的命令 !!! console中导入脚本 source yourscript.tcl 不显示图形界面的执行脚本 sh$ vmd -dispdev none -e script.tcl 需要注意到的是，使用-dispdev none选项后，用pbc命令的脚本回报错： invalid command name &quot;pbc&quot; 在脚本中添加下列命令即可解决该错误： package require pbctools mol mol的用法帮助：如前面第0节所述，在console中输入mol并且不加参数，就会显示mol的用法。 这里要介绍VMD中两个重要的概念：molid（molecular ID）和repid（representation ID）。 molid：对单个frame，molid恒等于0 repid：打开一个frame，默认的repid为0 如果你想添加第二种呈现方式（representation），可以用：mol addrep 0向molid为0的图中，新增一种representation，这一representation的repid等于之前最大的repid+1。 GUI中，Graphics -&gt; Representations -&gt; Create Rep 就相当于下列命令： 12mol addrep 0mol modselect 1 0 "type 1" 注意：写脚本时，尤其要注意的一点是如果打开一个frame成功，会隐式的执行一次mol addrep 0！ 例如，我们将类型为A的原子显示成蓝色（ColorID 0）、将B类型的原子显示成红色（ColorID 1），脚本这样写： 123456789# mol addrep 0 # NOTE: VMD has execute this statement invisibly. If # you add this "mol addrep 0" manually, there will # be an error. mol modselect 0 0 "type A"mol modcolor 0 0 ColorID 0mol addrep 0# now there are two "rep". The index of second "rep" is 1.mol modselect 1 0 "type B"mol modcolor 0 0 ColorID 0 mol default style {CPK} 【相当于Graphical选项卡中选择Representations,再在Draw style中Drawing Method下选择CPK】 mol default material {Diffuse} 【相当于Graphical选项卡中选择Representations,再在Draw style中Material下选择Diffuse】 mol list 列出目前所有representation mol delrep 3 0 与mol addrep 0相对，删除molid=0，repid=3的mol molinfo list/num 显示全部分子的molid atomselect 例子： 1234567set particle [atomselect 0 "index&lt;13000"]$particle set resname CD #默认是空$particle set chain X$particle set resid 1 #默认是0$particle set radius 0.6$particle num # 输出particle中原子个数$particle delete atomselect有单独的编号 比如atomselect345，我们可以用编号atomselect345来调用它;它的各种信息都可以输出出来。 atomselect macro macro指的就是那些charged、acidic、amino之类的，比如atomselect charged会选择体系中带电荷的原子。蛋白质体系容易用到，聚合物体系不容易用到。 atomselect macro 显示所有macro atomselect keywords atomselect 3 &quot;resid 25&quot; frame last 选择molid为3、最后一帧的resid 25。molid可以是数字或者top，所选内容就是普通的selection，用双引号或者{}括住，帧号可以是数字、first、last、now。 atomselect list会列出所有的atomselect index 除了上文中set particle [atomselect 0 &quot;index&lt;13000&quot;]的筛选方法，index选择原子时还支持多种筛选方式： “(index&gt;100 &amp;&amp; index&lt;200) || index = 66” “index 1 3 5” &quot;index = [ expr 250 * $i ]&quot; # index 支持expr表达式求值，i为自定义变量 Script Syntax[3] 0. 注释 TCL中的注释符是’＃’，’＃’和直到所在行结尾的所有字符都被TCL看作注释，TCL解释器对注释将不作任何处理。不过，要注意的是，’＃’必须出现在TCL解释器期望命令的第一个字符出现的地方，才被当作注释。 例如： %＃This is a comment %set a 100 # Not a comment %set b 101 ; # this is a comment 1. for语句 12for &#123;set i 0&#125; &#123;$i &lt; [llength $list]&#125; &#123;incr i&#125; 2. list set list { Opaque Transparent ... } [llength $list] # get index [lindex $list $i] # reference the list 3. measure measure的功能非常多，从相对简单的求质心、几何中心、均方回转半径、RDF（vmd中叫gofr）、rmsd和rmsf(RMS fluctuation)，到比较专业的氢键分析、sasa（solvent-accessible surface area）等。 全部功能见图：https://res.cloudinary.com/do7yb5qw4/image/upload/v1506587376/杂/vmd_measure.jpg measure center $sel measure minmax $sel measure bond { index_1 index_2} GUI下 Mouse &gt; Label &gt; Bonds， 或是在激活3D 窗口的条件下按2 鼠标形状会变成+，然后依次点击2个原子即可， Graphics &gt; Label 可以进行更多的操作 4. xyz(coordinate) is storaged as list! When you get multiple atom attributes (in this case, x, y, and z), the result is always returned as a nested list, even if that list contains only one element. As somebody may think the code below is very intuitive: 12set sel [atomselect 0 "index = 250"]graphics top text [ $sel get &#123;x y z&#125; ] "words i want to say" However, $sel get {x y z} ] is actually a list, but there need a vector. It’s like you give： 1graphics top text &#123; &#123;1 2 3&#125; &#125; "words i want to say" But actually we need: 1graphics top text &#123;1 2 3&#125; "words i want to say" The solution is ugly: 123foreach coor [ $sel get &#123;x y z&#125; ] &#123; graphics top text $coor "words i want to say"&#125; Beside that, coordiante should be used like below: graphics top text [list $x $y $z] &quot;words i want to say&quot; source: vmd mailing list 5. get one coor of three(only one element in pxyz) 12set pxyz [atomselect top "index = [ expr 250 * $i ]" ]set px [$pxyz get x] 存高质量图片[4] render TachyonInternal name.tga convert name.tga name.png 这样得到的图片效果有限 尝试了各种方法，似乎tga转换png的质量不能控制 要想得到高质量的图片，方法如下 File-&gt;render(这里有三行) (第一行选择)Tachyon (第三行加上，设置分辨率) -res 1024 1024 res代表resolution，设为1024*1024时，tga大小为3.1M，png大小为680K 最后convert vmdscene.tga vmdscene.png（转成jpg格式也可以） ambient occlusion（AO,环境光遮蔽）效果会很好 script: render Tachyon vmdscene.dat “/usr/local/lib/vmd/tachyon_LINUXAMD64” -aasamples 12 %s -format TARGA -res 1024 1024 -o %s.tga culling culling actually reduces performance on some hardware renderers[5] Depth Cueing Depth cueing causes distant objects to blend into the background color, in order to aid in 3-D depth perception 存动画 （1）进入 Extensions -&gt; Visualization -&gt; Movie Maker （2）Render -&gt; Tachyon （3）Movie Settings -&gt; Trajectory （4）Format -&gt; Animated GIF color scale【颜色梯度】 trajectory with color gradient load a trajectory 设置颜色随frame变化 Graphical -&gt; Representations -&gt; Draw style -&gt; Coloring method -&gt; Timestep Graphical -&gt; Representations -&gt; Trajectory -&gt; 选择&quot;update color every frame&quot;; 修改&quot;Color Scale Data Range&quot; 设置Color Scale Bar Extensions -&gt; Visuilizition -&gt; Color Scale Bar 选择颜色 Graphical -&gt; Colors -&gt; Color Scale -&gt; 这个设置还可以以&quot;RWB(Read Whie Blue) Offset -0.09, Midpoint 0.5 &quot; frame with color gradient load a frame 设置颜色随index变化 Graphical -&gt; Representations -&gt; Draw style -&gt; Coloring method -&gt; index Graphical -&gt; Representations -&gt; Trajectory -&gt; “Color Scale Data Range 0 ~ total_monomer_number” 设置Color Scale Bar和选择颜色与上面&quot;trajectory with color gradient&quot;相同 其他 compound（似乎没什么用） 只用于pbc中 supported compound types: segment, residue, chain, fragment, connected 问题 pbc join pbc join res -border 5 -sel “resname 0&quot;好使，但不明白为什么？ 但是注意，resname一个不存在的名字，比如&quot;resname 1000000”，也不会报错。 pbc join res -sel尝试了各种办法也没有成功 最后解决：还是在xml文件中删除多余的bond和angle，就是join的时候很慢，要等很久。 vmd有很多功能，如： VMD extensions: membrane builder Molecular Surface Representations 对vmd脚本的感觉 优点：vmd本身功能非常多，使用者多。 缺点：以tcl为基础的vmd脚本，坑很多，体现了很多动态弱类型语言的缺点。 reference VMD官网 ↩ VMD Tutorial ↩ VMD Tutorial: Scripting in VMD ↩ 非常好的效果的vmd作图 NOTE：该CBMSG网站还有很多有用的教程和资源（Computational Biophysics and Materials Science Group） ↩ manual culling ↩]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>画图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何快速的向Word格式的硕士/博士论文中，添加引用文献？]]></title>
    <url>%2F2017%2F09%2F24%2FWord%E6%A0%BC%E5%BC%8F%E8%AE%BA%E6%96%87%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[通常，很多理工科硕士/博士的毕业论文，是将自己Paper翻译成汉语再稍作组织而写成的。由于论文要求是Word格式的，重新向Word中添加引用文献是一项繁琐的工作。这里我介绍一种方法，利用Latex写Paper时准备的bib文件，向Word中添加引用文献。该方法有几个好处: 几乎所有文献引用在.bib文件中都是现成的，不用再重新下载引用 latex中采用的bibtex key（“@article{paper_name,”中paper_name即为bibtex key）可以直接用到Word中。 不用跳转到EndNote等其他软件 必要软件bibtex4word的安装请参考： 用Bibtex4Word实现Word写作时参考文献的插入和排版 多数高校一般都要求采用《GB/T 7714-2005 文后参考文献著录规则》作为毕业论文的引文规则，上面连接中给出的下载已经不可用了，戳这里可以找到下载 至此，软件的准备工作就完成了。我们将我们几篇Paper中用到的.bib文件合并到一起（如果有少量重复的引用，手动删除就可以；重复引用较多的话，可以用bib文件管理软件删除，比如我用的JabRef），就可以愉快的插入文献啦。插入方法很简单，见Bibtex4Word的介绍。]]></content>
      <categories>
        <category>技术杂烩</category>
      </categories>
      <tags>
        <tag>word</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[专利申请]]></title>
    <url>%2F2017%2F09%2F07%2F%E7%94%B3%E8%AF%B7%E4%B8%93%E5%88%A9%2F</url>
    <content type="text"><![CDATA[之前想把研究结果申请成专利(化工领域)，所以做了下列功课，在此分享给有相同需求的人。 在拿到专利申请号之前，相关论文是不能被公开发表的。而我们正好着急发论文，所以特意问了加急申请的费用和拿到专利号的时间。 申请专利的顺序 准备好纸面材料 一般长度为几页，需要介绍清楚相关的技术，让专利代理明白。 专利代理进行撰写 就算你选择加急，也需要至少一周时间。如果时间太短，可能会有写出来的文书的效果不好、专利保护范围不广等问题。 提交申请 材料都准备好之后，一到两天就能拿到专利申请号。 专利方面律师事务所 来源：中国在知识产权服务行业有哪些著名的公司？ 第一集团 柳沈律师事务所 2万包杆（包含全部费用），一个月内，加3000半个月。该律师建议我们可以先投文章，因为文章不可能在一个月之内发表的，另外拿到专利号的时间可以写在合同内。 联系方式：010-62681616 中国国际贸易促进委员会专利商标事务所 正常1.8万包杆，30个工作日，11-15工作日10%加急费，6-10工作日20%加急费。 联系方式：010-66046763 中国专利代理（香港）有限公司 香港公司，没有联系 第二集团 中科专利商标代理有限责任公司 给底稿到拿到申请号，需要一周时间，拿到专利号的时间可以写在合同内。价格为8000-10000(应该不是包杆，只是申请费，不包括官费等)。 联系方式：010-68619696 中原信达知识产权代理有限责任公司 10天，包杆一万八到一万九 联系方式：010-66576688 金杜 只做公司和机构 中咨 联系方式：010-66091188 至少15天。申请费120000，官费900高校优惠到300 另外费用2450高校优惠到700]]></content>
      <categories>
        <category>技术杂烩</category>
      </categories>
      <tags>
        <tag>专利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[All about Digital Currency]]></title>
    <url>%2F2017%2F08%2F30%2Fdigital_currency%2F</url>
    <content type="text"><![CDATA[all about block chain Info source www.8btc.com trans.chbtc.com/markets/eth 有长期数据，可以画周线 其他币 薛蛮子认为： 对于ICO的投资标准，薛蛮子表示，首先是人靠谱，此前投资的比原链是国内区块链最大的社区巴比特发起的，墨链是纸贵科技发起的，BEX是美豹金融发起的，这些项目的团队本身已经有了成功的创业案例，且在细分领域处于排头兵的地位。 拿比原链来说，薛蛮子表示，“我认为，比原链的创始团队很年轻，富有朝气，大家都很努力，但是比原链的技术挑战挺大，需要天时地利人和，很多条件具备才能做成，不是轻描淡写，一挥而就的。团队最要紧的是不断试错，踏踏实实做事情，不要辜负投资人的信任。我不看好的是，有的小伙子一辈子没赚过大钱，也没花过100万以上的钱，突然通过ICO拿了几个亿，这些人hold不住。” 问题与挑战 1. 税收 美国国税局（IRS, Internal Revenue Service）在努力调查bitcoin避税，这是bitcoin正式应用所面临的一个问题。 像达世（Dash）、门罗（Monero）和ZCash等币都部署了隐私功能，其交易是很难被追踪到的。 待读&amp;进展 待读 非常好：http://www.8btc.com/reinvent-the-currency 以太坊（1）–在CentOS 6.5上搭建以太坊私有链的步骤（图文详细） 教程 Geth搭建私有链 中国在区块链领域有哪些专家或公认的牛人？【帮助弄懂bitcoin技术】 进展 按照https://ethereum.stackexchange.com/questions/13547/how-to-set-up-a-private-network-and-connect-peers-in-geth对json进行了设置， 资料&amp;引用 资料 区块链是什么，如何简单易懂地介绍区块链？]]></content>
      <categories>
        <category>block chain</category>
      </categories>
      <tags>
        <tag>block chain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gnuplot笔记（下）]]></title>
    <url>%2F2017%2F08%2F16%2Fgnuplot%E7%AC%94%E8%AE%B0%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[gnuplot笔记下半部分。 [TOC] gnuplot命令 1. terminal gnuplot可以将画出的结果输出到不同terminal中。所谓terminal，既可以是png、eps等图片格式，也可以是x11、qt等窗口格式。 x11 支持像素大小 set terminal x11 enhanced lw 3.0 dashlength 5.0 size 1080,755 可以使用interactive脚本 set terminal x11 font &quot;Helvetica,45&quot; 加上font后，就不能使用了 eps 不支持支持像素大小 eps默认是以inch为单位，默认大小是10,6；我的图因为还要放大1.8倍，所以是18,10.8 All PostScript printers or viewers should know about the standard set of Adobe fonts Times-Roman, Helvetica, Courier, and Symbol. eps ps、eps格式不支持transparent，png支持 eps不支持transparent ps、eps格式不支持transparent，可以用png格式。 2. 数据筛选/处理 2.1. awk等预处理 下面两条命令是等价的 plot 't1.dat' p '&lt; cat t1.dat' 我用过 p &quot;&lt;awk '{if(NR&gt;13) print}' q.log&quot; 2.2. pi（pointinterval） for linespoints plot 只用于linespoints plot。决定点的symbol的稀疏，用法例子：pi 2，“means that point symbols are drawn only for every Nth point” 2.3. every 注意every不能简写成e 5个冒号，最后一个数字之后的冒号必须要省略 正确写法是： p 'PS500_26w_1/msd-PS_1.dat'every 10::::90000 w l 而不是： p 'PS500_26w_1/msd-PS_1.dat'every 10::::90000: w l 意思是每10个数据点画一个，一共画到第九万个点 具体参看gnuplot5.0.1 P85或help every 2.4. index( column(-2) ) 用于一个文件中多块数据stackoverflow &quot;p = 0.1&quot; 1 1 3 3 4 1 &quot;p = 0.2&quot; 1 3 2 2 5 2 12plot &apos;test.dat&apos; i 0 u 1:2 w lines title columnheader(1),\ &apos;test.dat&apos; i 1 u 1:2 w lines title columnheader(1) 需要注意的是光用空格来分割两个data block是不够的。 column(-2)是Pseudocolumns，可以在manual中搜索是Pseudocolumns。 3. 保存交互模式下的命令为脚本 12gnuplot&gt; save &apos;name.plt&apos;gnuplot&gt; load &apos;name.plt&apos; 4. 函数及设置定义域 123g(x)=3*x**2 # 普通函数f(x,min,max)=( (x&gt;min &amp;&amp; x&lt;max) ? (3*x**2) : 1/0 ) # 定义一个带定义域的函数p f(x,1,100) w l # 在[1,100]的定义域内，画出3*x**2 f(x,min,max)=( (x&gt;min &amp;&amp; x&lt;max) ? (3*x**2) : 1/0 )的解释： min，max只是自定义的变量，? :是经典三元表达式，1/0在gnuplot中不会被画出。综合起来f(x,min,max)的定义相当于：如果(x&gt;min &amp;&amp; x&lt;max)，就画出3*x**2，否则不画。 这里用到的几个技巧很有用，不光可以用来定义域。 5. 自带函数 log() &amp; log10() exp sin()等三角函数 gamma() 6. fit 自变量要设定成x、y等，如f(x)=exp(-(x/tau)**beta)，因为gnuplot似乎对变量名敏感 fit范围 12f(x)=a*x**bfit [0:300] f(x) &apos;msd.dat&apos;u 1:5 via a,b 7. 传入参数到脚本 命令行（CLI）下， 1gnuplot -c script.plt hehestr1 str2 str3 “script.plt” 就是ARG0，以此类推&quot;hehestr1&quot;就是ARG1… 8. how to set the config file? show loadpath will show where the configuration file locate at gerenal configuration is in app-defaults dir. 9. smooth csplines 可以解决由于点多画不出虚线的问题 少用的命令 Interactive label placing parametric mode 1234set parametricset trange [-pi:pi]plot sin(t),cos(t)unset parametric MOUSE_BUTTON 点左键 MOUSE_BUTTON==1； 中键 ==2； 右键 ==3; 光点击的话，其他三个自带变量（MOUSE_SHIFT,MOUSE_ALT,MOUSE_CTRL）==0 显示信息型命令 1. show show variables show all 2. history history 5 #显示最近5条命令 history ?load #显示所有以load开头的命令 history ?&quot;set label&quot; #显示所有以set label开头的命令 history !&quot;set label&quot; #执行所有以set label开头的命令 3. test test可以展示当前terminal或palette的画图效果 test (terminal | palette) 123gnuplot&gt; help test This command graphically tests or presents terminal and palette capabilities. ... x11 test test x11 eps test png test 各种plot multiplot 1234567891011 set size 3,1.5 set multiplot #set the parameter of 1st subfigure set origin 0,0 set size 1.5,1,5 p ......#set the parameter of 2nd subfigure set origin 1.5,0 set size 1.5,1,5 p ...... 对齐subfig 用set lmargin 进行对齐 调整所有subfig的scale大小 set tics scale 3 取消前面的设置 因为后面的subfig会继承前面subfig的设置，有时候需要取消前面的设置。 时常需要取消的有：label, arrow, scale等。 最常用的取消方式是unset 对于key–set key default 对于tics– set xtics autofreq 3D plot view view用来设定3d图的观察角度 set view &lt;rot_x&gt;, &lt;rot_z&gt; 默认值是： set view 60, 30 设置Z轴起点 set xyplane at 0.6 设置背景网格 set grid x y z back 自定义渐变色 set palette define (0.6 &quot;#FF0000&quot;,1.1 &quot;blue&quot;) External Link using gnuplot Plot functions using the special-filenames property colorbox 自定义colorbox： set colorbox vertical user origin 1.1,0.5 size .06,.4 设定colorbox的tics： set cbtics 0.1 set logscale cb set cbrange [0.001:1] filled curve plot 'silver.dat' u 1:2:3 w filledcu Error &amp; 问题： 输出文件的大小为0——解决方法： The eps file doesn’t get written until a plot command is specified after specifing the output. Possible solutions: Move your plot command after your set output command add a replot command to the end of your script Reference An amazing web: gnuplotting.org]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>画图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gnuplot笔记（上）]]></title>
    <url>%2F2017%2F08%2F16%2Fgnuplot%E7%AC%94%E8%AE%B0%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[gnuplot笔记，包含中高级使用方法，方便入门之后的进阶学习。 [TOC] Note about Version 5 1. dashtype需要单独设置 与4.x版本不同，现在linetype画出的都是实线了。 例子：p sin(x) dt 2 #设为2型虚线 2. size的用法 eps to png when eps size is set to 1.0,1.0，png的像素为600,420 eps：size 1.8,1.8 那么png的像素为1080,755 x11 set terminal x11 size 600,420应该是默认大小 size 2,2 会导致图像超过窗口大小 3. 新加入几个命令 plot ... smooth mcsplines plot &lt;datafile&gt; skip N # skip lines at start of ascii data file set colorsequence default|classic|podo # colors used by successive plot elements 4. 变量的引用 For 4.6: 12var=123set label 1 &apos;var&apos; at 1,1 For 5.0: 12var=123set label 1 var at 1,1 format 1. set logscale y set logscale # x和y轴都设置成logscale 2. set format 设置坐标轴上数字的格式。 以1000为例： set format x &quot;10^{%L}&quot; 显示出来的格式为10^3 set format x &quot;%2.0t{\327}10^{%T}&quot; 显示为1×10^3 需要注意的是： {\327}是乘号，需要将编码指定为set encoding iso_8859_1才可以使用 %t与%T 比如1200, %t=1.2 %T=3。这种写法可以方便的描线性标度下的较大的刻度。 3. offset x,y 设置label到坐标轴的距离， 0,0 是默认距离 e.g. set xlabel &quot;123&quot; offset 1,0 4. set ticscale n m Command set ticscale n m changes the length (size) of tics. The major tics are multiplied by the provided value n, while the minor tics are multiplied by m. 只改major tics:set tic scale 2 5. 字体font: (1) gnuplot-5.0.1 manual: All PostScript printers or viewers should know about the standard set of Adobe fonts Times-Roman, Helvetica, Courier, and Symbol. 注意：TimesNewRoman和Times（又称TimesRoman）是几乎一样的 (2) TimesRoman和TimesNewRoman都是一样的 For other fonts, 尽管程序不会报错，但也显示不出来 但是可以加粗/斜体 （可以参看http://www.manpagez.com/info/gnuplot/gnuplot-4.4.0/gnuplot_390.php） 6. tc (textcolor) 7. border set border lw 3 只改变线的宽度 8. key set key height #调节key与坐标轴的距离 set key spacing 1.3 #调节两行之间的距离 set key maxcols/maxrow set key autotitle 9. label 设定位置时候，是设定的左下角的坐标 用法：·set label 1 ‘20%wt’ at graph 0.42,0.92 font ‘,50’· 10. arrow 控制起始/终止位置 set arrow from 坐标 to 坐标 e.g.: set arrow from 9.5,3.8 to 9.5,1.8 nohead lt 5 lc rgb &quot;black&quot; set arrow 1 from (log10(50000)),-1 to (log10(50000)),2 nohead lt 5 lc rgb &quot;black&quot; &quot;arrow 1&quot;中&quot;1&quot;是一个标记数组，方便arrow的管理，比如unset arrow 1就取消arrow 1。 控制head e.g.: set arrow from -4,-4 to 4,-4 head filled size screen 1,30,55 lw 2 lt 2 lc rgb &quot;cyan&quot; 其中head filled size 1,30,55 为控制head的格式。 size &lt;length&gt;,&lt;angle&gt;{,&lt;backangle&gt;} length是长度,加上screen是代表屏幕长度，也就是相对长度；后面两个是箭头与线的角度 11. lmargin rmargin tmargin bmargin(左右上下) 以lmargin为例，lmargin是左侧坐标轴到图左边边界的距离 style：颜色、形状等与审美相关的设置 1. line and point types gnuplot-line-and-point-types 2. most useful point type shape full id empty id square 5 64 sphere 7 65 up-tri 9 66 down-tri 11 67 diamond 13 68 pentagon 15 69 e.g.: p sin(x) w p pt 5 3. 点的颜色的设置方法： lc rgb &quot;red&quot;，或者ls 1也可以！ 4. several color set DSL(domain-specific language) in DSL 有时候一个图里可能有一次画10条线，如果一条一条的画太麻烦了。为此gnuplot内置了自己的DSL。包括循环、逻辑等语句。 0. for、字符串数组 for循环： p for [i = 1:9] sample.i.'.dat' u 1:2 w l ls i t 'p='.i #一次画九条先，每条线有不同的title和linesytle（sytle是自己定义的） 字符串数组 `a=&quot;2 3 4 6 8 9 12 16 24&quot; a被当成字符串数组,word(a,n)是字符串类型。整数可以除字符串，例如864/word(a,1)。sprintf内的变量也可以用864/word(a,1)。 **.**点：字符串连接操作符，只能用于处理字符串和变量，不能处理表达式！！！ 注意：sprintf与C++的sprintf一样，百分号的转义字符是%%。 总结：字符串和文件名都用sprinf；无论是字符类型还是数字类型，都可以用在ls，column这些地方，并且可以进行数学运算。例子可见Paper3_segMSD.plt 1. escape charactor In postscript eps enhanced terminal, use &quot;\\&quot; before an escape charactor to keep its basic form, e.g. , &quot;\\_&quot; representation &quot;_&quot;. 2.各种字符的表达方式，可以google “Syntax for postscript enhanced option” （0）例子：set terminal postscript eps enhanced color lw 3.0 dashlength 3.0 &quot;TimsRoman,50&quot; （1）PostScript Character Codes的模式是T模式；输入&quot;set encoding&quot;后是E模式 （2）希腊字母写法的例子：{/Symbol r} （3）上下标同时出现：t@^{\*}_{p}，多用了一个@字符 3. string 单引号内的字符串不转义，双引号内的字符串转义 set title noenhanced #让title的内容直接输出，不进行转义 “.”, “eq” and “ne&quot; Three binary operators require string operands: the string concatenation operator”.&quot;, the string equality operator&quot;eq&quot;and the string inequality operator&quot;ne&quot;. The following example will print TRUE. if (&quot;A&quot;.&quot;B&quot; eq &quot;AB&quot;) print &quot;TRUE&quot; 4.print &quot;hello world!&quot;]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>画图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim笔记]]></title>
    <url>%2F2017%2F08%2F01%2Fvim%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[记录用过的命令，方便以后查找。不包含太简单的或太难的。 删除线代表已经非常熟练的掌握，不需要再看了。 vim下命令： (3) :.,$ s/str1/str2/g 用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1 其中.代表当前行，$代表最后一行，而.,$就代表从当前行到最后一行 也可以这样 :.,.+8 s/str1/str2/g， 其中.,.+8代表从当前行到从当前行开始下面第8行。 例如：如果当前行是第二行，那么:.,.+8 s/str1/str2/g等价于:2,10 s/str1/str2/g (4) s/\(love\)able/\1er/ # 会将loveable替换成lover，\1代表第一对小括号内的匹配项 (6) 读入文件 :23r input_file，在当前文件23行将input_file的内容插入近来 (7) &lt;leader&gt; is backlash (8) “+y 复制到系统剪贴板 (11) Vu(VU) # V mode下，大小写转换 (12) :!pwd # Execute the pwd unix command, then returns to Vi (13) !!pwd # Execute the pwd unix command and insert output in file (14) vim中的g(global)和%的区别： g:全局的 s/pattern/replacement/ : 替换行中出现的每一个pattern g/pattern/s/pattern/replacement/g : 开始处的g是全局命令，意味着对所有与地址匹配的行进行改变。结尾处的g是一个标志，意味着改变一行上的每个。 linux中的grep = g/rep/p %:代表这文件本身每一行 (15) 全部格式化: gg=G (16) vi如何关闭打开的多个文件中的一个? 切换到你想关闭的 文件窗口. 然后输入 :bd 即 : buffers delete 就可以关闭了. (17) 两条命令合在一起用 :%s/abc/def/ | wq 移动 zz 光标所在行居中 20| 到第20列！【Normal mode】 多个文件同时处理 文件以tab打开 12:args *.c:tab all or vim -p *.h *cc Run a command in multiple buffers 将所有文件进行格式化，并写入所有文件 12:tabdo Autoformat:wa 替换、查找 去掉换行符^M: 输入以下字符串: %s/^M//g (注意，^M = Ctrl v + Ctrl m，而不是手动输入^M) 换行符可以用\n直接匹配，用\r添加 对文件内含有特定字符的行操作。 g/-/s/^/#/ 是把所有含‘-’的行注释掉 /open\c 其中 \c表示忽略大小写 vi（lzy0xa@192.9.207.102）的正则表达式中H[1-9]*并不能match H20 ,因为这里vi认为*是匹陪[1-9]中的数，而不是匹配所有的字符。要想匹配H20、H320、H308之类的字符串就需要用H[0-9]* 代码折叠 12345set foldmethod=indent set foldnestmax=10 set nofoldenable &quot; makes sure that when opening, files are &quot;normal&quot;, i.e. notfolded. set foldlevel=0 zM/zR zm/zr 大/小写 – 所有/逐层 m/r – 折叠/打开 （对当前折叠）zc/zo zC/zO 大/小写 – 所有/逐层 zf/zd 创建/删除折叠 zj/zk [z / ]z 到当前打开的折叠的开始/结尾处。 显示信息 历史命令 q:或:hist 是否具有某种特性 12:echo has('python3') #0 is false, 1 means true #判断是否支持python3:echo has('viminfo') vimrc Plugin auto-pairs github readme里，有括号包裹单词这个功能，但我尝试多次也没有使用成功。 或对应这一功能（A means Alt, M means Meta, in present context Alt and Meta is the same ），但我在Xshell中用的时候，并没有激活auto-pairs，激活的是linux自带的快捷键–向右移动到词尾。 最终我输入单个括号是用：ctrl+v，（ markdown插件 vim-markdown http://www.jianshu.com/p/24aefcd4ca93 https://github.com/plasticboy/vim-markdown 有用的命令：c 1:Toc YouCompleteMe 需要进入bundle文件夹进行编译 错误YouCompleteMe unavailable: requires Vim compiled with Python (2.6+ or 3.3+) support 明明安装VIM时已经选择支持python3了，为什么还会报错？而且： 1:echo has('python3') #返回值为0，说明在vim中不能正常支持python 这很可能是因为：python运行时找不到库。解决方法就是添加python库的路径到LD_LIBRARY_PATH环境变量： 1export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/anaconda3/lib/ 然而，这样又会导致其他程序找到的是/opt/anaconda3/lib/里的库，而非系统自带的库，例如： 12$ evinceevince: symbol lookup error: /lib64/libgdk-3.so.0: undefined symbol: cairo_surface_set_device_scale 最终解决方法，是分别设置环境变量，例如： 1alias evince='LD_LIBRARY_PATH="" evince' 这样evince启动时，就不会去anaconda的路径里面找库了。 cmd 颜色 .vim/colors/中放置配置文件 :colo 查看当前颜色 noremap：绑定键的时候，不迭代绑定 五中模式代号：nvoic reference vim tutorial 超过130个你需要了解的vim命令 【好】 vim map nmap【非常好，介绍vimrc的一些基本命令】]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令记录]]></title>
    <url>%2F2017%2F07%2F31%2Flinux_command%2F</url>
    <content type="text"><![CDATA[记录用过的命令，方便以后查找。不包含太简单的或太难的。 长度感人。 [TOC] 正则表达式 1.&lt; #匹配词头 &gt; #匹配词尾 2.+ 匹配1或多个 3.？ 匹配0或1个 4.x|y 匹配x或y 5.x{5,10} 匹配x出现5到10次 一句话介绍一个命令： shell 内置 --: a double dash (--) is used to signify the end of command options. 例如ls -- -l中会把-l当成文件名 echo $((a%b)): 余数 资源管理 ulimit: 管理用户占用的资源 nice &amp; renice 命令: 管理任务优先级 pkill -kill -t pts/5: 踢掉相应的用户 sudo sh -c &quot;echo 1 &gt; /proc/sys/vm/drop_caches&quot;: 清理硬盘 iostat -x sdb1 1 3: 显示sdb1的状态，每1秒显示一次，一共显示3次。 键盘 bind -p: 查看所有的键盘绑定 stty -a: 查看下默认的键位设置 toe /usr/share/terminfo/: supported terminal; you can compare two terminal by infocmp vt100 vt220 其他 tac: cat倒过来写，是将文件反向输出的命令 join命令: 横向连接文件，可以合并第一列 tee: tee file1 file2 - #将标准输出，输出到file1、file2和标准输出（“-”就是代表标准输出）（注意 该命令本身会向标准输出 输出一次，所以tee file1 file2 - 会将标准输出 输出两次） basename &amp; dirname: 从路径名得到root部分和文件名部分 read: read -p &quot;make dir now?[y/n]:&quot; select#直接读入变量值 df -T: 显示硬盘分区类型 lsof: lsof -p 456,123 列出进程456和123所有打开的文件。lsof -i 6 列出所有IPv6协议的网络文件 ssh -X: Enables X11 forwarding然后就可以用vmd、gnuplot等软件了。 env: 输出所有环境变量 ldd ./exe: 给出链接的库 systemctl start atd: arch中用at，需要开启 gimp: 看图png,jpg,bmp都能看 info &amp; whatis: they tell the information of a command; Note that in OS, info whatis will get “search database …” linux Command line Ctrl + a, Ctrl + e, alt + f 前进一个单词、alt + b(通过xshell并不好使): 谁用谁知道 Ctrl + f, Ctrl + b 前进一个字母/后退一个字母 Ctrl + 方向键左键 光标移动到前一个单词开头 Ctrl + 方向键右键 光标移动到后一个单词结尾 ^oldstr^newstr 替换前一次命令中字符串 同时head&amp;tail: ls | (head;tail) 或者 (head; tail) &lt; file !系列命令 !-n， 重复执行倒数第 n 条命令，n 为正整数； !!， 重复执行上一条命令。该命令等价于 !-1；!?str，重复执行最近一条包含字符串 str 的命令； !#，引用当前的命令行，例如：cp filename filename.bak 可以写为 cp filename !#:1.bak !^ 重用上一条命令的第一个参数； ls /usr/share/doc /usr/share/man; cd !^# 即 cd /usr/share/doc !* 重用上一条命令的所有参数； touch a.txt b.txt c.txt vim !* # 即 vim a.txt b.txt c.txt !!:n 重用上一条命令中的第 n 个参数，n 为正整数。 vim {a..c}.txt vim !!:2 # 即 vim b.txt !str:x-y 重用上一条以 str 开头的命令的第 x 到第 y 个参数； touch a.txt b.txt c.txt d.txt vim !touch:2-3 # 即 vim b.txt c.txt !?str:n* 重用上一条包含 str 的命令的从第 n 个到最后一个参数； vim foo.h foo.cc bar.h bar.cc wc !?vim:2*# 即 wc foo.cc bar.h bar.cc 参数的子字符串 利用 :h 截取路径开头，相当于 dirname 12ls /usr/share/fonts/truetype/dejavu cd !$:h # 即 cd /usr/share/fonts/truetype 利用 :t 截取路径结尾，相当于 basename tar zxf !$:t # 相当于 tar zxf nginx-1.4.7.tar.gz 利用 :r 截取文件名 12gunzip filename.gzipcd !$:r # 即 cd filename 利用 :e 截取文件扩展名 12ls file.jpgecho !$:e # 即 echo jpg&lt;b&gt; 简单记忆： h|t r|e 参数的补全 引子 我们用which &quot;command&quot;命令时，可能感觉到which后面的命令无法补全，很不方便，比如which python3就需要手动输入python3。因此我们不禁希望参数也可以用[tab]补全。 实际上，linux是可以补全参数的。比如zsh就自带补全参数。最主流的bash经过设置，也是可以补全参数的。 bash 中标准补全功能包含了[1]： 路径补全 文件名补全 变量补全 用户名补全 主机名补全 很多人比较熟悉的补全可能只有前两项。此外，我们还可以通过complete命令，自定义补全参数。 以which为例，$ complete -c which，就可将所有命令作为which的参数进行补全了。 complete具有强大的补全功能，更多设置可以参考[1]。 complete CentOS 7.3，在/etc/bash_completion.d/进行设置。 -F设定补全函数 alt 如果不是直接在终端上操作，alt键需要进行设置才能使用。**比如Xshell中，在“属性–键盘–将Alt键作为Meta仿真”打钩，才能使用；OS X上，无法用alt键。**PS：win键盘一般alt键当做Meta键；ALt GR：有些老键盘左边是Alt，右边是ALt GR键 Alt+./Esc+. (!^ !$): 将最近一条命令的参数输出 Alt+ f/b: 向前/后移动一个词 其他 Brace Expansion ls /usr/{,local}/bin，会列出&quot;/usr/bin&quot;和&quot;/usr/local/bin&quot; shell特殊变量 $0 当前shell程序的名字 $1 ~ $9 命令行上的第一到第九个参数 $# 命令行上的参数个数 $*, $@ 命令行上的所有参数 $? 上一条命令的退出状态 $$ 当前进程的进程标识号(PID) $! 最后一个后台进程的进程标识号 外部资源链接 更多牛逼命令： http://www.zhihu.com/question/20140085 http://www.zhihu.com/question/20273259 http://www.zhihu.com/question/25910725/answer/31951050 linux shell 快捷键: http://blog.chinaunix.net/uid-361890-id-342066.html 编码 ctrl+h；终端 F1 ascii中Backspace的值为010（八进制），而ASCII values can be represented in several equivalent ways. 而ctrl+h的值也为010。 terminal区分不了二者，因此输入以ascii编码，则ctrl+h变为Backspace；而输入不以ascii编码，Backspace也会显示成^H，即ctrl+h terminal类型的选择也会影响快捷键 Xshell中，文件–属性–键盘–功能键类型 选择xterm R6，则VIM中可以绑定F1；如果选linux，则不可以 系统信息： cpu information cat /proc/cpuinfo 列出内核版本、主机名等信息 uname -a 发行版信息 cat /etc/redhat-release alias命令： http://stackoverflow.com/questions/22537699/cannot-use-alias-while-executing-a-command-via-ssh Quoted from the man page of bash: Aliases are not expanded when the shell is not interactive, unless the expand_aliases shell option is set using shopt … at命令： 介绍：定时执行一次命令。如果想周期地执行命令，请使用crontab at -f work.sh now +3 min 3分钟后执行脚本 work.sh -f指的是从文件读入命令 其他的时间表示法：at 17:30 2/24/99 atq （等于at -l） 查看at任务队列 atrm+任务号 似乎没有单命令行的用法，一般用法都是“at 时间”然后进入at命令，输入要执行的命令，然后退出 awk命令： 替换操作在awk中不易执行。 awk '/pattern/ {print $0 }' filename e.g. awk '/abc/ {print $0 }' filename, 则含有 abcde 的行也会被输出。 awk 'NR==2 {print $0}' aver.tmp awk '$1!~/match_str/ {print $0 }' filename 去掉重复的单词 123456789101112#!/bin/awk -f&#123; for (i = 1; i &lt;= NF; i++) &#123; ++word[$i] if (word[$i] == 1) printf("%s ", $i) &#125; printf("\n")&#125; awk script 1234567891011#!/usr/bin/awk -f#是注释符号BEGIN &#123;......&#125;&#123; #这个中括号不能省略......&#125;END &#123;......&#125; 引用外部变量的几种方式： 【来自：http://club.topsage.com/thread-393615-1-1.html】 （1）&quot;'&quot;var&quot;'&quot; ——错。应该是&quot;'&quot;$var&quot;'&quot; （2）awk '{print a, b}' a=111 b=222 yourfile （3）awk –v a=111 –v b=222 ‘{print a,b}’ yourfile （4）【ct】pid=$(ps -f | awk '/gpu='&quot;$gpu&quot;'/ &amp;&amp; !/awk/ {print $2}') ——在//之间，引用外部变量的正确方式是’&quot;$v&quot;’ 引用外部命令的两种方式：【http://hi.baidu.com/gubuntu/blog/item/050398ceb010513fb700c8d0.html】 例:awk '{if(/Beren/) {print $0 | &quot;cut -b 2-&quot; } else print $0}' job.plm 但糟糕的是，上面这条命令的输出顺序与你设想的并不一致 求最大值、最小值、求方差等 1234awk '&#123;if (max=="") &#123;max=$3&#125; else &#123;if ($3&gt;max) max=$3&#125;&#125; END &#123;print max&#125;' file1 awk '&#123;if (min=="") &#123;min=$2&#125; else &#123;if ($2&lt;min) min=$2&#125;&#125; END &#123;print min&#125;' file1 awk '&#123;sum+=$1; sumsq+=$1*$1&#125; END &#123;print sqrt(sumsq/NR-(sum/NR)**2)&#125;' file1 【注意】：中间不能有空行或短行，否则$3=null，而系统会认为null比负数还小，如果数列中含有负数，那么上式就会出现问题 求和 对六百列分别求和 1234for((i=1;i&lt;=600;i++))do awk '&#123;sum+=$'"$i"'&#125;END&#123;print sum/"'"$num_exc"'"&#125;' ttt1.tmp &gt;&gt; datadone 对行求和 12awk -v FS="," -v OFS="+" '&#123;$1="";system("echo $["$0"]")&#125;'awk -F',' '&#123;for(i=2;i&lt;=NF;i++)sum[NR]+=$i;print $1","sum[NR]&#125;' 【来自】http://bbs.chinaunix.net/thread-1384345-1-1.html printf用法 printf &quot;%s %s %s &quot;,$1,$2,$3 求最大值、最小值、求方差等 1234awk '&#123;if (max=="") &#123;max=$3&#125; else &#123;if ($3&gt;max) max=$3&#125;&#125; END &#123;print max&#125;' file1 awk '&#123;if (min=="") &#123;min=$2&#125; else &#123;if ($2&lt;min) min=$2&#125;&#125; END &#123;print min&#125;' file1 awk '&#123;sum+=$1; sumsq+=$1*$1&#125; END &#123;print sqrt(sumsq/NR-(sum/NR)**2)&#125;' file1 【注意】：中间不能有空行或短行，否则$3=null，而系统会认为null比负数还小，如果数列中含有负数，那么上式就会出现问题 awk中 ‘’ 和 “” 【单引号和双引号】 &quot;&quot;是直接输出 ’'是转义输出,'C1’就有特殊的含义 gawk 4.1.0之后才可以原位修改文件 bc命令： 1.m的n次方 echo &quot;m^n&quot;|bc 2.计算π： echo &quot;scale=100; a(1)*4&quot; | bc -l 【附一部分man】 MATH LIBRARY If bc is invoked with the -l option, a math library is preloaded and the default scale is set to 20. The math functions will calculate their results to the scale set at the time of their call. The math library defines the following functions: s (x) The sine of x, x is in radians. 正玄函数 c (x) The cosine of x, x is in radians. 余玄函数 a (x) The arctangent of x, arctangent returns radians. 反正切函数 l (x) The natural logarithm of x. log函数(以2为底) e (x) The exponential function of raising e to the value x. e的指数函数 j (n,x) The bessel function of integer order n of x. 贝塞尔函数 3.做加减法时（比如a*b+c）bc不会读入scale信息，所以要想设定scale，可以写成(a*b+c）/1,除法是一定会读入scale的。（(a*b+c）*1）没有效果，但a*b有效果） 【第二次测试，不存在这个问题了】 bc不能识别形式为科学计数法的输入，如1.2345e+06 convert命令： convert ${i%plt}eps -density 100x100 ${i%plt}tif convert ${i%plt}eps -density 300 ${i%plt}png #300代表dpi animated gif convert -delay 120 -loop 0 *.png animated.gif The delay parameter specifies the delay between frames in 0.01s, while the loop parameter determines how many times the animation runs (the 0 value will run the loop infinitely). source cp命令： cp自动创建层级结构 例子: cp --parents parentdir1/parentdir2/sourcefile destdir/ cut命令： cut命令很好用 awk '/Beren/ {print $0}' tt1 | cut -b 2-cut部分的意思是截取第二个到最后一个字符。 diff命令 1.对比两个文件夹的不同 diff -ruN tmp_galamost-3.0.6/ galamost-3.0.6_origin/ &gt; diff_text echo命令： -e 开启反斜杠转义字符 -E 关闭反斜杠转义字符 -n 去掉echo默认输出的换行符 测试 1234$ echo -e "a\tb\tc\n"a b c$ echo -E "a\tb\tc\n"a\tb\tc\n gprof： http://blog.csdn.net/linquidx/article/details/5916701 http://blog.csdn.net/stanjiang2010/article/details/5655143 gprof -b -A -p -q test gmon.out &gt; x -b选项的作用是输出程序说明，对比加-b选项和不加的情况就明白了 grep命令： -i： 忽略大小写 -v： 不显示匹配的项 同时匹配多个关键字: grep &quot;str1\|str2&quot; kill命令： 如果要让它恢复到后台，用kill -CONT 1234 （很多在前台运行的程序这样是不行的） kill -STOP 1234 如果要恢复到前台，请在当时运行该进程的那个终端用jobs命令查询暂停的进程 ls命令： 1.只显示文件 ls -l | grep ^- | awk '{print $9}' ls -1 -F | grep -v [/$] 2.只显示文件夹 只显示文件夹： ls -d */ -d的意义: 显示目录本身的信息，而不是列出目录下的文件 ls *： 显示所有文件、文件夹及其中的文件(文件夹) ls -d *: 显示所有文件、文件夹 查看linux进程的执行文件路径 1、以超级用户登陆 2、进入/proc目录 3、ps查看所有符合./cmd的进程，找出其对应的PID进程号 4、用ll命令： ll 进程号 如下显示一个示例： [root@Cluster1 proc]# ll 22401 (proc文件夹中有对应PID码的文件名,进入即可) total 0 -r--r--r-- 1 zhouys zhouys 0 Dec 11 11:10 cmdline -r--r--r-- 1 zhouys zhouys 0 Dec 11 11:10 cpu lrwxrwxrwx 1 zhouys zhouys 0 Dec 11 11:10 cwd -&gt; /home/zhouys/sbs/bin -r-------- 1 zhouys zhouys 0 Dec 11 11:10 environ lrwxrwxrwx 1 zhouys zhouys 0 Dec 11 11:10 exe -&gt; /home/zhouys/sbs/bin/cbs (deleted) dr-x------ 2 zhouys zhouys 0 Dec 11 11:10 fd -r-------- 1 zhouys zhouys 0 Dec 11 11:10 maps -rw------- 1 zhouys zhouys 0 Dec 11 11:10 mem -r--r--r-- 1 zhouys zhouys 0 Dec 11 11:10 mounts lrwxrwxrwx 1 zhouys zhouys 0 Dec 11 11:10 root -&gt; / -r--r--r-- 1 zhouys zhouys 0 Dec 11 11:10 stat -r--r--r-- 1 zhouys zhouys 0 Dec 11 11:10 statm -r--r--r-- 1 zhouys zhouys 0 Dec 11 11:10 status /proc文件系统下的 进程号目录 下面的文件镜像了进程的当前运行信息， 从中可以看到： cwd符号链接的就是进程22401的运行目录； exe符号连接就是执行程序的绝对路径； cmdline就是程序运行时输入的命令行命令；本例为：./cbs cpu记录了进程可能运行在其上的cpu；显示虚拟的cpu信息 environ记录了进程运行时的环境变量 fd目录下是进程打开或使用的文件的符号连接 ... 通过cwd直接进入进程运行目录，通过查看相关信息就可以定位此目录对应那个端口号，以及 定位是那个应用才使用此服务程序。 5、`ps -aux` 命令 ps也可打印其路径,但不是万能的,有些路径只能使用以上两种方法取得 ln ln source target hard link hard link是两个文件共享一个inode，然而各种编辑器编辑文件时（例如vi, Mou），是会重新生成一个文件并删除老文件的，这导致inode变化。所以hard link是几乎没用的功能：因为文件的inode经常会变。 删除文件夹的软链接 例如mydir是一个文件夹的软链接，如果想删除软链接，我们一般的操作为，rm my[tab]以补全文件名，结果为： rm mydir/ 然而这样删除会提示：rm: cannot remove ‘test’: Is a directory。 这时候千万不能加上-r，如果加上，会把软链接的源文件删除掉！ 正确删除文件夹软链接的命令为：rm mydir mkdir命令： 在预设情况下目录得一层一层的建立，但通过-p参数，就可以之间建立。 printf命令： 1.补零 printf &quot;%05d&quot; 123 结果是：00123 参考：http://blog.csdn.net/truelie/article/details/1692942 ps命令 linux查看进程启动时间(运行多长时间) ps -eo pid,lstart,etime | grep your_pid sed命令： sed命令详解 抓取第m 到 第n行： sed -n &quot;m,np&quot; filename sed -n &quot;$[$fl*($i-1)+1],$[$fl*$i]p&quot; ../../precopy/h-tail-10 &gt; frame$i 在file1第3行之后插入file2: sed '3 r file2' file1 将“vel[i].x vel[i].y vel[i].z”替换成“velx[i] vely[i] velz[i]” s/\[i\]\.\([xyz]\)/\1[i]/g &amp;字符 : 代表其前 pattern 字串 例：sed -e 's/test/&amp; my car/'替换后变为：test my car 在有字符串33的行的行首，添加 sed -i '/33/s/^/#&amp;/' t1.plm 注意为什么要有^： 有“^”，“&amp;”代表的是有字符串33存在的整行 没有“^”，“&amp;”代表的是字符串33 将原来的所有空行删除并在每一行后面增加一空行 sed '/^$/d;G' file3 在指定(export)行前面加行 sed '/export/i xxx' file或sed '/export/i \xxx' file 在指定(export)行前面后行 sed '/export/a xxx' file或sed '/export/a \xxx' file 单引号的转义 '\'' sed 's/'\''//g'# 将单引号替换为空格 匹配空行 正常匹配空行是^$；但是对于从windows拷贝过来的文件，要用^.$匹配 而vim（版本8.0）内置的sed，不论文件来自哪种系统，都可以用^$匹配 指定行添加内容 sed -i '1 i \#!/home/ct/bin/gnuplot5/bin/gnuplot5/' gnu.plt 外部变量 sed 's/standard/'&quot;$i&quot;'/' sed -i会使软链接失效 --follow-symlinks可以保持软连接 同时取代多个字符串 sed -e 's/str1//;s/str2//' filename sort命令 按第二行排序 sort -n -k2 file scp命令 scp与软链接 会把软链接的文件都拷贝过去！正确的拷贝方法为：123sudo tar -czvf test.tgz testscp ~/test.tgz sudo tar -xzvf test.tgz -C . ssh命令 有的命令source .bash_profile 例如：sshpass -p 'password' ssh -o StrictHostKeyChecking=no -l lzy&quot;$i&quot; 192.9.207.204 &quot;source .bash_profile;/opt/sge/sge6_2u4/bin/lx24-amd64/qstat&quot; su命令： 1.关于login （1）.直接登录root （2）.由其他用户名登录到root: su -，否则就是没有login （3）su -c 'command' time命令 time ./program 参数：-p 以秒为默认单位来进行输出 top命令： 1.查看内存 可以直接使用top命令后，查看%MEM的内容 查看用户ct的进程的内存： top -u ct 查看特定进程的内存：top -d 1 -p pid [,pid ...] //设置为delay 1s，默认是delay 3s；如果想根据内存使用量进行排序，可以shift + m（Sort by memory usage） uniq命令 uniq -c 在每行行首加上本行在文件中出现的次数(count)。它可取代-u加-d。 xargs命令 &amp; find命令： awk '{print }' filenames | xargs du -h 文件filenames中存储了一些文件名，用这种方式，可以看到每个文件的大小 find . -name &quot;pa*.xml&quot; | xargs -n 10000 rm -f find + xargs 是“Argument list too long”问题的标准解决方法，find命令是持续输出的，而xargs再将find的出处分成若干段，再进行下一步处理 `find -name *.dcd | tee -a dcd_name | xargs rm &amp; 删除文件，并将删除的文件的路径输入到dcd_name中 批量转换文件格式1ls *.jpg | xargs -I&#123;&#125; -P 8 convert "&#123;&#125;" `echo &#123;&#125; | sed 's/jpg$/png/'` 其中-P代表进程数； -i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给{}，可以用{}代替。” 在当前这个命令下，以tmp.jpg为例，实际上执行的是 convert tmp.jpg tmp.png yum命令 yum install foo yum remove foo yum list *foo* #You can rearch the available packages yum localinstall foo.rpm 逻辑表达式与&amp;&amp;和||： 逻辑表达式 （1）C语言中写法： if (a == b &amp;&amp; a == c) shell 中的写法： if ([ $a -eq $b ] &amp;&amp; [ $a -eq $c ]); then (2) C 语言中的写法： if (a == b &amp;&amp; a == c &amp;&amp; b == c) shell 中的写法： if [ $a -eq $b -o $a -eq $c -o $b -eq $c ]; then if [ $a -eq $b ] &amp;&amp; [ $a -eq $c ] &amp;&amp; [ $b -eq $c ]; then 注意：“[”或“]”与表达式之间必须要有空格。 [[ ]] vs. [ ] [2] [ ]是shell built-in，而[[ ]]不属于POSIX； [ ]会展开a*，所以用它的时候需要加双引号：[ &quot;$var&quot; ]；[[ ]]不需要 [ ]会fork a new process，[[ ]]不会 &amp;&amp;和|| &amp;&amp;和||与逻辑表达式表面相似，实则完全不同，如果混淆了会导致严重的错误。 command1 &amp;&amp; command2，如果command1返回值为真（$?==0），才会执行command2。一般命令正确执行了，都会返回0。 command1 || command2则是command1返回值为假（$? != 0）才执行command2。 关于这两个算符，还有个隐僻但重要的问题是command1 &amp;&amp; command2的返回值，如果command1返回值为假，整个表达式的返回值也为假，表达式所在的脚本的返回值也为假！。 有不少人认为[ ... ] &amp;&amp; ...和if语句效果一样但更简洁，这种想法是错误的，因为前一种用法会影响程序返回值，而if语句不会。如果在脚本中用前一种方法，会莫名其妙的导致返回值为假又没有任何报错。 脚本注意事项： declare -A var # 声明为关联数组 declare -a var # 声明为数组 二者很不同 关联数组定义的后面不能加# 例如：array=([seg]=100)# 这样会出问题 命令中blank space是不能随便加的 Because blank space is usually used as the separater of command or agruments. &lt;&lt;block #&lt;&lt; 和 block之间不能有空格 脚本的长度 不要把不同功能写到一个脚本中，尤其是脚本较大的时候。 即使你可以非常顺利的写出脚本的每一句，也不意味着你的脚本可以正常执行。 所以要分块编写:12345!/bin/sh part1.sh part2.sh part3.shexit 优点： 这样编写把part1-3的内容写在一个脚本里执行起来是一样的，但是，像这样将脚本分割，有利于调试脚本。由于脚本过于灵活，所以非常容易出错，而出错几率是和大小成指数关系的。所以要把脚本分化，使每一部分都有明确的意义，一来方便检查脚本是否有误，二来增加代码的重复利用率。 缺点： 传递参数麻烦。 常见错误 循环变量的错误使用 比如说循环变量i，在其他地方是否被改动了？ 这种错误shell是不会检查出来的 Linux 中 10 个有用的命令行补全例子 ↩ ↩ Is double braket preferable over single braket in Bash? ↩]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python mechanism]]></title>
    <url>%2F2017%2F07%2F28%2Fpython_mechanism%2F</url>
    <content type="text"><![CDATA[[TOC] 0. is 与 ==的区别 python对象有三个要素：id、type、value。is 比较的是id；==比较的是value 而id实际上是内存地址，(ob1 is ob2) 等价于 (id(ob1) == id(ob2)) 另外，一些具体的问题，结果不确定，比如用python.py： 12345 &gt;&gt;&gt; x = 500 &gt;&gt;&gt; y = 500 &gt;&gt;&gt; x is yTrue ```language 然而用python或者IPython，结果为False 1. mutable &amp; immutable 不可变（immutable）：int、字符串(string)、float、（数值型number）、元组（tuple) 可变（mutable）：字典型(dictionary)、列表型(list) 2. with 语句 自动进行对象的生命周期进行管理 Python中的with语句中要求对象实现__enter__和__exit__函数。调用with语句时，会先分析该语句，执行__enter__函数，然后在当前suite退出时，会调用__exit__函数。__exit__函数中除了可以做释放资源的操作之外，同时也是异常处理的地方。如果当前suite正常退出，没有抛出任何异常，__exit__的几个参数均为None。否则，则将此异常的type、value、traceback作为参数传递给__exit__函数，同时，如果__exit__返回false，此异常会再次抛出，上一级代码suite可以继续处理，如果__exit__返回true，那么此异常就不会被再次抛出了。 同时打开多个文件 12345with open(filename1, 'rb') as fp1, open(filename2, 'rb') as fp2, open(filename3, 'rb') as fp3: for i in fp1: j = fp2.readline() k = fp3.readline() print(i, j, k) 3. list参数传递 python中的默认变量是定义时得到的，类似于static，其它的时候无论调用几次函数，如果没有传参进来，就会一直用这个默认参数了。 正确做法： 12345def add(element, mylist=None): if mylist is None: mylist = [] mylist.append(element) return mylist 4*. Python中函数的参数传递与可变长参数 【tricky】可变长度参数：*tupleArg,**dictAr 廖雪峰的更详细的介绍 ct总结：参数绑定优先级： 指定参数名 顺序 不符合前两条的可以被可变长度参数捕捉 可变长度参数是通过拷贝传到函数内的！与一般机制不同 限制关键字参数的名字 如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下： 12def person(name, age, *, city, job): print(name, age, city, job) 5. generator 最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。 6. zip() &amp; Unpacking Argument Lists——&quot;*&quot; &amp; “**” The implementation of zip is very beautiful： 来自python doc 123456789101112131415def zip(*iterables): # zip('ABCD', 'xy') --&gt; Ax By sentinel = object() # ct: iterators is a "Iterator" point to the "Iterator" of different parameters(形参) # e.g., at first, iterators is the "Iterator" of 'ABCM'; # iterators.next() is the "Iterator" of 'xy'; iterators = [iter(it) for it in iterables] while iterators: result = [] for it in iterators: elem = next(it, sentinel) if elem is sentinel: return result.append(elem) yield tuple(result) 123456789#zip() in conjunction with the * operator can be used to unzip a list: &gt;&gt;&gt; x = [1, 2, 3] &gt;&gt;&gt; y = [4, 5, 6] &gt;&gt;&gt; zipped = zip(x, y) &gt;&gt;&gt; list(zipped)[(1, 4), (2, 5), (3, 6)] &gt;&gt;&gt; x2, y2 = zip(*zip(x, y)) &gt;&gt;&gt; x == list(x2) and y == list(y2)True Unpacking Argument Lists 12345 &gt;&gt;&gt; list(range(3, 6)) # normal call with separate arguments[3, 4, 5] &gt;&gt;&gt; args = [3, 6] &gt;&gt;&gt; list(range(*args)) # call with arguments unpacked from a list[3, 4, 5] 7. Iterable和Iterator 凡是可作用于for循环的对象都是Iterable类型，它有__getitem__()方法； 凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列，它有__next__()和__iter__()方法； 集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。 Python的for循环本质上就是通过不断调用next()函数实现的，例如： for x in [1, 2, 3, 4, 5]: pass 实际上完全等价于： 首先获得Iterator对象: it = iter([1, 2, 3, 4, 5]) 循环: 123456while True: try: # 获得下一个值: x = next(it) except StopIteration: # 遇到StopIteration就退出循环break while my_iterator（参见zip的实现） iterator最终会返回StopIteration对象，而while可以对其进行判断。 8. 内存 8.1. 释放内存 先del再gc.collect() 9. Python类 9.1. 和静态语言不同，Python允许对实例变量绑定任何数据 也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同： 123456789 &gt;&gt;&gt; bart = Student('Bart Simpson', 59) &gt;&gt;&gt; lisa = Student('Lisa Simpson', 87) &gt;&gt;&gt; bart.age = 8 &gt;&gt;&gt; bart.age8 &gt;&gt;&gt; lisa.ageTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute 'age' 9.2. Python的伪私有属性 Note that user defined attributes shall not end with ‘__’ 9.3. 私有变量的访问方法 不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量。 注意下面的这种错误写法： 12345 &gt;&gt;&gt; bart = Student('Bart Simpson', 98) &gt;&gt;&gt; bart.get_name()'Bart Simpson'&gt;&gt;&gt; bart.__name = 'New Name' # 设置__name变量！ &gt;&gt;&gt; bart.__name'New Name' 表面上看，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量不是一个变量！内部的__name变量已经被Python解释器自动改成了_Student__name，而外部代码给bart新增了一个__name变量。 9.4. 特殊函数__call__模糊了对象与函数的区别 9.5. 类类型的检查–不检查 静态语言 vs 动态语言 对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。 对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了： 12class Timer(object):def run(self): print('Start...') 这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。 Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。 Style guide argument **kwargs is a bad practice: you don’t know how **kwargs affect. wrong keywrod arguments is no longer reported by the interpreter. TypeError 'x' is an invalid keyword argument for this function reference:The Use and Abuse of Keyword Arguments in Python]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人工智能简介]]></title>
    <url>%2F2017%2F07%2F28%2F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[备忘 三巨头介绍[1]：Geoffrey Hinton、Yann LeCun、Yoshua Bengio（年级由大到小） Hinton 多伦多大学 DBN LeCun CNN Bengio attention、GAN 神经网络简介 技术特点和技巧的备忘 单层线性、双层非线性[2] 隐藏层的参数矩阵的作用就是使得数据的原始坐标空间从线性不可分，转换成了线性可分。 层数的影响[2] 参数数量一样的情况下，更深的网络往往具有比浅层的网络更好的识别效率。这点也在ImageNet的多次大赛中得到了证实。从2012年起，每年获得ImageNet冠军的深度神经网络的层数逐年增加，2015年最好的方法GoogleNet是一个多达22层的神经网络。在最新一届的ImageNet大赛上，目前拿到最好成绩的MSRA团队的方法使用的更是一个深达152层的网络！关于这个方法更多的信息有兴趣的可以查阅ImageNet网站。 BP的缺点[3] 基于梯度下降的反向传播法很容易在训练网络参数时收敛于局部极小值。此外，反向传播法训练网络参数还存在很多实际问题，比如需要大量的标签样本来训练网络的权值，多隐含层的神经网络权值的训练速度很慢，权值的修正随着反向传播层数的增加逐渐削弱等。 面对采用反向传播法来训练具有多隐含层的深度网络的网络参数时存在的缺陷，一部分研究人员开始探索通过改变感知器的结构来改善网络学习的性能，由此产生了很多著名的单隐含层的浅层学习模型，如SVM、logistic regression、Maximum entropy model和朴素贝叶斯模型等。浅层学习模型能够有效地解决简单或者具有复杂条件限制的问题，但受限于只含一个隐含层，所以浅层学习模型特征构造的能力有限，不能有效处理包含复杂特征的问题。 LSTM LSTM只能避免RNN的梯度消失（gradient vanishing）；梯度膨胀(gradient explosion)不是个严重的问题，一般靠裁剪后的优化算法即可解决，比如gradient clipping（如果梯度的范数大于某个给定值，将梯度同比收缩）。[4] 历史节点 1943 W.Pitts &amp; W.McCulloch: Concept of ANN(Artificial Neural Network)[3] 1949 D. Olding Hebb: math model 1957 F.Rosenblatt: Perceptron 1969 Marvin Minsky &amp; Seymour Papert: Perceptron’s inability of XOR &amp; limitation of computing power 1974 Paul Werbos: BP(Back Propagation) 1980 Hinton: MLP(Multi_Layer Perceptron) 1982 John Hopfield: Hopfield Network(pioneer RNN) 1998 LeCun: CNN(Convoluted Neural Network) 2006 Hinton, &lt;&gt; DBN(Deep Belief Networks) 2012[2] 深度学习技术又在图像识别领域大展拳脚。Hinton与他的学生在ImageNet竞赛中，用多层的卷积神经网络成功地对包含一千类别的一百万张图片进行了训练，取得了分类错误率15%的好成绩，这个成绩比第二名高了近11个百分点， Jeff Dean &amp; Andrew Ng in GoogleBrain: “the Cat” 名词概念 activation function[2] 【示意效果】 capcity[2] 更多的参数意味着其模拟的函数可以更加的复杂，可以有更多的容量（capcity）去拟合真正的关系。 curse of dimensionality（维数灾祸）[5] 在机器学习里是指随着样本空间和参数空间维数的增加，潜在参数组合的数量指数型增长，相同精确度的预测会需要多得多的训练样本。当训练样本不变时，预测的精度与空间维数的增加成反比。 DBN(深度信念网络) generalization[2] 提升模型在测试集上的预测效果的主题叫做泛化 Grid Search（网格搜索：用尝试的方法选择中间层的节点数）[2] regularization[2] 相关方法被称作正则化。神经网络中常用的泛化技术有权重衰减等。 schools of AI(译为学派)[6] 符号主义(symbolicism)，又称为逻辑主义(logicism)、心理学派(psychologism)或计算机学派(computerism)，其原理主要为物理符号系统(即符号操作系统)假设和有限合理性原理。认为人工智能源于数理逻辑。 连接主义(connectionism)，又称为仿生学派(bionicsism)或生理学派(physiologism)，其主要原理为神经网络及神经网络间的连接机制与学习算法。认为人工智能源于仿生学，特别是对人脑模型的研究。 行为主义(actionism)，又称为进化主义(evolutionism)或控制论学派(cyberneticsism)，其原理为控制论及感知-动作型控制系统。认为人工智能源于控制论。(认为人工智能源于仿生学，特别是对人脑模型的研究。) Training Set, Validation Set and Testing Set; Ground Truth 验证数据用于最小化过拟合(overfitting)。 这数据不调整权重和偏差。在基于训练数据调整权重之后，如果基于训练数据的准确度增加了，而基于验证数据的准确度没有增加或反而下降了，则表明过拟合（overfitting）了，需要立即停止训练。[7] Ground Truth: 正确标注的数据是Ground Truth， 错误的标记则不是。（也有人将所有标注数据都叫做Ground Truth）[7] NN RNN 什么是 LSTM RNN 更多介绍 DNN optimization 待读 link link framework &amp; software Deepchem Developed by Vijia Panda &amp; Schrodinger Company. deepcheem Modeling Small Molecule Toxicity with Graph Convolutions (An Official Example) 刚看完In [2]:部分。 技术评论 技术成熟的条件 Andrew Ng[8] 一个新科技的出现要掐着时间，不能太早也能太晚。比如说iphone，2007年才是它发布的正确时间，而不是在1993年，因为那时的芯片，电池，屏幕技术还没到位。 另外一个极端的例子是达芬奇发明直升机，他发明直升机的时间是1480年代，而飞机引擎技术在1900年代才出现。 还有自动驾驶技术，2007年研究自动驾驶技术还太早，因为AI要用到的传感器还没生产出来。2015年以后，整个自动驾驶的生态系统才算比较完善。 同样在1990年代，网络，视频流还不足以支撑慕课问世，到2011年，整个网络基础建设才为在线视频教育提供了较好的环境。 深度学习也是，90年代数据/计算比较小，浅层算法效果更好。从2007开始，有了大数据做基础，深度学习才取得了更好的效果。 但是，我们还是要感谢历史中所有的革新者，包括早期的那些人，他们的工作对后来的发展进步也非常具有影响和帮助。【现在不叫座，以后可能叫好】 reference 历史 a brief history of maching learning(机器学习简史) 【已读】 可读 colah blog book: Deep learning(Ian. Goodfellow) [book: Neural networks and deep learning(Michael Nielsen)] (www.deeplearningbook.org/) Yoshua Bengio为什么能跟Hinton、LeCun相提并论？ 包含学术传承与贡献的讨论 ↩ 历史|从神经元到深度学习 【可再读】 ↩ ↩ ↩ ↩ ↩ ↩ ↩ ↩ 深度学习技术发展历史及应用现状如何？ ↩ ↩ LSTM如何来避免梯度弥散和梯度爆炸？ ↩ 神经网络的历史？ ↩ 人工智能学派简介 ↩ Training Set, Validation Set 和Testing Set之间的差别及关系 ↩ ↩ 【干货|持更】人工智能产业的相关资料及入门指南 【已读】 ↩]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdf5简介]]></title>
    <url>%2F2017%2F07%2F26%2Fhdf5%2F</url>
    <content type="text"><![CDATA[HDF5 可以存储不同类型的图像和数码数据的文件格式，同时还有统一处理这种文件格式的函数库。 历史 HDF(Hierarchical Data File)是美国国家高级计算应用中心(National Center for Supercomputing Application,NCSA)为了满足各种领域研究需求而研制的一种能高效存储和分发科学数据的新型数据格式。1998年，发布HDF5版本。迄今为5.1版，已经非常稳定。 特性 自述性 对于一个HDF文件里的每一个数据对象，有关于该数据的综合信息（元数据）。在没有任何外部信息的情况下，HDF允许应用程序解释HDF文件的结构和内容。 通用性 许多数据类型都可以被嵌入在一个HDF文件里。例如，通过使用合适的HDF数据结构，符号、数字和图形数据可以同时存储在一个HDF文件里。 灵活性 HDF允许用户把相关的数据对象组合在一起，放到一个分层结构中，向数据对象添加描述和标签。它还允许用户把科学数据放到多个HDF文件里。 扩展性 HDF极易容纳将来新增加的数据模式，容易与其他标准格式兼容。 跨平台性 现代性 支持并行I/O，线程和其他一些现代系统和应用要求。 解决我的trajectory程序的问题：自述性、通用性、扩展性 Why HDF? 有专门的维护： hdfgroup.org NASA’s Earth Observing System等等官网介绍 Caffe等机器学习、深度学习框架原生支持 文档 sphinx 它能够把一组 reStructuredText 格式的文件转换成各种输出格式，而且自动地生成交叉引用，生成目录等。也就是说，如果有一个目录，里面包含一堆reST格式的文档（可能子目录里面也同样存在reST格式的文档），Sphinx能够生成一个漂亮的组织结构以及便于浏览和导航的HTML 文件（这些文件在其他的文件夹中）。 Sphinx介绍：https://zhuanlan.zhihu.com/p/25688826 中文文档：https://zh-sphinx-doc.readthedocs.io/en/latest/index.html# 再通过github部署（专门为生成程序介绍页而设计的功能）：https://segmentfault.com/a/1190000002765287]]></content>
      <categories>
        <category>技术杂烩</category>
      </categories>
      <tags>
        <tag>技术杂烩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git笔记]]></title>
    <url>%2F2017%2F07%2F26%2Fgit%2F</url>
    <content type="text"><![CDATA[git 开始 非常好的入门: 非常好的入门1[1]: 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 非常好的入门2 init config 123git config --global user.name "your name"git config --global user.email "your email"git config --global core.editor "vim #set vim as editor 列出设置的config git config --list difftool 没有默认的difftool，如果首次输入命令git difftool，CentOS会自动推荐kompare。 12Viewing: &apos;particles/BinReader.cc&apos;Launch &apos;kompare&apos; [Y/n]: y kompare的效果非常好。 help git help &lt;verb&gt; 操作 add filename commit git commit -m &quot;your message&quot; Amending the most recent commit message[2] git commit --amend will open your editor, allowing you to change the commit message of the most recent commit. Additionally, you can set the commit message directly in the command line with: git commit --amend -m &quot;New commit message&quot; …however, this can make multi-line commit messages or small corrections more cumbersome to enter. Make sure you don’t have any working copy changes staged before doing this or they will get committed too. (Unstaged changes will not get committed.) reset git reset --hard HEAD^ git reset --hard 3628164 reflog 查看历史命令 与git log的区别：显示整个本地仓储的commit, 包括所有branch的commit, 甚至包括已经撤销的commit, 只要HEAD发生了变化, 就会在reflog里面看得到。 git log只包括当前分支的commit. clone git clone /path/to/repository 如果是远端服务器上的仓库，你的命令会是这个样子： git clone username@host:/path/to/repository git clone git@github.com:dunitian/Windows10.git &quot;F:/Work/WP/Windows10&quot; #到指定文件夹 push git push origin master:master origin is the remote server; the branch name before the colon is local branch name, and that after the colon is remote branch name. e.g.: 12git push origin HEAD:refs/for/branch1 # push HEAD branch to a remote branch git push origin :refs/for/branch1 # delete remote branch git checkout hexo myfile 从hexo分支得到myfile stash[3] 储藏会处理工作目录的脏的状态 - 即，修改的跟踪文件与暂存改动 - 然后将未完成的修改保存到一个栈上，而你可以在任何时候重新应用这些改动。 git stash 临时存储当前状态 git stash list git stash apply (--index) 找回临时存储的状态 git stash drop 删除stash branch git checkout -b dev #-b参数表示创建并切换 git checkout master git checkout --track local_branch origin/remote_branch create a local branch based on a remote-tracking branch. (In recent versions of git the “–track” option is actually unnecessary since it’s implied when the final parameter is a remote-tracking branch, as in this example.)][4] The “–track” option sets up some configuration variables that associate the local branch with the remote-tracking branch. These are useful chiefly for two things: They allow git pull to know what to merge after fetching new remote-tracking branches. If you do git checkout to a local branch which has been set up in this way, it will give you a helpful message such as: 123Your branch and the tracked remote branch &apos;origin/master&apos;have diverged, and respectively have 3 and 384 differentcommit(s) each. git merge dev 合并指定分支到当前分支 git branch -d dev #删除 git branch -r/-a # 查看远程/所有分支； git branch 查看本地分支 git checkout mybfranch # shift to another branch pull git pull origin master相当于git fetch origin # fetch to local repo加上git merge origin/master # origin master shall be in local repo fetch git fetch origin hexo从remote repo获取名为hexo的branch 丢弃 git rm (then git commit) git checkout -- file git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： $ git checkout -- test.txt 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 显示状态 status log git log --oneline --decorate # 加上–decorate 时，我们可以看到我们的标签 remote 看当前配置有哪些远程仓库，可以用命令 git remote 执行时加上 -v 参数，你还可以看到每个别名的实际链接地址。 git ls-files #ls files in present branch git ls-files -u #显示冲突的文件，-s是显示标记为冲突已解决的文件 diff git diff #对比工作区和stage文件的差异 git diff --cached 对比stage和branch之间的差异 git diff master remotes/origin/hexo #对比本地“master” branch和远程“remotes/origin/hexo” branch git diff origin/hexo #对比当前working tree和远程branch rebase git rebase 用法 stackoverflow git rebase --skip git rebase --continue #use this when you solved conflicts. git rebase --abort #放弃当前rebase tag git push origin --tags 其他概念与原理 remote remote是一个相对的概念，一个存储在本地其他文件夹的repo也可以是remote[4] “remotes” are just nicknames for other repositories, synonymous with a URL or the path of a local directory – you can set up extra remotes yourself with “git remote”, but “git clone” by default sets up “origin” for you. origin It’s a repo! 顾名思义，origin就是一个名字，它是在你clone一个托管在Github上代码库时，git为你默认创建的指向这个远程代码库的标签 (远程仓库名)/(分支名) 这样的形式表示远程分支 Note that when git branch -a is used, there is ‘remote’ in front of branch name, e.g.: 1234$ git branch -r orgin/master $ git branch -a remote/origin/master local_branch_name:remote_branch_name # 这是push，pull的时候顺序反过来 远程分支和本地分支的名字相同，可以省略远程分支的名字 upstream vs. origin This should be understood in the context of GitHub forks (where you fork a GitHub repo at GitHub before cloning that fork locally) upstream generally refers to the original repo that you have forked (see also “Definition of “downstream” and “upstream”” for more on upstream term) origin is your fork: your own repo on GitHub, clone of the original repo of GitHub branch &amp; hash[5] you need to understand that branch and tag names are just pointers to hash values, which represent a single commit only two types of branches, and they are storaged in[4]: 12.git/refs/heads/ #[for local branches] **only hash in the file**.git/refs/remotes/ #[for tracking branches] Local branches Remote-tracking branches refspec &lt;source-name&gt;:&lt;destination-name&gt; is a refspec 错误 prompt to input passphrase time and time again: Git enter long passphrase for every push Note that you can use ssh-key only if you use ssh to build remote connections. git remote -v should looks like: origin git@github.com:TimChen314/MDTackle.git (fetch) but not: origin https://github.com/TimChen314/MDTackle.git reference 待读 超好: git cheatsheet 常用git Git 工作区、暂存区和版本库 ↩ How to modify existing, unpushed commits? ↩ 6.3 Git 工具 - 儲藏 ↩ GIT: FETCH AND MERGE, DON’T PULL ↩ ↩ ↩ What’s the difference between git reset --hard master and git reset --hard origin/master? ↩]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shadownsocks备忘]]></title>
    <url>%2F2017%2F07%2F26%2Fshadowsocks%E5%A4%87%E5%BF%98%2F</url>
    <content type="text"><![CDATA[备忘 官网 OS X: 用ShadowsocksX iOS: Wingy windows: Shadowsocks-Qt，可以用二维码进行设置 reference 各种系统下Shadowsocks客户端的安装与配置]]></content>
      <categories>
        <category>shadownsocks</category>
      </categories>
      <tags>
        <tag>shadownsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Story of Terminal]]></title>
    <url>%2F2017%2F07%2F26%2FStory_of_Terminal%2F</url>
    <content type="text"><![CDATA[总结 从本地到远程sever，经过了多个编码环节。从按下一个键到远程server最终反应，经历的过程： 本地terminal类型和编码 -&gt; linux下terminal类型和编码 ctrl+h的编码 ascii中Backspace的值为010（八进制），而ASCII values can be represented in several equivalent ways. 而ctrl+h的值也为010。 terminal区分不了二者，因此输入以ascii编码，则ctrl+h变为Backspace；而输入不以ascii编码，Backspace也会显示成^H，即ctrl+h F1键 terminal类型的选择也会影响快捷键。 Xshell中，文件–属性–键盘–功能键类型 选择xterm R6，则VIM中可以绑定F1；如果选linux，则不可以 问题： 为什么BS无法删除，而是想左移动？ 为什么在执行程序进行输入时，按下BS显示的是^H? 答案 知乎： 1早在 VT100终端时代，^H（ASCII码 0x08）表示&lt;BS&gt; 而 ^? （ASCII码 0x7f）表示&lt;DEL&gt;。过去 0x7f是留给 DELETE键使用的。而到了 VT220时代，DELETE已经变为 ^[[3~ （ASCII 码 0x1b, 0x5b, 0x33, 0x7e 共4个字节），而 ^? 的 0x7f 换给了我们的&lt;BS&gt;，有些老点版本的终端软件，默认 &lt;BS&gt;还是使用 VT100的 ^H，比如 Xshell 4 Build 0142以前的版本，默认&lt;BS&gt;是发送^H。SecureCRT直到6.x版本还在默认发送 VT100的 ^H。 Terminal VT100 Xterms on the other hand, emulate the vt100 terminal, which didn’t have a [Delete]. 123456789101112VT100Key KeySymName Console characters -------------------------------------------------- Ctrl+H ---&gt; Control_H ---&gt; ASCII BS (0x08) [&lt;---] ---&gt; Backspace ---&gt; ASCII DEL (0x7F) --------------------------------------------------Xterm&apos;s emulation of VT100Key KeySymName Console characters -------------------------------------------------- Ctrl+H ---&gt; Control_H ---&gt; ASCII BS (0x08) [&lt;---] ---&gt; Backspace ---&gt; ASCII BS (0x08) [Delete] ---&gt; Delete ---&gt; ASCII DEL (0x7F) VT series have their own keyboard: http://www.vt100.net/ wikipedia: A personal computer can run** terminal emulator** software that replicates the function of a terminal, sometimes allowing concurrent use of local programs and access to a distant terminal host system.]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>编码</tag>
        <tag>Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown in hexo-render-markdown-it]]></title>
    <url>%2F2017%2F07%2F21%2Fmarkdown_in_hexo%2F</url>
    <content type="text"><![CDATA[The implementation of Markdown in different software are always different here or there. To testify the implementation of hexo, syntax page of Mou is pasted in here for comparison. In summary, only inline image is unavailable. PS: spacing can add indent; and code block &amp; quote wouldn’t indent automatically. so indent.sh is used Could add spacing manually by &amp;nbsp; #半角的不断行的空白格 (it works in header, too) &lt;br/&gt; as line break Bug 有时候ordered list序号大于等于10，缩进会失效。 目录不能正常显示，如vim笔记.md Mou Overview Mou, the missing Markdown editor for web developers. Syntax Strong and Emphasize strong or strong ( Cmd + B ) emphasize or emphasize ( Cmd + I ) Sometimes I want a lot of text to be bold. Like, seriously, a LOT of text Blockquotes Right angle brackets &gt; are used for block quotes. Links and Email An email example@example.com link. Simple inline link http://chenluois.com, another inline link Smaller, one more inline link with title Resize. A reference style link. Input id, then anywhere in the doc, define the link with corresponding id: Titles ( or called tool tips ) in the links are optional. Images An inline image , title is optional. A reference style image. Inline code and Block code Inline code are surround by backtick key. To create a block code: Indent each line by at least 1 tab, or 4 spaces. var Mou = exactlyTheAppIwant; Ordered Lists Ordered lists are created using “1.” + Space: Ordered list item Ordered list item Ordered list item Unordered Lists Unordered list are created using “*” + Space: Unordered list item Unordered list item Unordered list item Or using “-” + Space: Unordered list item Unordered list item Unordered list item Hard Linebreak End a line with two or more spaces will create a hard linebreak, called &lt;br /&gt; in HTML. ( Control + Return ) Above line ended with 2 spaces. Horizontal Rules Three or more asterisks or dashes: Headers Setext-style: This is H1 This is H2 atx-style: This is H1 This is H2 This is H3 This is H4 This is H5 This is H6 Extra Syntax Footnotes Footnotes work mostly like reference-style links. A footnote is made of two things: a marker in the text that will become a superscript number; a footnote definition that will be placed in a list of footnotes at the end of the document. A footnote looks like this: That’s some text with a footnote.[1] Strikethrough Wrap with 2 tilde characters: Strikethrough Fenced Code Blocks Start with a line containing 3 or more backticks, and ends with the first line with the same number of backticks: 123Fenced code blocks are like Stardard Markdown’s regular codeblocks, except that they’re not indented and instead rely ona start and end fence lines to delimit the code block. Tables A simple table looks like this: First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell If you wish, you can add a leading and tailing pipe to each line of the table: First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell Specify alignment for each column by adding colons to separator lines: First Header Second Header Third Header Left Center Right Left Center Right More test for hexo-renderer-markdown-it hexo-renderer-markdown-it uses plugins such as markdown-it-sup to implement superscript. all plugins to use a plugin you need npm i plugin-name --save add plugin-name into _config.yml in plugins: part of markdown-it config example superscript: 29^th^ -&gt; 29th subscript: H~2~O -&gt; H2O ==highlight== -&gt; highlight ++inserted++ -&gt; inserted abbrevation The HTML specification is maintained by the W3C And that’s the footnote. ↩]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云邮箱设置记录]]></title>
    <url>%2F2017%2F07%2F21%2Fali_mail_set%2F</url>
    <content type="text"><![CDATA[正文 在阿里云买了域名，阿里云正好（2017-07）有免费赠邮箱服务，所以想把这个邮箱服务用起来。 登录阿里云–&gt;控制台–&gt;域名与网站(左侧菜单栏中)–&gt;企业邮箱–&gt;登录管理员账号(用postmaster@yoursite.com这个账号登录https://qiye.aliyun.com/admin/,这里是负责管理邮箱系统) qiye.aliyun.com/admin/中会显示 邮箱登录地址:http://mail.timchen314.com 访问http://mail.timchen314.com: 温馨提醒：该页面暂时无法访问 尊敬的用户： 您好！ 根据《非经营性互联网信息服务备案管理办法》第十八条法规，您的域名尚未进行备案，暂时无法访问。请参考工信部相关备案流程进行相关操作。 所以，必须要备案后才能使用邮箱服务。 ICP备案是：[1] ICP备案的含义是主机、站长（个人或者法人）、域名和网站经营内容四者的一个绑定认证关系 如果使用了github作为托管主机，是无法备案的。如何选择备案产品类型 如您购买的是其他服务商空间，请联系对应的空间提供商备案；如自己架设服务器，需要联系您服务器的网络供应商，即提供您服务器上网服务的运营商，如电信、联通等。 可能有用[2] reference 阿里云个人网站备案过程全记录 ↩ 可能有用：本博客阿里云配置过程（一）服务器及域名备案篇 ↩]]></content>
      <categories>
        <category>技术杂烩</category>
      </categories>
      <tags>
        <tag>技术杂烩</tag>
        <tag>邮箱设置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo]]></title>
    <url>%2F2017%2F07%2F21%2Fhexo%2F</url>
    <content type="text"><![CDATA[memo 这个网站可以作为参考www.ezlippi.com npm i(nstall) hexo-generator-json-content --save Fix error to ensure “all article” works normally. hexo-footnote(已不再维护) npm install hexo-footnotes --save 如果Hexo不能自动发现插件，则需要手动安装插件5，编辑_config.yml文件： 12plugins: - hexo-footnotes 安装hexo-renderer-marked以支持更多Markdown特性 123npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --savenpm install markdown-it-emoji --save 设置文章置顶 &amp; Cloudinary在线图片服务[1] top: 3 # 数字越大越靠前，默认为0 除了在本地存储图片，还可以将图片上传到一些免费的CDN服务中。比如Cloudinary提供的图片CDN服务，在Cloudinary中上传图片后，会生成对应的url地址，将地址直接拿来引用即可。 在Cloudinary申请账号，上传图片(注意把upload选项中的unsigned signature选上) Cloundinary的免费存储空间还是非常大的cloudinary价格 我的cloudinary 使用方法： 点击图片 点击url 拷贝链接 hexo个人命令 用hexol/hexod命令一次性完成本地/远程预览 配置.bash_profile: 1234export HEXO='/Users/Aether/Documents/hexo_file'export HEXOMD='/Users/Aether/Documents/hexo_file/source/_posts/'alias hexod='cd $HEXOMD &amp;&amp; sh tackle_md.sh &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo deploy'alias hexol='cd $HEXOMD &amp;&amp; sh tackle_md.sh &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo s' tackle_md.sh自动调整缩进、设置部分显示(for next theme) 1234#!/bin/shsh indent.shsh read_more.sh 其中，indent.sh: 12345#!/bin/sh# indent for code blocksed -i 's/^```[a-z]/ &amp;/g' *.md# indent for quotesed -i 's/^&gt;/ &amp;/g' *.md read_more.sh: 12345678910#!/bin/sh# if no "&lt;!-- more --&gt;" in *.md file, adding it into the file.for md_file in $(ls *md)do stat=$(grep "&lt;!-- more --&gt;" $md_file) if [ -z "$stat" ];then sed -i '20a &lt;!-- more --&gt;' $md_file fidone yilia theme image file path hexo_file/themes/hexo-theme-yilia/source/img theme-yilia yilia next theme 要想显示标签页，需要手动操作，详见[2] 添加搜索[3] 在os X safari上无法正常使用，原因不明；在os X chrome上和win7 chrome上都可以正常使用 12npm install hexo-generator-search --savenpm install hexo-generator-searchdb --save 如何设置页面文章的篇数？[4] 123npm install --save hexo-generator-indexnpm install --save hexo-generator-archivenpm install --save hexo-generator-tag 设置social_icons next是通过FontAwesome进行图标设计的，FA支持的图标都在主页上。 目前FA不支持知乎，所以随便选了个fa-bed作为icons。设置中写为zhihu: bed 设置文章标题的格式[5] 直接用html就可以 title: &lt;font size=6&gt;&lt;b&gt;人工智能简介 next themes的配置文件在themes/next/source/css/_variables/custom.styl 12$font-size-headings-base = 28px$font-size-headings-step = 2px hexo bug Error: Cannot find module './build/Release/DTraceProviderBindings' in OS X npm install hexo --no-optional doesn’t work npm un hexo-cli &amp;&amp; npm i hexo-cli -g still encounts bugs, and it’s about dtrace-provider. Then we try to install dtrace-provider: Error: Python executable anaconda3/bin/python is v3.5.2, which is not supported by gyp. If PYTHON=python2.7 npm install dtrace-provider --save is used then a new bug will be reported: xcode-select: error: tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instance This is an error about Xcode, solution link Finally, this DTrace error is solved. References: HEXO搭建个人博客 2个小时教你hexo博客添加评论、打赏、RSS等功能 从搭建hexo个人博客过程中理解学习DNS解析 Hexo Configuration ↩ Next-主题配置 ↩ 参考：Hexo博客添加站内搜索 ↩ Next-常见问题 ↩ set title size ↩]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>yilia</tag>
      </tags>
  </entry>
</search>