<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我们刚刚与一波金融危机擦肩而过]]></title>
    <url>%2Fbaoshang_bank%2F</url>
    <content type="text"><![CDATA[我们刚刚与一波金融危机擦肩而过 来源：北北看剧 这两天光大证券(10.570, -0.23, -2.13%)的PE投资在境外亏55亿的事情刷屏了金融圈。 55亿的事情归纪委管，央行大概只会瞄一眼，他们有一件5500亿，哦不，700000亿的事要先处理一下。 5月24日周五，有一则新闻说“包商银行被接管”，金融圈的一些朋友转了，大部分人都没注意。 但你不知道的是，从那一刻起到现在的十天时间里，我们与一波金融危机擦肩而过。 没人关注“包商银行”是件很正常的事，就像武侠小说里面的小人物，如果不是被主角打死了可能一辈子都不为人知。 “包商银行”原来叫“包头市商业银行”。包头这个地名大部分人应该都知道，但若问在哪个省的什么位置，恐怕超过一半的网友都要先去搜搜地图。 所以“包头市”的“商业银行”这样一个小地方的名称装不下这家银行的大雄心，就改名叫“包商银行”。它之所以雄心勃勃是因为它背后的实际控制人是资本大鳄——明天集团。 包商银行与明天集团的恩怨情仇以及如何完蛋的略去十万字。 看到一家银行完蛋，似乎最担心的应该是个人储户——其实最不用担心的就是个人储户。包商银行的“遗嘱”（债务处置方案）里第一条就是个人储户的钱，国家全兜！ 然后是企业负债，5000万以内的国家也全兜！ 看上去似乎没造成什么损害。 人们喜欢用蝴蝶震震翅膀引发暴风雨来形容（原来这个比喻是用来说明数学上的混沌理论的）金融危机，如果这只蝴蝶是因为有人要抓它而震了震翅膀，会不会把那个人震死呢？当然不会，但是引发的暴风雨却可能把千里之外的某些人淹死。 金融危机也一样，危机源头的人可能毫无损失，而卷起的风暴会让其他人损失惨重。 包商银行事件就是蝴蝶震了翅膀，因为银行倒闭从来都不是简单的事。 包商银行2016年的年报（因为它之后两年没公布年报，这是我们能看到的最近的年报）显示，它的总资产是4315亿（据传被接管前的总资产是5500亿），其中存款1936亿，剩下的2000多亿全是向其他金融机构借来的。 金融机构之间借钱可不象我们小散户那样几百几千，都是以亿为单位，国家兜5000万只是个零头。 5月27日，经过一个周末的打探消息，各家借钱给包商银行的金融机构了解到接管组是听央行的，去包头不如进京找央行。 央行的回复是两种方案：要么打折买断，要么按公告，5000万以内全兜，超过部分等清算。 大家回来一算账，两个方案结果差不多，都是亏海了。 当然金融机构肉厚，亏几个亿亏得起。 问题是，只有一个“包商银行”吗？ 中国的商业银行是分三六九等的。“工农中建”四大国有银行是第一等；招商、兴业、中信、浦发、光大这些是第二等，被称为“股份制银行”；还有数量巨大的城市商业银行是第三等；广大的农村商业银行、信用社是第四第五等。 梯队之间的界限并不是非常明确。比方说交通银行(6.170, 0.01, 0.16%)，有时候往上归入第一等，有时候往下归入第二等。这两年招商银行(35.350, 0.10, 0.28%)的各项业务指标全面超过了交通银行，对交行排第一等肯定不服气。再比方说上海农村商业银行，从名字上看算第四等，但从规模和质量看绝对能排进第二等。 完蛋的包商银行属于比较正宗的第三等。第三等的城市商业银行数量超过一百家。 教科书上说对交易对手的信用情况要进行如何如何评估，如何如何做尽职调查云云，实际操作中要么不看，要么就只看个脸（名字）。 只看脸是有道理的。 首先，第三方给的评级，花钱买的，你会信吗？ 其次，财务报表，也许是真的，但你知道表外资产有多少？你知道五级分类严格不严格？只看一个角，谁知道冰山有多大。 所以大家实际就看个名字，第一等第二等肯定没问题，第三等多半也没事，第四等的稍微当心点，第五等的出了事你自己背别赖到领导头上…… 现在第三等的突然暴雷了。 原来不是说多半没事吗，怎么让领导火烧眉毛了？赶紧调整，只能借给第一等第二等，第三等的没领导批准也不能干，第四第五等的想也不要想了。 于是，一夜之间，城商行、农商行的小伙伴们发觉，他们被银行朋友圈拉黑了。 5月20日到5月24日的那一周，银行间同业存单（银行间互相借钱的一种方式）发行量为5249亿， 5月27日降到655亿， 5月28日，去北京的小伙伴们回来了，降到109亿！ 市场进一步传言，包商银行的质押回购也还不上来，又引发新一波恐慌（当天晚上，央行的官方媒体《国际金融报》赶紧出来辟谣）。 5月29日，130亿。 5月30日，76亿！ 至此，包商银行的单一事件已经有演化为金融危机的苗头！ 金融机构借不到钱是件可怕的事。几乎所有的中小金融机构都存在“期限错配”：他们借给企业的钱期限较长，不是想收回就能收回，向别的金融机构借的钱期限较短，到期了只能靠借新还旧先维持着。如果借不到新钱就只有倒闭。 经过多年的快速扩张，城商行+农村金融机构的总资产规模，已经高达70万亿，而中国2018年的GDP为90万亿元。 更进一步说，过去10年城商行+农村金融机构的扩张远比大行更加激进，所以占整个银行体系的比例，从10年前的5%左右，上升到超过25%。 如果说过去10年中国是全世界经济增长的引擎，那城商行+农村金融机构就是中国经济增长的引擎。这个引擎要是熄了火，真正是“地球都要抖三抖”。 这个冲击力够大吧！ 6月2日，周末还没过完，央行负责人用答记者问的方式，通过新华社发布了《包商银行被接管是个案 当前金融风险总体可控》的新闻，调子和之前对“赴京请罪”者有了180度转弯。 大体上说，平均能赔到90%，小额全赔，大额也能赔到80%（其中承兑汇票超过5000万元部分明确不会低于80%）。 所有的话都是安抚那些金融机构受伤的心灵。“放心吧，亏不了多少钱”，“最近，市场上有人担心，接管包商银行后，是否会有其他机构也被接管，请大家放心，目前还没有这个打算”。大家不要胡思乱想。 原来准备刮骨疗伤、壮士断腕，现在放点血，意思意思算了。 央行既然表态了，我相信接下来大家会表面上若无其事地继续玩下去。一场金融危机化解于无形。 央行的做法完全正确。如果不及时制止危机，这场风暴恐怕难以收场。 危机化解了，问题并没有解决。 6月1日，锦州银行公告称，审计师安永会计师事务所辞职不干了。这是一家在香港上市的银行，因为出不了2018年的年报已经停牌两个月，现在连审计师都落荒而逃了……锦州银行也是一家城商行，根据其2018年中报，总资产7484亿。 翻开央行的网站，到现在还出不出年报的银行超过一打…… 有些人担心金融危机无可避免地要发生，并且引述了1997年东南亚金融危机、1998年墨西哥俄罗斯金融危机、2008年美国次贷危机引发全球金融危机的往事。 从这次事件的处置来看，中国央行是非常清醒的。到处都有蝴蝶震动翅膀，重要的是在酿成暴风雨前斩断传递的链条。 中国和上述这些国家不同，中国央行的手段足够、资源足够、信誉足够。 不发生金融危机是我们金融监管的底线，去杠杆的道路艰难且漫长。 reference]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fehtereum%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[matplotlib]]></title>
    <url>%2Fmatplotlib%2F</url>
    <content type="text"><![CDATA[very good tutorial matplotlib和PIL打开图片的方法 command figure size 12plt.figure(figsize=(20,10)) # this command shall be at beginning.&lt;!-- more --&gt; Based on ref matplotlib.pyplot.figure, the default size of a plot is 6.4 and 4.8. rcParams[&quot;figure.figsize&quot;] = [6.4, 4.8] subplots size fig, ax1 = plt.subplots(figsize=(20, 10)) 如果不用上面的命令，而用ax.figure.set_size_inches(50,10)，不好使。 other thins plt.figure(dpi=80, facecolor='w', edgecolor='w') line plt.plot(X, C, color=&quot;blue&quot;, linewidth=1.0, linestyle=&quot;-&quot;, label=&quot;balala data&quot;, marker='tri', markersize=3,) limit (range) plt.xlim(-4.0,4.0) legend plt.legend(loc='upper left') ticks plt.xticks(np.linspace(-4,4,9,endpoint=True)) label of axis plt.xlabel(&quot;This is X axis&quot;) point style For style of point, see [1] and [2] save/load save plt.savefig(&quot;name.png&quot;) Note that plt.show() will clean the content, so savefig should be in front load 12img = mpimg.imread("3732video_star_distri.png")plt.imshow(img) histogram plt.hist(mydict.values(), bins=10) add additional ticks 123456lines = plt.plot(x,y)ax = lines[0].axeslim = ax.get_ylim()ax.set_yticks(list(ax.get_yticks()) + extraticks_list)ax.set_ylim(lim) ref: adding extra axis ticks using matplotlib arrow plt.arrow(datetime(2018,4,21), 1.268, 30, 0, linestyle=(0,(5,10))) 注意：是(x,y,dx,dy)，第三个和第四个参数是箭头的长度；这里30被当做30天；(offset,(onoffseq))格式的参考可见：linestyle add x2 axis ax2 = ax1.twinx() ref: example code concept axes Figure &gt; axes ref: What is ‘axes’(NOTE: not ‘axis’) plot vs. subplot vs. figure.add_subplot() ref: What is the difference between drawing plots using plot, axes or figure in matplotlib? global setting 12mpl.rcParams[&apos;xtick.labelsize&apos;] = 24mpl.rcParams[&apos;ytick.labelsize&apos;] = 24 font 12345font = &#123;'family' : 'normal', 'weight' : 'bold', 'size' : 22&#125;matplotlib.rc('font', **font) ref: matplotlib.pyplot.plo ↩ marker example ↩]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ethereum & web3.py]]></title>
    <url>%2Fethereum%2F</url>
    <content type="text"><![CDATA[Web3.py gasPrice from mainnet gasPrice=w3.eth.gasPrice etherscan 12url="http://api.etherscan.io/api?module=account&amp;action=txlist&amp;address=" + address + \ "&amp;startblock=0&amp;endblock=99999999&amp;page=1&amp;offset=2&amp;sort=asc&amp;apikey=FGYXPUXVQV4Z992UJFP11U5SV3UJVYSFQQ" desc/asc sort=desc means get the earliest first; sort=asc verse vise. page/offset page and offset shall use cooperatively. offset means how many items in a page! reference]]></content>
      <categories>
        <category>python, ethereum</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[block chain妙用]]></title>
    <url>%2Fblockchain_magic%2F</url>
    <content type="text"><![CDATA[这是历史性的一个事件： 在遭遇了半夜一点被叫起来强制删帖之后，北大学生将沈X阳事件中自己的遭遇写入了以太坊&quot;input data&quot;中，这意味着这一文件永远无法被删除了! Etherscan 点击&quot;Convert to ACSII&quot;，就可以看到内容。]]></content>
      <categories>
        <category>block chain</category>
      </categories>
      <tags>
        <tag>block chain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python cookbook note]]></title>
    <url>%2Fpython_cookbook_note%2F</url>
    <content type="text"><![CDATA[python cookbook 非常好！ 第一章：数据结构和算法 1.1 解压序列赋值给多个变量 例子： 12data = [ 'ACME', 50, 91.1, (2012, 12, 21), 98 ]_, _, weight, (year, month, day), _ = data 学到：tuple可以解压；可以多层解压；不想要的变量用_接受； 1.2 解压可迭代对象赋值给多个变量 可用来分割字符串以及其他多种用途；可以抛弃（用_或ign）/接受任意多个元素；*表达式解压出来的数据，无论是0个还是n个，type都是list。 12line = 'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false'uname, *_, homedir, sh = line.split(':') 还能用这种分割语法去巧妙的实现递归算法： def sum(items): head, *tail = items return head + sum(tail) if tail else head 1.3 保留最后 N 个元素 学到了deque(maxlen)和for line in file_f: 1.4 查找最大或最小的 N 个元素 learn headq module (For details see python note ) 当要查找的元素个数相对比较小的时候，函数 nlargest() 和 nsmallest() 是很合适的。 如果你仅仅想查找唯一的最小或最大（N=1）的元素的话，那么使用 min() 和 max() 函数会更快些。 类似的，如果 N 的大小和集合大小接近的时候，通常先排序这个集合然后再使用切片操作会更快点 （ sorted(items)[:N] 或者是 sorted(items)[-N:] ）。 需要在正确场合使用函数 nlargest() 和 nsmallest() 才能发挥它们的优势 （如果 N 快接近集合大小了，那么使用排序操作会更好些）。 第二章：字符串和文本 2.1 使用多个界定符分割字符串 第四章：迭代器与生成器 4.3 使用生成器创建新的迭代模式 例子： 12345678def frange(start, stop, increment): x = start while x &lt; stop: yield x x += incrementfor n in frange(0, 4, 0.5): print(n)list(frange(0, 1, 0.125)) for和list()都是调用了frange的next。 第九章：元编程 9.1 在函数上添加包装器 9.2 创建装饰器时保留函数元信息 9.3 在函数上添加包装器 reference]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Digital Currency Market]]></title>
    <url>%2Fbtc_market%2F</url>
    <content type="text"><![CDATA[市场 2018.01.08 Total Market Capitalization is up to 820 billion dollars, which is roughly equivalent to one year GDP of Turkey. Info source bitcoinity有相对可靠地成交量的数据 现货交易所 靠谱交易所： 币安Binance 从零开始的比特币购买与储存图文教程 费用：充值免费；提现：0.0005 BTC ≈ 3到5$；交易: 0.1% huobi，一般用手机号登录，不像其他网站用邮箱 [x] 杠杆 otcbtc 如何购买 Cardano(ADA) 或其它加密币？ 场外交易所localbitcoins.com 全球最大 用法 btc交易份额： https://coinmarketcap.com/currencies/bitcoin/#markets 可以注册火币 币安或者OKcoin 先用法币购买usdt 然后就可以购买比特币或者其他的了 不靠谱/不方便 OKEx 份额世界最大 国内团队 交易量造假 bitstamp 注册于卢森堡 gdad 美国加州 属于Coinbase公司 bitfinex 香港 场外交易所coincola.com 骗子交易所 火币huobi 溢价(时间为02.08 16:30) 品种 实价￥ 估价￥ 溢价比率(%) BTC 53800 52430 2.6 ETH 5388 5244 2.7 USTD 6.44 6.31 2.0 费率 ETH/USTD 0.2% ETH提币 0.01ETH btc提币 0.001btc（这是btc网络交易费） ustd提币 10ustd 总结：提币费用总在10美元左右 app 需要香港的apple ID； 申请而香港apple ID需要通过电话或银行卡绑定才能使用，而异地申请香港银行卡非常麻烦。 如何办理香港银行卡？2017最新收藏版！ 聊聊怎么低成本在香港开户一张银行卡 工銀亞洲內地客戶見證開戶服務介紹 购买需要香港的apple ID 首先，美国的不行，美国apple ID还要绑定美国的信用卡； 第二，香港apple ID只在app store登录，只要不等度iCloud，就绝不会影响账号安全！ 第三，app分用人民币交易的场外app和用数字货币交易的币币app，apple ID只能下载到币币app 第四，场外app，要首先登录huobi官网，扫描二维码进行下载，再对app授信，才能使用。 otcbtc 2018-04-26记录 品种 提币费 提币费￥ BTC 0.001 57 ETH 0.003 12 BCH 0.001 8.5 LTC 0.01 9 XRP 0.02 1 ADA 0.5 1.75 USTD 5 31.5 另外，otcbtc的点差非常大！2018-04-26的XRP，买5.20卖5.0，点差达到4%！火币不存在这个问题！ 火币的点差一般为千二左右。 其他分类 ADA ADA官网：可以购买ADA的交易所 现货杠杆： bitfinex 有杠杆没现货 杠杆现货交易所 场外交易 huobi 网站：otc.huobi.pro 成为中间商的要求： 申请表 手持身份证录制视频 押金5000HT 4月24日值7万多人民币。 otcbtc 场外交易没有api。 费用 2018-6-29 23:59前广告免费；手续费： 成交额的 0.5 % localcoins 期货 bitmex交易指南 大幅下跌时会无法下单，例如 18/03/12 22:15–15分钟，成交量5M，9706-&gt;9363 三种价格 最新成交价 网站上彩色大字的是最新成交价。instrument中key为&quot;lastPrice&quot; 价格指数 现货交易所30分钟的平均价格。 altcoin中除了ADA是参考bittrex，剩下的都参考Poloniex。 只用于交割。instrument中key为&quot;indicativeSettlePrice&quot;。 标记价格 强平会参考这个价格，而不是最新成交价。 instrument中key为&quot;fairPrice&quot;。 合约参考价格 BMX指数是由bitstamp和gdad各贡献50%得到的；合约参考价格是基于BMX修正得到的“合理标记价格”。 因为参考价格经过了修正，所以永续合约和季度合约的“标记价格”才不同。 费用 maker &amp; taker maker是限价交易单，提供流动性，有0.25%的返点； taker是市价交易单，抽取流动性，交易费0.75%。 该费用在永续合约与定期合约中都存在。 资金费用funding rate 只在永续合约中存在；每天三次收取，分别在北京时间（4:00, 12:00, 20:00）；多空双方相互支付，比如，如果多单数量比较大，多单向空方支付 定期合约交割 没有找到交割的定义，我猜测，所谓交割就是平仓。 XBT交割费为0.05%，其他币为0.25%（记录于18/03/19）。 存款/提款 无费用 仓位 &amp; 保证金 空仓时，可以以任意价格进行委托；有仓位时，委托价位不能超过爆仓价 逐仓 全仓 跨期保证金 默认情况下所有仓位的最初设置都为 “全仓保证金”。 调整杠杆是整个仓位的杠杆！比如你有5x底仓，然后你想20倍加仓，那你最后的杠杆就是20x。 自动减仓机制 平台会挑选杠杆高、盈利大的仓位，自动减仓，这是为了平掉对手仓，保证平台的流动性。 风险限额： 仓位超过50XBT，会需要额外的保证金，仓位越大，额外保证金越多。 限价止损(Stop Limit) &amp; 限价止盈(Take Profit Limit) 写在前面：触发价格默认是参考最新成交价格的，你也可以设置成标记价格或指数价格；如果在“触发后平仓”选项上打钩，那么系统只会减仓不会加仓，由于它们的行为很绕，这样可以防止失误。 首先要注意，在没有达到触发价格之前，是不需要下单保证金的。 其次，这个翻译好像有点问题，Stop Limit和Take Profit Limit并不是意在止损和止盈，它们的行为如下： 限价止损(Stop Limit)，触发价格高于参考价格，只允许买入/做多；触发价格低于参考价格，只允许卖出/做空。这一行为与你持有多仓还是空仓并没有关系！。限价止盈(Take Profit Limit)刚好相反，触发价格高于参考价格，只允许卖出/做空；触发价格低于参考价格，只允许买入/做多。 如何记忆： 对于限价止损(Stop Limit)，为了方便，可以理解成系统是假设你开空的，如果你开了空仓要止损，才会触发价格高于参考价格时买入。 其他 提币时间为每天UTC 13：00前（北京时间21：00）； btc盈亏 btc盈亏$ = (1$/open - 1$/close )*close = close/open = btc/$ 涨跌 例如开1万$多仓，按照美元计价，那么btc价格上涨10%，收益就是1000$；下跌10%，收益是-1000$ Datamish: collecting dada from bitmex Super useful! 期权 只有一个strike price（执行价格），初始价格为现价（最小单位50，比如现价10020，strike price是10000）+1000$。 结算日是每周五的 UTC 12:00:00。 问题 &quot;account has insufficient available balance&quot; 状态： 已开空单，20x 现象： 无法开10x多单 答：杠杆是整个仓位的杠杆，而不是一笔交易的杠杆。由于仓位中可用余额有限，而持仓的合约很多，杠杆只能保持在很高的水平。 429 &quot;你发出太多的请求。请稍候，然后重试。&quot; bitmex自动交易 错误 无法连接服务器（没有翻墙也会导致这个问题） 22:01:47,646 - INFO - ws_thread - Started thread12018-03-23 22:01:52,666 - ERROR - ws_thread - Couldn&apos;t connect to WS! Exiting. api_key错误 21:19:20,598 - INFO - ws_thread - Started thread12018-03-23 21:19:22,799 - ERROR - ws_thread - Handshake status 401 Unauthorized Errno 61 2018-03-29 20:27:00,382 - ERROR - ws_thread - [Errno 61] Connection refused 原因未知。 获取历史数据 18年之前的index、quote、trade已经获得； instrument和instrument/indices只能获取当前数据； quote不好使； 期货基础 BRR()和BRTI（Bitcoin Real Time Index）是CME推出的标准化btc价格指数。 交易所期货：bitfinex、bitmex、okex Market Order , Limit , Stop, Stop Limit 市价、限价、止损/盈、限价止损/盈。Stop采用的是市价。 限价会保证 成交价格，价格达不到就不成交；市价是保证成交，价格达不到就涨/降价格。 已实现亏盈和未实现亏盈 比如bitmex开仓100手，那只有未实现盈亏；如果这100手平掉40手，还剩60手，那么平掉的40手就会产生未实现盈亏。 期货定价机制(bitmex) 比特币以太坊期货等还有个名字叫做“虚拟合约”，本质可以理解为“炒空气”，期货的本质是多空互相博弈，买入来自于平空&amp;开多，卖出来自于开空&amp;平多，交易的平衡最终决定了当前成交价。但是这个价格总会和实币交易有偏差。 Please note that the execution price you see is your bankruptcy price, not your liquidation price. Your liquidation price includes the maintenance margin requirement of 0.5% over 17024, which is 16935. 强制平仓损失=未实现亏+仓位占用的保证金。计算强平价格时候，要把持仓保证金算进去！！！ TIPS: btc期货没有点差 点差–spread 下载大陆用不了的app taobao香港的AppleID就可以。 买来之后只用AppleID登陆app store，而不登录iCloud，就是安全的 美国AppleID不行，还需要绑定美国的信用卡或paypal。注意必须用美国的户头绑定到paypal才有用。 mac上，shadowsocks在命令行下士无效的。想要在命令行下shadowsocks，请参考 Mac命令行终端下使用shadowsocks翻墙。 最终测试可以用curl www.google.com（注意www不能少），成功的话会返回一堆html。 api-connecter中时间单位是秒（例如TIMEOUT = 2） 策略 掉期 hedge 顺势 发动趋势 凯利公式化 少量仓位一百倍杠杆，按照凯利公式的假设，要么翻倍要么赔光 小市值、非空气策略 BNB(17)、LOOM?(67)(New)、HT(66)、ELF?(62)(weak)、NAS?(Nebulas)(56)(weak)、AE(28)、Ont(25)(New)、ADA(7) 交易系统研究 BOLL（布林线） 计算 （1）计算MA MA=N日内的收盘价之和÷N （2）计算标准差MD MD=平方根N日的（C－MA）的两次方之和除以N （3）计算MB、UP、DN线 MB=（N－1）日的MA UP=MB＋2×MD DN=MB－2×MD 信号 对于BTC日线，默认参数(20, 2)似乎确实是最有效的。 20指的是平均的天数；2指的是两倍标准差；后面结论都建立在本条基础之上。 如果阐述设为其他值，比如(99, 2)，那么中线和标准差都有99天的价格计算得到的，那么它对近期的价格变化非常非常不敏感！ 超出上轨/下轨不是一点的，都会回调。 收窄意味着转折可能要发生。 支持信息 交易额比较大的期货品种 金融信息 宏观 比特币价格：与标准普尔 500 指数相关性创新高 背景介绍与这对我们意味着什么？： 首先，金融资产的风险，是由市场来决定的，市场承认它风险低，它才是风险低。在金融市场上，可以将金融资产按风险分类，例如，美国国债是最低风险资产，美股股指是中风险资产，美股高科技公司、新兴市场（印度巴西中国）股指是高风险资产。 当市场认为现在市场整体的风险上升时，资本会向更低风险的资产流动，高风险资产贬值、低风险资产升值。例如，如果经济学家对全球经济增长不看好，那么新兴市场股指就会下跌。 反过来看，要想知道一种资产的风险程度，可以看它与哪种资产的相关性高。**BTC价格与标普500相关性创新高，意味着BTC的风险在降低！**这对BTC是好消息，但对我们是坏消息。因为风险越低的资产，投资者越多，我们获得超额收益的机会就越小…… 金融类文章 bitmex创始人兼CEO写的文章 Basic Basis Trading Strategies，稍微需要点背景知识，感兴趣可以看看。 另外这是CEO亚瑟·海耶斯（ Arthur Hayes ）的介绍，沃顿商学院毕业的，背景很牛：花旗前交易员创立bitmex，仅2018一月利润就达2100万美元 中英文金融词汇表 常用术语的查询可以去：投资百科全书：investopedia arbitrage/hedging – 套利/对冲（套利一般是指跨市场、高频的买卖；对冲是同时开空和多difference between arbitrage and hedging ） bids/asks – 买/卖 expiry – 到期 long/short – 空/多 market/limit – 市价/限价 maturity – 到期 position – 头寸 spot/future – 现货/期货 spread – 点差 Settlement – 交割（bitmex adapt cash settlement） contango/backwardation – 期货升水值/期货贴水值 期权 exercise – 行权（期权术语） Call/put Option – 认购期权/认沽期权 Premium – 权利金，指买进期权合约所需支付的代价，可视为由期权的内在价值及时间价值构成。 stike price – 行权价格 KO(Knock-out) barrier price – 译为“敲出障碍价格”。即期权的止损价格。比如看跌bitmex期权，行权价格7500，敲出障碍价格3750那么：如果到期前跌倒7000，你就赚500；如果到期前跌倒3750，你就赚3750；如果继续下跌、价格低于3750，那么合约终止。这样可以保护看跌期权的做市商不损失太多。 ‘Mutual Fund’ A mutual fund is an investment vehicle made up of a pool of moneys collected from many investors for the purpose of investing in securities such as stocks, bonds, money market instruments and other assets. Mutual funds are operated by professional money managers, who allocate the fund’s investments and attempt to produce capital gains and/or income for the fund’s investors. A mutual fund’s portfolio is structured and maintained to match the investment objectives stated in its prospectus. quote/trade “Quote Data” usually means top-of-book bid/ask data. (Also called BBO=best bid/offer, TOB, inside market, etc.) But more generally it can also mean all the current resting orders sitting on the book at any given time. These are limit orders that are less competitive than ones at the top-of-book. “Trade Data” means the record of trades that were actually transacted. log return[1] 总结：采用log return在数学推导上有很多优点；根据log return也很容易得出raw return log-normality: if we assume that prices are distributed log normally (which, in practice, may or may not be true for any given price series), then log(1 + r_i) is conveniently normally distributed approximate raw-log equality: when returns are very small, log returns are close in value raw returns time-additivity: the product of normally-distributed variables is not normal. Instead, the sum of normally-distributed variables is normal mathematical ease: ln is easy to integration and differentiation numerical stability: multiplying small numbers is not as it is subject to arithmetic underflow, while addition of small numbers is numerically safe. Why Log Returns 写的简单又专业 ↩]]></content>
      <categories>
        <category>block chain</category>
      </categories>
      <tags>
        <tag>block chain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vultr VPS]]></title>
    <url>%2FVPS_Vultr%2F</url>
    <content type="text"><![CDATA[Vultr是老牌的VPS服务商。这里记录一下购买和使用流程。 可以支付宝 费用是随用随扣 买了主机，不想用（比如我因为ping太高了），可以马上销毁，点击&quot;Server Destory&quot;就可以。费用只有几美分。 可以再&quot;Deploy&quot;其他Server。 ping 将VULTR各节点测试地址的结果粘贴到自己的linux/mac的node_info_file文件上，再执行下面shell命令，批量测速。 12345for node in $(awk &apos;&#123;for(i=1;i&lt;=NF;++i) &#123;print $i&#125;&#125;&apos; node_info_file | grep com); do echo $node ping -c 5 $nodedone oneline模式for node in $(awk '{for(i=1;i&lt;=NF;++i) {print $i}}' node_info_file | grep com); do echo $node ; ping -c 5 $node; done &gt; result 结果是Tokyo的机房最快。 给的是root用户 可以自己建普通用户。 Deploy的时候填上ssh-key可以免密登录 这个免密登录只针对root用户，普通用户如果想免密登录，可将/root/.ssh中的内容拷贝到自己的home目录下。]]></content>
      <categories>
        <category>技术杂烩</category>
      </categories>
      <tags>
        <tag>技术杂烩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About Digital Currency]]></title>
    <url>%2Fpri%2Fdigital_currency%2F</url>
    <content type="text"><![CDATA[What a bubble! 总览 Info source Cryptocurrency Market Capitalizations www.8btc.com 很好的网站 http://bitcointalk.org/ 问题与挑战 1. 税收 美国国税局（IRS, Internal Revenue Service）在努力调查bitcoin避税，这是bitcoin正式应用所面临的一个问题。 像达世（Dash）、门罗（Monero）和ZCash等币都部署了隐私功能，其交易是很难被追踪到的。 个人目标 量化策略投资 ICO是一锤子买卖，在2018年会有很多坑。ICO及其之后的项目准备阶段，币价的特点是不确定性大、严重依赖消息。 资金量大、消息面广的，可以广撒网。 以我的资金量和消息面，是玩不转的。 自媒体？ 英文翻译 猪八戒上千字100，千字140的价格算高的了。 英文约稿与推荐 只要求中文独家，最好中文先发。 中文转载 待读&amp;进展 待读 非常好：http://www.8btc.com/reinvent-the-currency 以太坊（1）–在CentOS 6.5上搭建以太坊私有链的步骤（图文详细） 以太坊（3）：以太坊私有链环境下的智能合约的编写、编译、创建与执行 教程 Geth搭建私有链 中国在区块链领域有哪些专家或公认的牛人？【帮助弄懂bitcoin技术】 进展 按照https://ethereum.stackexchange.com/questions/13547/how-to-set-up-a-private-network-and-connect-peers-in-geth对json进行了设置， digital currency ethereum (new_set) practice My understanding: init first block. then you can mine. cardano cardano简介 爱丁堡大学一个中心IOHK牵头。 ADA 不支持win32和移动钱包 EOS EOS：疯子的狂欢 BM出品，李笑来站台 STEEM BM出品，远没有btc强势 其他币 TUNE：音乐应用 三位创始人都是格莱美奖得主。 太空链：严重破发 薛蛮子认为： 对于ICO的投资标准，薛蛮子表示，首先是人靠谱，此前投资的比原链是国内区块链最大的社区巴比特发起的，墨链是纸贵科技发起的，BEX是美豹金融发起的，这些项目的团队本身已经有了成功的创业案例，且在细分领域处于排头兵的地位。 拿比原链来说，薛蛮子表示，“我认为，比原链的创始团队很年轻，富有朝气，大家都很努力，但是比原链的技术挑战挺大，需要天时地利人和，很多条件具备才能做成，不是轻描淡写，一挥而就的。团队最要紧的是不断试错，踏踏实实做事情，不要辜负投资人的信任。我不看好的是，有的小伙子一辈子没赚过大钱，也没花过100万以上的钱，突然通过ICO拿了几个亿，这些人hold不住。” tech 1、 共识算法:POW/POS/DPOS/PBFT/BFT-Raft/Paxos/Kafka 2、 P2P通讯:自举(bootstrapped)/连接/广播 3、 签名验签:ECDSA/secp256k1/ED25519/MultiSig 4、 Hash锁定:Merkle树/MPT树 5、 UTXO记账:流水账 6、 智能合约:P2PKH/P2SH/Oracle/状态机 7、 隐私保护:零知识证明、同态加密、CoinJoin加密技术 8、 私钥存储:HD协议(Hierarchical Deterministic Key Creation)、钱包Wallets、丢失找回 9、 算力分发：矿池分发 冷热钱包 热是指在线。如果热钱包断网，那么从存储的角度来讲，也是冷钱包了。但是离线的热钱包和冷钱包还是有很多不同之处。 常用的钱包 BTC 比特币系统的一个重要的可扩展特性是：它的区块存储在多层次的数据结构中。一个区块的哈希实际上只是区块头的哈希，区块头是包含时间戳、随机数、上个区块哈希和存储了所有的区块交易的默克尔树的根哈希的长度大约为200字节的一段数据。[1] 钱包相关 简单科普私钥、地址、助记词、Keystore的区别 比特币钱包的安全使用和完美备份 介绍了如何离线生成脑钱包 ripple钱包: OS X client 只要记住私钥，那么点击“通过私钥创建一个账户”，就可以得到一个已经创建过的账户的钱包！ 共识 区块链技术如何兼顾共识和匿名，解决储存和处理速度问题？ 1.共识机制下如何兼顾匿名。举个例子，甲转账给乙两个比特币，但乙不承认。在共识机制下，我们都可以看到确实有2个比特币从地址A转到了地址B，此时有 问题一：甲可以想办法证明地址A就是他的，但这个证明仍旧是传统的，需要一个个说服别人的证明，而不是一下子说服全部人的证明。 问题二：即使甲说服了大部分人地址A就是他的，乙仍旧可以不承认地址B是他的，也没有共识机制可以指出地址B是谁的。甲仍旧不能证明转给乙两个比特币。 问题三：如果存在共识机制能指出地址AB是对应甲和乙的，隐私性就无从谈起，等于所有人的交易都是暴露的。 2.数据储存过大。举个例子在淘宝买东西，传统交易是中心化的，数据都记录在阿里的硬盘里，我们害怕阿里偷偷修改了以前的数据，要去中心化，所以用上了区块链技术取代阿里云，但所有的交易数据可不是几个T这么少，普通用户如何储存。如果只是少数人储存，那仍旧没有去中心化。 3.计算速度的问题。假设以后所有交易都在区块链上，区块链技术也得到改进，每秒能处理上亿比交易，如果每个人都要记录，是否意味着每个人都有强大的处理能力，如果但普通计算机无法胜任，只能交给少数超级计算机处理，是否意味普通人失去了记录的能力。 共识（consensus）算法指的是大家对某一个提案达成一致意见的过程，也就是分布式系统中多个节点之间，对某个状态达成一致结果的过程。至于提案（proposal），几乎可以认为任何可以达成一致的信息就是一个提案。在具体的区块记账中，问题1所对应的提案就是地址A向地址B转账这条交易信息是否存在。达成共识的过程就是大家确认该笔交易存在并且有效。因此，不涉及到问题1.1和1.2，即地址A是甲的地址，地址B是乙的地址这个身份关联过程，因此，可以视为该过程是匿名的。除非提案内容更改为&quot;地址A是甲的地址，地址B是乙的地址，地址A向地址B发起了一笔转账&quot;。 这样就触发了问题三，问题三的描述里，确实无法保证隐私性，这个不用多说。 闪电链 闪电链科普： 所谓闪电链就是小额交易不上主链，而是放在侧链上，在达到一定交易量后再统一上到主链上。 闪电链相当于中心化的节点。 闪电网络的反作弊机制 一个叫双向支付通道（Bi-Directional Payment Channel ) 一个叫时间锁（TimeLock） 一个叫密码（Secret Value） 双向通道：交易双方都确认，才能交易成功。 POW btc的block上，负责POW的nounce。 btc采用POW是为了增加作假block的成本，进而禁止了双花。 UTXO 玛_雅和vatten解释的很好 其实并没有什么比特币，只有 UTXO 隐私保护机制[2] 零知识证明 零知识证明也就是证明者在不泄露秘密的情况下，让验证者相信证明者知道这个秘密。 Zcash是首个使用零知识证明机制的区块链系统。不同于其他加密数字货币会公开所有的交易记录，Zcash可以用零知识证明将完全加密的交易记录确认为有效，但是他有一个很关键的缺点就是速度缓慢。 Zcash采用了尖端加密技术zk-SNARKs来对用户地址及账户余额进行隐藏。 同态加密 明文加密后得到密文，对密文进行特定的代数运算得到的还是加密的结果，对结果进行解密可以得到对明文进行同样运算一样的结果。也就是说可以在不知道原数据的情况下进行运算，最后同样能得到正确的结果。 混币 以门罗币（Monero）为例，他使用了RingCT（环形加密匿名）技术来实现隐私保护。 problem what is private network? 资料&amp;引用 区块链是什么，如何简单易懂地介绍区块链？ 2亿美元被锁死在区块链中？以太坊智能合约被爆存在巨大漏洞，新技术落地恐怕要“迟到”了 BM是指网名byteMaster (Daniel Larimer)的程序员，BTS、STEEMIT、EOS创始人 reference: ↩ 知识点 || 区块链的隐私保护机制有哪些？真的安全吗？ ↩]]></content>
      <categories>
        <category>block chain</category>
      </categories>
      <tags>
        <tag>block chain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Learning Note]]></title>
    <url>%2FWeb%2F</url>
    <content type="text"><![CDATA[html5 html In a nutshell The &lt;head&gt; element contains meta information about the document The &lt;body&gt; element contains the visible page content HTML elements are the building blocks of HTML pages HTML elements are represented by tags HTML tags label pieces of content such as “heading”, “paragraph”, “table”, and so on tags: &lt;tagname&gt;content goes here...&lt;/tagname&gt; html basic Headings e.g., &lt;h1&gt; Paragraphs &lt;p&gt; Links &lt;a&gt; &lt;a href=&quot;https://www.w3schools.com&quot;&gt;This is a link&lt;/a&gt; local links &lt;a href=&quot;html_images.asp&quot;&gt;HTML Images&lt;/a&gt; colors By default, a link will appear like this (in all browsers): An unvisited link is underlined and blue A visited link is underlined and purple An active link is underlined and red You can change the default colors, e.g.: 123456789101112131415161718192021a:link &#123; color: green; background-color: transparent; text-decoration: none;&#125;a:visited &#123; color: pink; background-color: transparent; text-decoration: none;&#125;a:hover &#123; color: red; background-color: transparent; text-decoration: underline;&#125;a:active &#123; color: yellow; background-color: transparent; text-decoration: underline;&#125;&lt;/style&gt; target Attribute Available values: _blank, _self, _parent, _top, framename - Opens the linked document in a named frame images Note: border:0; is added to prevent IE9 (and earlier) from displaying a border around the image (when the image is a link). Create a Bookmark 12&lt;h2 id=&quot;C4&quot;&gt;Chapter 4&lt;/h2&gt;&lt;a href=&quot;#C4&quot;&gt;Jump to Chapter 4&lt;/a&gt; Images &lt;img src=&quot;w3schools.jpg&quot; alt=&quot;W3Schools.com&quot; width=&quot;104&quot; height=&quot;142&quot;&gt; The style attributes are valid in HTML5 and suggested. Floating let the image float to the right or to the left of a text maps An image-map is an image with clickable areas. Background image 123 &lt;body style="background-image:url('clouds.jpg')"&gt;&lt;h2&gt;Background Image&lt;/h2&gt;&lt;/body&gt; picture element Introduced since html5. Always specify an element as the last child element of the element. The element is used by browsers that do not support the element, or if none of the tags matched. Buttons &lt;button&gt;Click me&lt;/button&gt; Lists HTML lists are defined with the &lt;ul&gt; (unordered/bullet list) or the &lt;ol&gt; (ordered/numbered list) tag, followed by &lt;li&gt; tags (list items) &lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;/ul&gt; elements An HTML element usually consists of a start tag and end tag, with the content inserted in between: &lt;tagname&gt;Content goes here...&lt;/tagname&gt; &lt;br&gt; element which indicates a line break. Empty elements can be “closed” in the opening tag like this: &lt;br /&gt;. HTML5 does not require empty elements to be closed. But if you want stricter validation, or if you need to make your document readable by XML parsers, you must close all HTML elements properly. &lt;hr&gt; 水平分割线 a thematic break. headings Note: Use HTML headings for headings only. Don’t use headings to make text BIG or bold. For Bigger Headings use: &lt;h1 style=&quot;font-size:60px;&quot;&gt;Heading 1&lt;/h1&gt; &lt;head&gt; Element The HTML element has nothing to do with HTML headings. The element is a container for metadata. HTML metadata is data about the HTML document. Metadata is not displayed. The element is placed between the tag and the tag: &lt;pre&gt; The text inside a element is displayed in a fixed-width font (usually Courier), and it preserves both spaces and line breaks. link Formating element 12345678910&lt;b&gt; - Bold text &lt;strong&gt; - Important text &lt;i&gt; - Italic text &lt;em&gt; - Emphasized text &lt;mark&gt; - Marked text &lt;small&gt; - Small text &lt;del&gt; - Deleted text &lt;ins&gt; - Inserted text &lt;sub&gt; - Subscript text &lt;sup&gt; - Superscript text Note: Browsers display &lt;strong&gt; as &lt;b&gt;, and &lt;em&gt; as &lt;i&gt;. However, there is a difference in the meaning of these tags: &lt;b&gt; and &lt;i&gt; defines bold and italic text, but &lt;strong&gt; and &lt;em&gt; means that the text is “important”. Quotations &lt;q&gt; for short and &lt;blockquote&gt; for long Quotations e.g., : cite="http://www.worldwildlife.org/who/index.html">123456For 50 years, WWF has been protecting the future of nature.The world&apos;s leading conservation organization,WWF works in 100 countries and is supported by1.2 million members in the United States andclose to 5 million globally.&lt;/blockquote&gt; &lt;abbr&gt; Marking abbreviations can give useful information to browsers, translation systems and search-engines. &lt;cite&gt; The HTML element defines the title of a work. &lt;bdo&gt; Bi-Directional Override e.g., &lt;bdo dir=&quot;rtl&quot;&gt; comments e.g., &lt;!-- Do not display this at the moment &lt;img border=&quot;0&quot; src=&quot;pic_mountain.jpg&quot; alt=&quot;Mountain&quot;&gt; --&gt; Attributes Attributes usually come in name/value pairs like: name=“value”, blank is used to sperate attributes. e.g., &lt;a href=&quot;https://www.w3schools.com&quot;&gt;This is a link&lt;/a&gt; href is an attributes. src width &amp; height alt The alt attribute specifies an alternative text to be used, when an image cannot be displayed. The value of the attribute can be read by screen readers. This way, someone “listening” to the webpage, e.g. a blind person, can “hear” the element. style color, font, size etc. e.g., &lt;p style=&quot;color:red&quot;&gt;I am a paragraph&lt;/p&gt; lang &lt;html lang=&quot;en-US&quot;&gt; is important for accessibility applications (screen readers) and search engines. title Here, a title attribute is added to the element. The value of the title attribute will be displayed as a tooltip when you mouse over the paragraph. HTML Attributes JSON[1] JSON[1] 结构有两种结构[2] json简单说就是javascript中的对象和数组，所以这两种结构就是对象和数组两种结构，通过这两种结构可以表示各种复杂的结构 1、对象：对象在js中表示为“{}”括起来的内容，数据结构为 {key：value,key：value,…}的键值对的结构，在面向对象的语言中，key为对象的属性，value为对应的属性值，所以很容易理解，取值方法为 对象.key 获取属性值，这个属性值的类型可以是 数字、字符串、数组、对象几种。 2、数组：数组在js中是中括号“[]”括起来的内容，数据结构为 [“java”,“javascript”,“vb”,…]，取值方式和所有语言中一样，使用索引获取，字段值的类型可以是 数字、字符串、数组、对象几种。 经过对象、数组2种结构就可以组合成复杂的数据结构了。 Forms &lt;input&gt; Element type value text, radio, submit name Attribute Each input field must have a name attribute to be submitted. If the name attribute is omitted, the data of that input field will not be sent at all. Action Attribute The action attribute defines the action to be performed when the form is submitted. Target Attribute type value _self, _blank, TIPS .htm or .html has no difference. HTML tags are not case sensitive The HTML5 standard does not require lowercase tags, but W3C recommends lowercase in HTML, and demands lowercase for stricter document types like XHTML. Quote Attribute Values W3C recommends quotes in HTML, and demands quotes for stricter document types like XHTML. single quotes can also be used. With HTML, you cannot change the output by adding extra spaces or extra lines in your HTML code. display special symbols © - &amp;copy; ® - &amp;reg; ™ - &amp;trade; MIME type 也称作content type。Content-Type: text/HTML：http协议中Content-Type的值就是mime type。 更多信息见：wiki 互联网媒体类型 CSS3 CSS(层叠样式表 Cascading Style Sheets)，专门用来负责html里的&lt;style&gt;。 CSS的语法很简单，选择器：{属性1：属性值; 属性2：属性值}。 CSS can be added to HTML elements in 3 ways: Inline - by using the style attribute in HTML elements Internal - by using a &lt;style&gt; element in the &lt;head&gt; section External - by using an external CSS file Three examples: 123&lt;link rel=&quot;stylesheet&quot; href=&quot;https://www.w3schools.com/html/styles.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/html/styles.css&quot;&gt; Your first test:[2] 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;body &#123; background-color: lightblue;&#125;h1 &#123; color: white; text-align: center;&#125;p &#123; font-family: verdana; font-size: 20px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;My First CSS Example&lt;/h1&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; id attribute Note: The id of an element should be unique within a page, so the id selector is used to select one unique element! 1234&lt;p id=&quot;p01&quot;&gt;I am different&lt;/p&gt;#p01 &#123; color: blue;&#125; class attribute 1234&lt;p class=&quot;error&quot;&gt;I am different&lt;/p&gt;p.error &#123; color: red;&#125; CSS properties border【Note: border must have at last 3 properites】; color; font-size; font-family; padding &amp; margin(inside/outside the border); JavaScript &lt;noscript&gt; Defines an alternate content for users that do not support client-side scripts. Examples 12345678//change HTML contentdocument.getElementById(&quot;demo&quot;).innerHTML = &quot;Hello JavaScript!&quot;;//change HTML stylesdocument.getElementById(&quot;demo&quot;).style.fontSize = &quot;25px&quot;;document.getElementById(&quot;demo&quot;).style.color = &quot;red&quot;;document.getElementById(&quot;demo&quot;).style.backgroundColor = &quot;yellow&quot;;//change HTML attributesdocument.getElementById(&quot;image&quot;).src = &quot;picture.gif&quot;; Chares port 80: http 443: https 浏览器的解析方式[3] 浏览器解析html页面首先浏览器先下载html，然后在内存中把html代码转化成Dom Tree，然后浏览器根据Dom Tree上的Node分析css和Images，当文档下载遇到js时，js独立下载。 HMAC HMAC是密钥相关的哈希运算消息认证码，HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。 hmac主要应用在身份验证中，它的使用方法是这样的： (1) 客户端发出登录请求（假设是浏览器的GET请求） (2) 服务器返回一个随机值，并在会话中记录这个随机值 (3) 客户端将该随机值作为密钥，用户密码进行hmac运算，然后提交给服务器 (4) 服务器读取用户数据库中的用户密码和步骤2中发送的随机值做与客户端一样的hmac运算，然后与用户发送的结果比较，如果结果一致则验证用户合法 REST/RESTful 参考：理解RESTful架构 Representational State Transfer，“表现层状态转化”，主语应该是resource。 RESTful架构： （1）每一个URI（统一资源定位符）代表一种资源； （2）客户端和服务器之间，传递这种资源的某种表现层； （3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现&quot;表现层状态转化&quot;。 协程 优点： 最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。 第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。 socket introduction 默认端口也是80和443; 协议标识符是ws（如果加密，则为wss）; socket所在的层次以及它是什么：简单理解Socket 从字面意思来看TCP/IP是TCP和IP协议的合称，但实际上TCP/IP协议是指因特网整个TCP/IP协议族。不同于ISO模型的七个分层，TCP/IP协议参考模型把所有的TCP/IP系列协议归类到四个抽象层中 应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等 传输层：TCP，UDP 网络层：IP，ICMP，OSPF，EIGRP，IGMP 数据链路层：SLIP，CSLIP，PPP，MTU 我们知道两个进程如果需要进行通讯最基本的一个前提能能够唯一的标示一个进程，在本地进程通讯中我们可以使用PID来唯一标示一个进程，但PID只在本地唯一，网络中的两个进程PID冲突几率很大，这时候我们需要另辟它径了，我们知道IP层的ip地址可以唯一标示主机，而TCP层协议和端口号可以唯一标示主机的一个进程，这样我们可以利用ip地址＋协议＋端口号唯一标示网络中的一个进程。 socket连接和HTTP连接的区别: 简单来说，你浏览的网页(网址以HTTP://开头)都是HTTP协议传输到你的浏览器的，而HTTP是基于socket之上的。socket是一套完成TCP.UDP协议的接口. HTTP协议:简单对象访问协议，对应于应用层，HTTP协议是基于TCP连接的。 TCP协议:对应于传输层 IP协议:对应于网络层 TCP/IP是传输层协议，主要解决数据如果在网络中传输； 而HTTP协议是应用层协议，主要解决如何包装数据。 socket是对TCP/IP协议的封装，socket本身并不是协议，而是一个调用接口(API),通过socket我们才能使用TCP/IP协议. http连接:http连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断掉. socket连接:socket连接就是所谓的长连接，理论上客户端和服务器端一旦连接其连接将不会主动断掉；但是由于各种环境因素可能会连接断开，比如说:服务器端或客户端主机down了，网络故障，或者两者之间长时间没有传输数据，网络防火墙可能会断开该连接以释放网络资源。所以当一个socket连接中没有数据传输的时候，那么为了维持连接需要发送心跳消息，具体心跳消息格式是开发者自己定义的。 JSON简介 ↩ CSS3 教程 注意：主要浏览器有5个！ ↩ CSS、JS 放置位置与前端性能的关系？ ↩]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlite note]]></title>
    <url>%2Fsqlite%2F</url>
    <content type="text"><![CDATA[基本概念 ref: runoob sql 大小写敏感性 有个重要的点值得注意，SQLite 是不区分大小写的，但也有一些命令是大小写敏感的，比如 GLOB 和 glob 在 SQLite 的语句中有不同的含义。 注释 SQLite 注释是附加的注释，可以在 SQLite 代码中添加注释以增加其可读性，他们可以出现在任何空白处，包括在表达式内和其他 SQL 语句的中间，但它们不能嵌套。 SQL 注释以两个连续的 “-” 字符（ASCII 0x2d）开始，并扩展至下一个换行符（ASCII 0x0a）或直到输入结束，以先到者为准。 您也可以使用 C 风格的注释，以 “/&quot; 开始，并扩展至下一个 &quot;/” 字符对或直到输入结束，以先到者为准。 main database[1] The “.databases” command shows a list of all databases open in the current connection. There will always be at least 2. The first one is “main”, the original database opened. The second is “temp”, the database used for temporary tables. There may be additional databases listed for databases attached using the ATTACH statement. The first output column is the name the database is attached with, and the second column is the filename of the external file. 如果导入同一个库两次，.table会显示什么？ 123456789sqlite&gt; .open test.dbsqlite&gt; .databasemain: /Users/Aether/Documents/hexo_file/source/_posts/test.dbsqlite&gt; ATTACH DATABASE 'test.db' as 'foo';sqlite&gt; .databasesmain: /Users/Aether/Documents/hexo_file/source/_posts/test.dbfoo: /Users/Aether/Documents/hexo_file/source/_posts/test.dbsqlite&gt; .tableCOMPANY foo.COMPANY 回滚日志[2] 如果崩溃或断电发生在事务的中间某时刻，则在硬盘上会留有回滚日志。在下次另外一个应用程序尝试打开数据库文件时，它会通知存在回滚日志(“热日志”)，并使用日志中的信息来把数据库恢复到未完成事务开始之前的状态。这就是SQLite实现原子提交的基本原理。 TEMP[2] 临时数据库文件总是在数据库连接关闭时自动删除。 字段类型 SQLite是无类型的. 这意味着你可以保存任何类型的数据到你所想要保存的任何表的任何列中, 无论这列声明的数据类型是什么(只有自动递增Integer Primary Key才有用). 对于SQLite来说对字段不指定类型是完全有效的. 建表时声明啥类型或者不声明类型都可以,也就意味着创表语句可以这么写:create table if not exists t_student(name, age); 一般数据采用的固定的静态数据类型，而SQLite采用的是动态数据类型，会根据存入值自动判断。SQLite的数据存储类型有: integer (有符号整形), real (浮点值,以8字节IEEE浮点数存放), text(文本字符串,使用数据库编码UTF-8，UTF-16BE或者UTF-16LE存放), blob(是一个数据块,完全按照输入存放; 二进制数据,比如: 文件) 布尔类型 Sqlite没有单独的布尔存储类型，它使用INTEGER作为存储类型，0为false，1为true IS_OPENING BOOLEAN NOT NULL CHECK (IS_OPENING IN (0,1)) NUMERIC类型：当文本数据被插入到亲缘性为NUMERIC的字段中时，如果转换操作不会导致数据信息丢失以及完全可逆，那么SQLite就会将该文本数据转换为INTEGER或REAL类型的数据，如果转换失败，SQLite仍会以TEXT方式存储该数据。对于NULL或BLOB类型的新数据，SQLite将不做任何转换，直接以NULL或BLOB的方式存储该数据。需要额外说明的是，对于浮点格式的常量文本，如&quot;30000.0&quot;，如果该值可以转换为INTEGER同时又不会丢失数值信息，那么SQLite就会将其转换为INTEGER的存储方式。 Date 与 Time 数据类型 SQLite 没有一个单独的用于存储日期和/或时间的存储类，但 SQLite 能够把日期和时间存储为 TEXT、REAL 或 INTEGER 值。 虽然可以不写类型，但为了以后方便理解，最好还是写上。 sqlite_master &amp; sqlite_temp_master sqlite查询库里所有表名 每一个 SQLite 数据库都有一个叫 SQLITE_MASTER 的表， 里面存储着数据库的数据结构（表结构、视图结构、索引结构等），只可以对他使用查询语句 SQLITE_MASTER 表DDL信息如下: CREATE TABLE sqlite_master (type TEXT,name TEXT,tbl_name TEXT,rootpage INTEGER,sql TEXT); SELECT name FROM sqlite_master WHERE type=’table’ ORDER BY name; NOTE: ‘TEMP’ is in sqlite_temp_master SQL语句的种类 数据定义语句: (DDL:Data Definition Language) 包括create和drop等操作; 例如:在数据库中创建新表或删除表(create table或drop table) 数据操作语句(DML:Data Manipulation Language) 包括insert、update、delete等操作(添加、修改(更新)、删除表中的数据) 数据查询语句(DQL:Data Query Language) 可以用于查询获得表中的数据, 关键字select是DQL(也是所有SQL)用得最多的操作 其他DQL常用的关键字有where,order by,group by和having transaction BEGIN TRANSACTION：开始事务处理。 COMMIT：保存更改，或者可以使用 END TRANSACTION 命令。 ROLLBACK：回滚所做的更改。 By default, each INSERT statement is its own transaction. But if you surround multiple INSERT statements with BEGIN…COMMIT then all the inserts are grouped into a single transaction. The time needed to commit the transaction is amortized over all the enclosed insert statements and so the time per insert statement is greatly reduced. about Savepoint 可以参考：SQLite3源码学习（29） 用户事务和Savepoint VACUUM 通过复制主数据库中的内容到一个临时数据库文件，然后清空主数据库，并从副本中重新载入原始的数据库文件。这消除了空闲页，把表中的数据排列为连续的，另外会清理数据库文件结构。(ct: sqlite是以树结构存储数据的) 约束 NOT NULL 约束：确保某列不能有 NULL 值。 DEFAULT 约束：当某列没有指定值时，为该列提供默认值。 UNIQUE 约束：确保某列中的所有值是不同的。 PRIMARY Key 约束：唯一标识数据库表中的各行/记录。 CHECK 约束：CHECK 约束确保某列中的所有值满足一定条件。 SQLite 支持 ALTER TABLE 的有限子集。重命名列，删除一列，或从一个表中添加或删除约束都是不可能的!!! 操作 dot command 你不能从Python中调用点命令，因为点命令是特定于命令行shell工具的。 .schema table_name: 列出创建表的语句。.sch也可以 .tables: 列出所有表名 .headers on 列出表头(column names) command line $sqlite3 testDB.db .dump &gt; testDB.sql INSERT insert by python dictionary 12values = &#123;'title':'jack', 'type':None, 'genre':'Action', 'onchapter':None,'chapters':6,'status':'Ongoing'&#125;cur.execute('INSERT INTO Media (id, title, type, onchapter, chapters, status) VALUES (:id, :title, :type, :onchapter, :chapters, :status);'), values) ATTACH The ATTACH DATABASE statement adds another database file to the current database connection. Database files that were previously attached can be removed using the DETACH DATABASE command. VIEW(视图) SQLite 视图是只读的，因此可能无法在视图上执行 DELETE、INSERT 或 UPDATE 语句。但是可以在视图上创建一个触发器，当尝试 DELETE、INSERT 或 UPDATE 视图时触发，需要做的动作在触发器内容中定义。 最简单的视图： CREATE VIEW testview AS SELECT * FROM testtable WHERE first_col &gt; 100; 创建临时视图： sqlite&gt; CREATE TEMP VIEW tempview AS SELECT * FROM testtable WHERE first_col &gt; 100; “IF NOT EXISTS” sqlite&gt; CREATE VIEW IF NOT EXISTS testview AS SELECT * FROM testtable WHERE first_col &gt; 100; 删除视图 sqlite&gt; DROP VIEW IF EXISTS testview; ALTER TABLE 只有两个用法： 重命名表 ALTER TABLE database_name.table_name RENAME TO new_table_name; 在已有的表中添加列 ALTER TABLE database_name.table_name ADD COLUMN column_def...; 注意，新添加的列是以 NULL 值来填充的 select 日期表达式 返回当前系统日期和时间值，注意是UTC+0时间 SELECT CURRENT_TIMESTAMP; 例子[3] 1234sqlite&gt; SELECT * FROM COMPANY WHERE AGE &gt;= 25 OR SALARY &gt;= 65000;sqlite&gt; SELECT * FROM COMPANY WHERE AGE IS NOT NULL;sqlite&gt; SELECT * FROM COMPANY WHERE AGE NOT IN ( 25, 27 ); /* 既不是 25 也不是 27 的所有记录 */sqlite&gt; SELECT * FROM COMPANY WHERE AGE BETWEEN 25 AND 27; UPDATE 12sqlite&gt; UPDATE COMPANY SET ADDRESS = 'Texas' WHERE ID = 6;sqlite&gt; UPDATE COMPANY SET ADDRESS = 'Texas', SALARY = 20000.00; /* 修改所有 */ UPDATE multiple rows 参考： Update multiple rows with different values in a single SQL query sqlite update 多行 DELETE 12sqlite&gt; DELETE FROM COMPANY WHERE ID = 7;sqlite&gt; DELETE FROM COMPANY; /* 删除所有 */ 字符串匹配 GLOB大小写敏感；LIKE大小写不敏感 GLOB 星号（*） 代表零个、一个或多个数字或字符。 问号（?） 代表一个单一的数字或字符。这些符号可以被组合使用。 LIKE 百分号（%） 代表零个、一个或多个数字或字符。 下划线（_） 代表一个单一的数字或字符。这些符号可以被组合使用。 python connection[4] 1234567891011# Fill the tablepersons = [ ("Hugo", "Boss"), ("Calvin", "Klein") ]con.executemany("insert into person(firstname, lastname) values (?, ?)", persons)# Print the table contentsfor row in con.execute("select firstname, lastname from person"): print(row)print("I just deleted", con.execute("delete from person").rowcount, "rows") security[5] Use ? as a placeholder! Use Python’s string operations to assemble a query makes program vulnerable to an SQL injection attack if connection is not closed When the connection is closed explicitly by code or implicitly by program exit then any outstanding transaction is rolled back. connection as a context manager[4] Connection objects can be used as context managers that automatically commit or rollback transactions. In the event of an exception, the transaction is rolled back; otherwise, the transaction is committed. 123456789# Successful, con.commit() is called automatically afterwardswith con: con.execute("insert into person(firstname) values (?)", ("Joe",))# con.rollback() is called after the with block finishes with an exception!try: with con: con.execute("insert into person(firstname) values (?)", ("Joe",))except sqlite3.IntegrityError: print("couldn't add Joe twice") cursor FIRST OF ALL: There’re two distinct ‘cursor’ concept: In standard SQL, it’s like concept of iterator[6]: In computer science and technology, a database cursor is a control structure that enables traversal over the records in a database. Cursors facilitate subsequent processing in conjunction with the traversal, such as retrieval, addition and removal of database records. The database cursor characteristic of traversal makes cursors akin to the programming language concept of iterator. In sqlite module of python, it’s basically the same with connection. Or say, connection is a shortcut of cursor (make things easier).[6] Connection.execute This is a nonstandard shortcut that creates a cursor object by calling the cursor() method, calls the cursor’s execute() method with the parameters given, and returns the cursor. As long as you use the standard methods of the Cursor object, you can be sure that if you switch to another database implementation that follows the above specification, your code will be fully portable. Perhaps you will only need to change the import line. cursor in sqlite module of python[6] Cursor objects allow you to keep track of which result set is which, since it’s possible to run multiple queries before you’re done fetching the results of the first. commit ref: how often do I have to commit? What concurrent readers see When a change to the database is committed, it becomes visible for other connections. Unless it is committed, it remains visible only locally for the connection to which the change was done. Because of the limited concurrency features of sqlite, the database can only be read while a transaction is open. balance between Performance and Exclusively locking the database Actually, SQLite will easily do 50,000 or more INSERT statements per second on an average desktop computer. But it will only do a few dozen transactions per second. sqlite3 in python By default, the ‘isolation_level’ parameter of a connection is set as DEFERRED. Set ‘isolation_level’ to ‘None’, this will leave the underlying sqlite3 library operating in autocommit mode. (autocommit mode means that statements that modify the database take effect immediately.) read datetime.datetime from sqlite3[7] for more about read datetime.datetime or even adapter, see doc: DB-API 2.0 interface for SQLite databases 建立connect时加上detect_types=sqlite3.PARSE_DECLTYPES, 就可以直接读写datetime类型: 12345 &gt;&gt;&gt; db = sqlite3.connect('test.db', detect_types=sqlite3.PARSE_DECLTYPES) &gt;&gt;&gt; c = db.cursor() &gt;&gt;&gt; c.execute('create table foo (bar integer, baz timestamp)')&lt;sqlite3.Cursor object at 0x40fc50&gt; &gt;&gt;&gt; c.execute('insert into foo values(?, ?)', (23, datetime.datetime.now())) Using adapters to store additional Python types[8] simple example read &amp; write boolean directly: 12sqlite3.register_adapter(bool, int)sqlite3.register_converter("BOOLEAN", lambda v: bool(int(v))) define __conform__ in your class 123456class Point: def __init__(self, x, y): self.x, self.y = x, y def __conform__(self, protocol): if protocol is sqlite3.PrepareProtocol: return "%f;%f" % (self.x, self.y) register an adapter callable 123def adapt_point(point): return "%f;%f" % (point.x, point.y)sqlite3.register_adapter(Point, adapt_point) datatime.date and datetime.datetime can be directly written to sqlite3 sqlite3 module has two default adapters for Python’s built-in datetime.date and datetime.datetime types. PRAGMA cur.execute(&quot;PRAGMA table_info('my_table_name')&quot;).fetchall() 返回值是a list of tuple; tuple分别含有下列元素： cid name type notnull dflt_value pk e.g.: [(0, 'ORDER_IN_PAIR_UTCTIME', 'TIMESTAMP', 1, None, 0)] dot command in python First of all, dot command is just for sql shell. .schema – corresponding to PRAGMA 参数占位 Best Practice Don’t use autoincrement[9] If ‘WITHOUT ROWID’ option isn’t specified, you always get an implicit auto increment column called rowid. If you don’t specify the rowid value or use a NULL value when you insert a new row, SQLite assigns an integer that is one larger than the largest rowid in the table. The maximum value of rowid column is 9223372036854775807. diference between ‘autoincrement’ and ‘rowid’: ‘autoincrement’ only complains when rowid is overflow. reference How to name an SQLite database so it doesn’t have the default name of main? ↩ SQLite剖析之临时文件、内存数据库 ↩ ↩ SQLite Where 子句 ↩ using-sqlite3-efficiently ↩ ↩ sqlite3 — DB-API 2.0 interface for SQLite databases ↩ Why do you need to create a cursor when querying a sqlite database? ↩ ↩ ↩ How to read datetime back from sqlite as a datetime instead of string in Python? ↩ Using adapters to store additional Python types in SQLite databases ↩ SQLite AUTOINCREMENT : Why You Should Avoid Using It ↩]]></content>
      <categories>
        <category>sql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pandas note]]></title>
    <url>%2Fpandas%2F</url>
    <content type="text"><![CDATA[数据分析神器Pandas。 教程参考[1] [2] [3]. 基本 Pandas 基于两种数据类型，series 和 dataframe。series 是一种一维的数据类型，其中的每个元素都有各自的标签。dataframe 可以看作是一个 series 的字典。 Series有一个与数组关联的数据标签，被叫做 索引 。最简单的Series是由一个数组的数据构成： 1234567In [4]: obj = Series([4, 7, -5, 3]) In [5]: obj Out[5]: 0 4 1 7 2 -5 3 3 Dataframe axis=0表示行，axis=1表示列 行、列的index，分别为index, columns，例如： df.columns loc是根据标签索引；iloc是index索引: df.iloc(1) # 第二行 df.iloc(:,1) # 第二列 df.loc([0], ['size') # 第一行、「size」列 df.head/tail df is the abbre. of dataframe. Show first 5 line：df.head(5) Changing column labels so you can getting a column by label . 123df.columns = [&apos;water_year&apos;,&apos;rain_octsep&apos;, &apos;outflow_octsep&apos;, &apos;rain_decfeb&apos;, &apos;outflow_decfeb&apos;, &apos;rain_junaug&apos;, &apos;outflow_junaug&apos;]df.rain_octsep # 相当于df[&apos;rain_octsep&apos;] len(df) filter 12345678# Using a series of booleans to filterdf[df.rain_octsep &lt; 1000]# Filtering by multiple conditionalsdf[(df.rain_octsep &lt; 1000) &amp; (df.outflow_octsep &lt; 4000)] # 这里不能用 and 关键字，因为会引发操作顺序的问题。必须用 &amp; 和圆括号。# Filtering by string methodsdf[df.water_year.str.startswith(&apos;199&apos;)]# 注意，你必须用 .str.[string method] ，而不能直接在字符串上调用字符方法。 添加(add data) add a row ref: Merge, join, and concatenate In short, there are several methods to add data to a Dataframe: Merge, join, concatenate and append. But only loc can add data inplace!!! All other methods will return a new dataframe and without ‘inplace’ arg append Dataframe: add a row 1234567# method 1df = DataFrame(columns=('lib', 'qty1', 'qty2'))#生成空的pandas表 for i in range(5):#插入一行 df.loc[i] = [randint(-1,1) for n in range(3)] # method 2 append from a python dict# ref : [pandas.DataFrame.append](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.append.html)df.append(your_dict, ignore_index=True) python pandas 怎样高效地添加一行数据？ 简而言之： Pandas/numpy structures are fundamentally not suited for efficiently growing. They work best when they are created with a fixed size and stay that way. add a column df[1]=np.arange(1,11,2) # add a column of which name is 1 add dict to DataFrame add one-D dict to one line of a DataFrame 1df.loc[len(df.index)] = mydict 删除/修改 引用以及修改 Dataframe df[1] # columns=1的列 df[1:2] # 第二行 df.iloc[-8:, 1:] # 取倒数八行、不要第一列 df.iat[1,1] #选择已知标量（单个元素） Series: 修改 s3 = pd.Series( [3,5,7], index = list('ABC'),name='s3' ), 那么修改方法为： s3['B'] = 6或者s3[1] = 6 即：通过label和index都可以修改 drop Dataframe: pandas的DataFrame对象如何清空？ df.drop(df.index,inplace=True) Series: drop以及重新添加 s3.drop('A') s3.index.append(pd.Index(['A']) ) statistic/arithmetic operation add/sub/mul/div/floordiv/pow/mod/ fill_value Note: It substitute a fill_value for missing data in one of the inputs. div div, divide is the same as truediv[4] df/a is the same as df.truediv(a), then a/df is the same as df.truediv(a). info, describe # describe: basic statistical information of dataset. 12pd.options.display.float_format = &apos;&#123;:,.3f&#125;&apos;.format # Limit output to 3 decimal places.df.describe() sum, mean, std, corr # correlation between two columns(pearson correlation) 注意std默认是除以N-1而不是N的； min, max, median, idxmin, idxmax # Index of the largest value 写入/读取 写 df.to_csv('D:\\a.csv', sep=',', header=True, index=True) df.to_json('D:\\a.json') df.to_html('D:\\a.html') df.to_sql('tableName', con=dbcon, flavor='mysql') df.to_dict 读 直接读取html中的表格 pd.read_html(&quot;https://coinmarketcap.com/currencies/bitcoin/&quot;) df.from_dict 数据清洗、分析 清洗 drop(), dropna(), fillna(), replace(), 重复值处理: duplicated()，unique()，drop_duplictad() 转格式 pd.to_datetime() : Convert argument to datetime, so you can df.sort_values() by time. 分析 groupby a6214[&quot;Value_IN(ETH)&quot;].groupby(a6214[&quot;From&quot;]) # 按照转账人分类，得到的结果为SeriesGroupBy类型 显示 打印dataframe设置 完整打印table 当一行较长时，完整显示一行：'display.max_rows', None, 'display.max_columns', None 不自动换行：expand_frame_repr', False 123conn = sqlite3.connect('./order_record.db', detect_types=sqlite3.PARSE_DECLTYPES)with pd.option_context('display.max_rows', None, 'display.max_columns', None, 'expand_frame_repr', False): # more options can be specified also print(pd.read_sql_query("SELECT * FROM ALL_ORDER", conn)) 显示的精度 pandas.set_option(&quot;display.precision&quot;, 10) reference 十分钟快速入门 Pandas ↩ 10 Minutes to pandas ↩ indexnext |previous |Python For Data Analysis: Pandas入门 ↩ difference between dataframe div and dataframe divide in pandas ↩]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fflask%2F</url>
    <content type="text"><![CDATA[quick start ###Unique URLs / Redirection Behavior The following two rules differ in their use of a trailing slash. 123456@app.route(&apos;/projects/&apos;)def projects(): return &apos;The project page&apos;@app.route(&apos;/about&apos;)def about(): return &apos;The about page&apos; The canonical URL for the projects endpoint has a trailing slash. It’s similar to a folder in a file system. If you access the URL without a trailing slash, Flask redirects you to the canonical URL with the trailing slash. The canonical URL for the about endpoint does not have a trailing slash. It’s similar to the pathname of a file. Accessing the URL with a trailing slash produces a 404 “Not Found” error. This helps keep URLs unique for these resources, which helps search engines avoid indexing the same page twice. reference]]></content>
  </entry>
  <entry>
    <title><![CDATA[jupyter]]></title>
    <url>%2Fjupyter%2F</url>
    <content type="text"><![CDATA[A Tutorial package management pip只能管理python package，而conda可以管理非python语言的package。 So Conda is a packaging tool and installer that aims to do more than what pip does; handle library dependencies outside of the Python packages as well as the Python packages themselves. 曾读到过，对于python package，conda基本就是用的pip。简单讲，如果安装一个包的命令是pip install wanted_package，在conda中conda install wanted_package同样可以安装。 package for jupyter Since jupyter is belong to anaconda, package shall be installed by conda if you want use it in jupyter! pylab help info %pylab? This sentence will give out the ‘help information’ of pylab. Note that %pylab will be imported! magics Magics come in two kinds:【ct】可以简单理解为单行/多行 Line magics these are commands prepended by one % character and whose arguments only extend to the end of the current line. %run可以从.py和.ipynb文件 Cell magics: Some simple cell magics 123%%writefile foo.pyprint('foo')print('Equinox') Magics for running code under other interpreters IPython has a %%script cell magic, which lets you run a cell in a subprocess of any interpreter on your system, such as: bash, ruby, perl, zsh, R, etc. To use it, simply pass a path or shell command to the program you want to run on the %%script line, and the rest of the cell will be run by that script, and stdout/err from the subprocess are captured and displayed. 123%%script python2 import sys print &apos;hello from Python %s&apos; % sys.version Background Scripts These scripts can be run in the background, by adding the --bg flag. When you do this, output is discarded unless you use the --out/err flags to store output as above. 123456%%ruby --bg --out ruby_linesfor n in 1...10 sleep 1 puts &quot;line #&#123;n&#125;&quot; STDOUT.flushend shortcut key Jupyter Notebook 的快捷键 Keyboard shortcuts command mode ESC: command mode h: 显示快捷键帮助 Enter: edit mode ctrl+enter、shitf+enter: 执行、执行后选中下个单元 a/b: 在上/下方插入新单元 dd: 删除当前cell m: 设为markdown cell y: 单元转入代码状态 3: 设定 3 级标题 x/c/v: 剪切/复制/粘贴 space/shift+spcae: 向下/上滚动 Shift-K/J : 扩大选中上/下方单元 合并/分割 shfit + m / shift + ctrl + - cmd + s : safe and Checkpoint restart kernel 00 即在command mode下， edit mode alt + 左键: 列模式 shift+tab: 补全提示 ctrl + shift + -: 分割cell cmd+[ 减小缩进 Errors c.NotebookApp.allow_origin and c.NotebookApp.ip : They don’t work. Except certain ip, it supposes to be unaccessible when these parameters is set. Tips change default browser $ jupyter notebook --generate-config And then in ~/.jupyter/jupyter_notebook_config.py file, c.NotebookApp.browser = ' should be modified to c.NotebookApp.browser = 'open -a /Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome %s'. 2018.07.06: In OS X, the easiest way is modifying the system default browser to Chrome and then jupyter-notebook will use Chrome as default browser. about proxy **NOTE: proxy extension (such as shadowsocks) will induce error – ERR_EMPTY_RESPONSE ** In Chrome, the use of privoxy will lead to a forever loading page. (Maybe it’s because the local http request is transferred by proxy and hence the port is changed to 12333.) Solution: You can change SS to “自动代理模式” and start jupyter, and then change SS back to “全局代理模式”. Pretty Display of Varibles 12from IPython.core.interactiveshell import InteractiveShellInteractiveShell.ast_node_interactivity = &quot;all&quot; 不让变量输出 结尾加个分号！variable; 添加目录功能 conda install -c conda-forge jupyter_contrib_nbextensions convert to .py file jupyter nbconvert --to script [YOUR_NOTEBOOK].ipynb jupyter notebook list Show running notebook add kernel &amp; edit kernel Add kernel: How do I add python3 kernel to jupyter (IPython) NOTE: Don’t forget to point to a specific python. 12python3.7-m pip install ipykernelpython3.7 -m ipykernel install --user Edit kernel: Jupyter notebook not pointing to Anaconda source 1 source 2 27 个Jupyter Notebook的小提示与技巧 reference]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker note]]></title>
    <url>%2Fdocker%2F</url>
    <content type="text"><![CDATA[Official introduction: Docker is an open platform for developers and sysadmins to build, ship, and run distributed applications, whether on laptops, data center VMs, or the cloud. 我认为可以这样介绍：docker是没有性能损失的、打包软件及其运行运行环境(包括系统在内的)的虚拟机。“Build Once, Run Anywhere!” galamost-3.0.9 docker测试 完全没有速度损失（docker vs. no-docker in 1080TI: 700 TPS vs. 700±20 TPS; IP: 101）。 即使host上为cuda8.0而docker上为cuda9.0，速度也基本没有损失（docker vs. no-docker in 1080: 513 TPS vs. 533 TPS; IP: 106）。 Docker介绍 首先，Docker不会降低性能！ docker性能(2015年的文章)[1]： docker利用namespace实现系统环境的隔离；利用Cgroup实现资源限制； …… docker还存在着以下几个缺点： 1.资源隔离方面不如虚拟机，docker是利用cgroup实现资源限制的，只能限制资源消耗的最大值，而不能隔绝其他程序占用自己的资源。 2.安全性问题。docker目前并不能分辨具体执行指令的用户，只要一个用户拥有执行docker的权限，那么他就可以对docker的容器进行所有操作，不管该容器是否是由该用户创建。比如A和B都拥有执行docker的权限，由于docker的server端并不会具体判断docker cline是由哪个用户发起的，A可以删除B创建的容器，存在一定的安全风险。 Docker Engine Utility for NVIDIA GPUs 这是nvidia官方支持的docker项目，里面一个issue提到了正常情况下，效率没有损失 By default, a container has no resource constraints and can use as much of a given resource as the host’s kernel scheduler will allow.[2] docker在web开发中得使用流程是怎样的？[3] 使用Docker的正确姿势 Tomcat+Mysql,怎么做？ 我们构建两个镜像，一个仅安装Tomcat并部署我们的app，另一个仅安装MySQL，然后启动这两个镜像，得到两个容器，再利用Docker的容器互联技术将二者连接(Docker的容器是通过http连接的)。 docker原理的简介： 基础介绍 原理[4] 让某些进程在彼此隔离的命名空间中运行。大家虽然都共用一个内核和某些运行时环境（例如一些系统命令和系统库），但是彼此却看不到，都以为系统中只有自己的存在。这种机制就是容器（Container），利用命名空间来做权限的隔离控制，利用 cgroups 来做资源分配。 灵剑 docker可以使用docker build工具链将应用和所有依赖整个安装到镜像中，部署的时候直接启动容器就是一个正确运行的服务了。docker build使用Dockerfile，Dockerfile是一个文本文件，相当于一个脚本，可以在CI系统中自动执行，做持续集成、持续部署很容易，build、test成功后直接替换线上的镜像就行。从原理上来说，docker并不是一个完全独立的虚拟化环境，而是一个有独立namespace的进程，所以启动开销就跟直接在物理机上启动服务差不多，但是保证了环境隔离。 作者：灵剑 链接：https://www.zhihu.com/question/51134842/answer/189312743 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Docker技术架构图[5] 从Docker依赖的底层技术来看，Docker原生态是不能直接在Windows平台上运行的，只支持linux系统，原因是Docker依赖linux kernel三项最基本的技术,namespaces充当隔离的第一级，是对Docker容器进行隔离，让容器拥有独立的hostname,ip,pid，同时确保一个容器中运行一个进程而且不能看到或影响容器外的其它进程;Cgroups是容器对使用的宿主机资源进行核算并限制的关键功能。 比如CPU,内存,磁盘等，union FS主要是对镜像也就是image这一块作支持，采用copy-on-write技术，让大家可以共用某一层，对于某些差异层的话就可以在差异的内存存储，Libcontainer是一个库，是对上面这三项技术做一个封装。 rootfs[6] 内核空间是 kernel，Linux 刚启动时会加载 bootfs 文件系统，之后 bootfs 会被卸载掉。 用户空间的文件系统是 rootfs，包含我们熟悉的 /dev, /proc, /bin 等目录。 对于 base 镜像来说，底层直接用 Host 的 kernel，自己只需要提供 rootfs 就行了。 而对于一个精简的 OS，rootfs 可以很小，只需要包括最基本的命令、工具和程序库就可以了。相比其他 Linux 发行版，CentOS 的 rootfs 已经算臃肿的了，alpine 还不到 10MB。 这里需要说明的是： base 镜像只是在用户空间与发行版一致，kernel 版本与发行版是不同的。 例如 CentOS 7 使用 3.x.x 的 kernel，如果 Docker Host 是 Ubuntu 16.04（比如我们的实验环境），那么在 CentOS 容器中使用的实际是是 Host 4.x.x 的 kernel。 容器只能使用 Host 的 kernel，并且不能修改。 writable container[6] 当容器启动时，一个新的可写层被加载到镜像的顶部。 这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。 所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。 只有容器层是可写的，容器层下面的所有镜像层都是只读的。 下面我们深入讨论容器层的细节。 镜像层数量可能会很多，所有镜像层会联合在一起组成一个统一的文件系统。如果不同层中有一个相同路径的文件，比如 /a，上层的 /a 会覆盖下层的 /a，也就是说用户只能访问到上层中的文件 /a。在容器层中，用户看到的是一个叠加之后的文件系统。 添加文件 在容器中创建文件时，新文件被添加到容器层中。 读取文件 在容器中读取某个文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后打开并读入内存。 修改文件 在容器中修改已存在的文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后修改之。 删除文件 在容器中删除文件时，Docker 也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。 只有当需要修改时才复制一份数据，这种特性被称作 Copy-on-Write。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。 技术细节 runtime/runc[7] 容器 runtime runtime 是容器真正运行的地方。runtime 需要跟操作系统 kernel 紧密协作，为容器提供运行环境。 如果大家用过 Java，可以这样来理解 runtime 与容器的关系： Java 程序就好比是容器，JVM 则好比是 runtime。JVM 为 Java 程序提供运行环境。同样的道理，容器只有在 runtime 中才能运行。 lxc、runc 和 rkt 是目前主流的三种容器 runtime。 lxc 是 Linux 上老牌的容器 runtime。Docker 最初也是用 lxc 作为 runtime。 runc 是 Docker 自己开发的容器 runtime，符合 oci 规范，也是现在 Docker 的默认 runtime。 rkt 是 CoreOS 开发的容器 runtime，符合 oci 规范，因而能够运行 Docker 的容器。 image增量存储、类似git 概念 可以参考官方Docker glossary Registry 即注册服务。注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像 Dockerfile 告诉docker build命令应该执行哪些操作。 NAMES 自动分配的容器名称，可视为数字ID的昵称 layer In an image, a layer is modification to the image, represented by an instruction in the Dockerfile. Layers are applied in sequence to the base image to create the final image. When an image is updated or rebuilt, only layers that change need to be updated, and unchanged layers are cached locally. This is part of why Docker images are so fast and lightweight. The sizes of each layer add up to equal the size of the final image. 在 Dockerfile 文件中写入指令，每个指令都在映像上生成一个新的层。Docker 限制每个映像最多有 127 层，因此，要尽量优化映像层数。 During the ‘build’, the image is generated layer by layer. If bugs are encountered, you can start the toppest correct layer and debug the bug layer. 构建缓存[4] 在执行每条指令之前，Docker 都会在缓存中查找是否已经存在可重用的镜像，如果有就使用现存的镜像。如果你不想在构建过程中使用缓存，你可以在 docker build 命令中使用 --no-cache=true 选项。遵循的基本规则如下： 从一个基础镜像开始（FROM 指令指定），下一条指令将和该基础镜像的所有子镜像进行匹配，检查这些子镜像被创建时使用的指令是否和被检查的指令完全一样。如果不是，则缓存失效。 然而，有些指令需要更多的检查和解释。 对于 ADD 和 COPY 指令，镜像中对应文件的内容也会被检查，每个文件都会计算出一个校验和。文件的最后修改时间和最后访问时间不会纳入校验。在缓存的查找过程中，会将这些校验和和已存在镜像中的文件校验和进行对比。如果文件有任何改变，比如内容和元数据，则缓存失效。 除了 ADD 和 COPY 指令，缓存匹配过程不会查看临时容器中的文件来决定缓存是否匹配。例如，当执行完 RUN apt-get -y update 指令后，容器中一些文件被更新，但 Docker 不会检查这些文件。这种情况下，只有指令字符串本身被用来匹配缓存。 CoreOS[8] 目前最常用的用来执行Docker集装箱的Linux发行版本既不是Ubuntu、Debian也不是RedHat、Fedora，而是CoreOS。这个发行版本根本没有软件包管理程序，所以也不能通过输入某个命令来安装软件。但是CoreOS预装了Docker，所以可以制作集装箱镜像，或者下载别人发布的集装箱镜像来执行。 应用 deploy for AI There are many AI-related docker in Datmo docker NAMD ==NOTE: dockerd NAMD can be used in Microsoft Azure!!! == 2.11-icc-mkl-intelmpi contains an optimized NAMD image compatible with Azure Infiniband/RDMA instances Amber With official support! nvidia/cuda galamost3 优点/缺点 优点 保证了线上线下环境的一致性 简化了部署流程 只需要从DockerHub上pull一个镜像就可以 实现了沙盒机制，提高了安全性 由于webapp运行在容器中，与操作系统隔离开了，从而使操作系统基本不可能受到破坏，另外如果webapp因为攻击而瘫痪，并不需要重启服务器，直接重启容器或者再启动一个镜像就可以了。 缺点 参见[9]和[10] 调度系统的服务、环境变量 例如利用cron服务，一旦将cron服务容器化后，原始的环境变数设定都会失效。 你也不能使用环境变量在生成镜像的时候根据条件来改变指令(per #2637)。 其他 Why we don’t let non-root users run Docker in CentOS, Fedora, or RHEL Docker (开源项目)改名 Moby 今后的工作方式是：贡献Moby下的项目，然后使用Docker公司的Docker CE产品。 if the image size is too large, google docker reduce image size Kubernetes 是什么？ Frequently Asked Questions Does it have a performance impact on my GPU workload? No, usually the impact should be in the order of less than 1% and hardly noticeable. Do you support CUDA Multi Process Service (a.k.a. MPS)? No, MPS is not supported at the moment. However we plan on supporting this feature in the future, and this issue will be updated accordingly. Do you support running a GPU-accelerated X server inside the container? No, running a X server inside the container is not supported at the moment and there is no plan to support it in the near future (see also OpenGL support). I have multiple GPU devices, how can I isolate them between my containers? GPU isolation is achieved through a container environment variable called NVIDIA_VISIBLE_DEVICES. Devices can be referenced by index (following the PCI bus order) or by UUID (refer to the documentation). Why is nvidia-smi inside the container not listing the running processes? nvidia-smi and NVML are not compatible with PID namespaces. We recommend monitoring your processes on the host or inside a container using --pid=host. Command docker --help docker ps/start/stop 查看/停止/启动容器 docker list/rmi 列出/删除本地镜像 run docker run -it -p 8080:80 centos:latest /bin/bash，表示用latest版本，shell为bash， -p 将container8080端口映射到80端口。 -d 守护容器，就是后台运行，退出命令窗口容器也不会停止 -it 交互式容器 退出命令窗口容器就停止运行了 -P 将容器内部使用的网络端口映射到我们使用的主机上。docker ps会显示端口是如何映射的 --runtime=nvidia without it gpu and its drive wouldn’t be found. --name your_name assign a name to your container run centos image in background[11] docker run --runtime=nvidia -t -d --name conda_hoomd timchen314/galamost3:3.0.9 /bin/bash automatically restart --restart=always 意味着无论容器因何种原因退出（包括正常退出），就立即重启。 --restart=on-failure:3，意思是如果启动进程退出代码非0，则重启容器，最多重启3次。 exec docker exec -it your_container_name bash # login an existed container run source Source is not an executable (source is a bash shell built-in command that executes the content of the file passed as argument) docker run --rm -ti _image_name_ bash -c 'source FILE' Piping a file into docker run echo 'export=$PATH:/opt/miniconda2/bin/' | docker exec -i conda_hoomd bash -c &quot;cat &gt;&gt; /etc/profile&quot; Note that it won’t work in this way: docker exec -i conda_hoomd echo 'export=$PATH:/opt/miniconda2/bin/' &gt;&gt; /etc/profile pause/unpause cp 12docker cp foo.txt mycontainer:/foo.txtdocker cp mycontainer:/foo.txt foo.txt rm remove all exited containers: docker rm -v $(docker ps -aq -f status=exited) attach 直接进入容器 启动命令 的终端，不会启动新的进程。 system docker system prune tag 每个仓库会有多个镜像，用tag标示，如果不加tag，默认使用latest镜像(不设tag，则默认为latest)[12]。 [image name] = [repository]:[tag] 注意！一个repo可以含有多个image！一个image可以打上多个tag！只有[repository]:[tag]唯一对应一个image！ 1234docker tag myimage-v1.9.2 myrepo:1docker tag myimage-v1.9.2 myrepo:1.9docker tag myimage-v1.9.2 myrepo:1.9.2docker tag myimage-v1.9.2 myrepo:latest 如果执行下面的命令，之前的tag会自动覆盖掉。 1docker tag myimage-v2.0.0 myrepo:latest logs Docker daemon log: /var/log/daemon.log | grep docker[13] 保存/加载tar格式的镜像 12docker save -o centos.tar xianhu/centos:git # 保存镜像, -o也可以是--outputdocker load -i centos.tar # 加载镜像, -i也可以是--input -H 指定host IP[14] 默认配置下，Docker daemon 只能响应来自本地 Host 的客户端请求。如果要允许远程客户端请求，需要在配置文件中打开 TCP 监听，步骤如下： 1.编辑配置文件 /etc/systemd/system/multi-user.target.wants/docker.service，在环境变量 ExecStart 后面添加 -H tcp://0.0.0.0，允许来自任意 IP 的客户端连接。 根据已有容器，新建自有镜像 docker commit -m &quot;centos with git&quot; -a &quot;your_name&quot; 72f1a8a0e394 The last is container ID. -a means author docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]] Dockerfile show info docker images 显示已有docker docker ps -a 查看终止状态的容器 docker stats -a Resource Usage docker top NAMES 查看容器内部运行的进程 docker system df show the used space docker history your_image show tags For the images pulled to hub.docker.com, the tags can be found by： visit ‘https://hub.docker.com/r/library/debian/tags/’ and you can see tags。 By replace “/r/” in path to “/v2/repositories/” the tags can be downloaded and analysed. curl 'https://registry.hub.docker.com/v2/repositories/library/debian/tags/'|jq '.&quot;results&quot;[][&quot;name&quot;]' will List first 10 tags! [15] Note: jq is a tool for processing JSON inputs. If all tags is needed, see reference[15]. VALIDATE: curl 'https://registry.hub.docker.com/v2/repositories/library/python/tags/'|jq '.&quot;results&quot;[][&quot;name&quot;]' does work! build 注释符号# ADD 与 COPY 类似，从 build context 复制文件到镜像。不同的是，如果 src 是归档文件（tar, zip, tgz, xz 等），文件会被自动解压到 dest。 ARG 构建参数[4] 格式：ARG &lt;参数名&gt;[=&lt;默认值&gt;] 构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history 还是可以看到所有值的。 CMD 三种格式[16] Exec 格式：CMD [“executable”,“param1”,“param2”] 这是 CMD 的推荐格式。 CMD [“param1”,“param2”] 为 ENTRYPOINT 提供额外的参数，此时 ENTRYPOINT 必须使用 Exec 格式。 Shell 格式：CMD command param1 param2 指令就是用于指定默认的容器主进程的启动命令的。[4] 在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，docker run -it ubuntu cat /etc/os-release 在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 &quot;，而不要使用单引号。 如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。比如： CMD echo $HOME 在实际执行中，会将其变更为： CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ] 另外，docker的主程序不能是退出或后台运行的状态： 对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。 COPY 支持两种形式： 12COPY src destCOPY [&quot;src&quot;, &quot;dest&quot;] ENTRYPOINT &lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot; ENTRYPOINT 不会被忽略，一定会被执行，即使运行 docker run 时指定了其他命令。 ENTRYPOINT [&quot;/bin/echo&quot;, &quot;Hello&quot;] CMD [&quot;world&quot;] 当容器通过 docker run -it [image] 启动时，输出为： Hello world 而如果通过 docker run -it [image] CloudMan 启动，则输出为： Hello CloudMan PS: 最佳实践[16] 使用 RUN 指令安装应用和软件包，构建镜像。 如果 Docker 镜像的用途是运行应用程序或服务，比如运行一个 MySQL，应该优先使用 Exec 格式的 ENTRYPOINT 指令。CMD 可为 ENTRYPOINT 提供额外的默认参数，同时可利用 docker run 命令行替换默认参数。 如果想为容器设置默认的启动命令，可使用 CMD 指令。用户可在 docker run 命令行中替换此默认命令。 ENV 12ENV MY_VERSION 1.3RUN apt-get install -y mypackage=$MY_VERSION 以设置PATH为例： 1ENV PATH=&quot;/opt/conda3/bin:$&#123;PATH&#125;&quot; LABEL LABEL指令添加元数据到一个镜像。一个LABEL是一个键值对。要在LABEL值中包含空格，使用双引号和反斜杠(续行)。 查看LABEL，可以用docker inspect。 例子： 12345LABEL "com.example.vendor"="ACME Incorporated"LABEL com.example.label-with-value="foo"LABEL version="1.0"LABEL description="This text illustrates \that label-values can span multiple lines." MAINTAINER (depreciate) 设置镜像的作者，可以是任意字符串。 其他 EXPOSE VOLUME RUN 安装 Mac OS homebrew直接安装 brew cask install docker CentOS 官网 官网的方法是最正确的： 12345678910# Add the package repositoriescurl -s -L https://nvidia.github.io/nvidia-docker/centos7/x86_64/nvidia-docker.repo | \ sudo tee /etc/yum.repos.d/nvidia-docker.repo# Install nvidia-docker2 and reload the Docker daemon configurationsudo yum install -y nvidia-docker2sudo pkill -SIGHUP dockerd# Test nvidia-smi with the latest official CUDA imagedocker run --runtime=nvidia --rm nvidia/cuda nvidia-smi CentOS runoob 单独安装docker-ce非常麻烦的，因为需要安装和配置nvidia-container-runtime： 1234567sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.reposudo yum install -y docker-cesudo systemctl start dockersudo docker run hello-world# install nvidia-container-runtimeyum install -y nvidia-container-runtime# Then you should follow the troublesome setting process in https://github.com/nvidia/nvidia-container-runtime#docker-engine-setup Docker Machine Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。 configuration bash-completion 123ln -s /Applications/Docker.app/Contents/Resources/etc/docker.bash-completion ln -s /Applications/Docker.app/Contents/Resources/etc/docker-machine.bash-completion ln -s /Applications/Docker.app/Contents/Resources/etc/docker-compose.bash-completion docker run hello-world for test error &quot;Docker version reports bad response from Docker engine&quot; A lot of people encounter this error (https://forums.docker.com/t/docker-version-reports-bad-response-from-docker-engine/13395). For me, I sovled this by reset to factory defaults. problem use gcc5.x (solved) source /opt/rh/devtoolset-4/enable can’t get the size of remote image (unsolved) by google: docker remote image size, or docker image size in REPOSITORY, there is no cli command to do this. A complicate answer is: Docker: How to get image size? reference 入门 只要一小时，零基础入门Docker runoob 进阶 Docker Cheat Sheet 官网 get started Docker — 从入门到实践 待读 Examples of Dockerfile: centos 123456789FROM scratchADD centos-7-docker.tar.xz /LABEL name="CentOS Base Image" \ vendor="CentOS" \ license="GPLv2" \ build-date="20180107"CMD ["/bin/bash"] docker与虚拟机实现原理比较 ↩ Limit a container’s resources ↩ docker在web开发中得使用流程是怎样的？ ↩ Docker — 从入门到实践 ↩ ↩ ↩ ↩ 【 全干货 】5 分钟带你看懂 Docker ！ ↩ 每天5分钟玩转Docker容器技术（三） ↩ ↩ 每天5分钟玩转Docker容器技术（一） ↩ 分布式机器学习的故事：Docker改变世界 ↩ 一年之后重新审视 Docker —— 根本性缺陷和炒作 ↩ Docker架构优缺点大剖析 ↩ Docker container will automatically stop after “docker run -d” ↩ 镜像命名的最佳实践 - 每天5分钟玩转 Docker 容器技术（18） ↩ Where is the Docker daemon log? ↩ 每天5分钟玩转Docker容器技术（二） ↩ How to list all tags of a docker image ↩ ↩ RUN vs CMD vs ENTRYPOINT - 每天5分钟玩转 Doc ker 容器技术（17） ↩ ↩]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>cloud computing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令之service]]></title>
    <url>%2Flinux_senior_service%2F</url>
    <content type="text"><![CDATA[service，顾名思义，是用于对系统服务进行管理的命令。 Basically, it’s a shell script! vi it! Besides, chkconfig is a closely related command. CentOS中的介绍： 123456789101112131415161718192021$ info serviceDESCRIPTION service runs a System V init script in as predictable environment as possible, removing most environment variables and with current working directory set to /. The SCRIPT parameter specifies a System V init script, located in /etc/init.d/SCRIPT. The supported values of COMMAND depend on the invoked script, service passes COMMAND and OPTIONS it to the init script unmodified. All scripts should support at least the start and stop commands. As a special case, if COMMAND is --full-restart, the script is run twice, first with the stop command, then with the start command. service --status-all runs all init scripts, in alphabetical order, with the status command. If the init script file does not exist, the script tries to use legacy actions. If there is no suitable legacy action found and COMMAND is one of actions specified in LSB Core Specification, input is redirected to the systemctl. Otherwise the command fails with return code 2. [TOC] service命令 service network start就相当于/etc/init.d/network start。 An example of service command: 12$ service netconsoleUsage: /etc/init.d/netconsole &#123;start|stop|status|restart|condrestart&#125; Comman used option include “start|stop|status|restart” An example of init service script: 123456789101112case "$1" in start) do start-thing; ;; stop) do stop-thing; ;; restart) do restart-thing; ;; ...esac chkconfig命令 service与chkconfig的关系归纳为：[1] 先要注册成为系统服务(即service可以调用)，然后才能使用chkconfig控制运行级别。 service是chkconfig的前提条件。 注意：谨记chkconfig不是立即自动禁止或激活一个服务，它只是简单的改变了/etc/rc*.d中的符号连接。[2] chkconfig --list If you want to list systemd services use ‘systemctl list-unit-files’. chkconfig --add/del SERVICE chkconfig SERVICE on/off 是否开机就执行 chkconfig --level SERVICE 3456 只在3456级别下运行该SERVICE (/etc/rc*.d下)S开始的文件向脚本传递start参数 K开始的文件向脚本传递stop参数 K/S后面的数字代表开机启动脚本中的启动顺序，数组越大启动越晚。[2] 相应级别的文件在/etc/rc*.d之下 12$ ls /etc/rc*.d -d/etc/rc.d /etc/rc0.d /etc/rc1.d /etc/rc2.d /etc/rc3.d /etc/rc4.d /etc/rc5.d /etc/rc6.d PS: /etc/rc.d/rc*.d/下的文件均为符号链接，最终绝大部分都是都是链接到/etc/rc.d/init.d下面。/etc/rc.d/init.d目录下面的都是开启启动脚本文件，用来启动相应的程序。 PPS: 开机顺序 硬件自检 -&gt; 初始化启动bootloade -&gt; 加载内核 -&gt; 初始化硬件 -&gt; 加载根文件系统 -&gt; 加载驱动 -&gt; 启动一个init用户级程序 PPPS: 上面两次加载硬件，是因为驱动分成两种：[3] 1.随内核加载的驱动，一般是中断控制器，串口，定时器，时钟，各种总线等；这种驱动的初始化函数一般会放到一个特殊的初始化段中，在内核初始化时调用； 2.编译成模块的驱动，在内核初始化完成，也就是初始线程创建完成，出现shell时，根据应用程序的需要或者脚本按需加载。 reference linux中注册系统服务—service命令的原理通俗 ↩ linux启动脚本和service、chkconfig ↩ ↩ 古斟布衣 ↩]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tools for MD analysis]]></title>
    <url>%2Ftools_for_MD_analysis%2F</url>
    <content type="text"><![CDATA[+ and - means pro and con of the tool! The conclusion: MDTraj seems a powerful tools, but once in a while it still feel troublesome. MDTraj + convert files are awesome - most of it is coded by python - suck for xml (e.g. can't read image) - the rotation utilities is hard to use. MDAnalysis - Python2 only CPPTRAJ - for Amber ST-analyzer + with GUI LOOS + OO - for structural analysis Pteros - developed by only one person Python Tools for Machine Learning scikit-learn: SVM and others Deep learning: Theano reference]]></content>
      <categories>
        <category>MD simulation</category>
      </categories>
      <tags>
        <tag>MD simulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[solving linux problem]]></title>
    <url>%2Flinux_problem%2F</url>
    <content type="text"><![CDATA[解决各种linux问题。 linux挂载2T以上硬盘 找到硬盘编号 ls /dev/sd* 结果一般为： /dev/sda /dev/sda1 /dev/sda2 /dev/sda3 /dev/sdb 后面跟很多数字的是系统盘，上面的例子中系统盘是/dev/sda；那么/dev/sdb就是新安装的备份盘。 root下，执行parted /dev/sdb以建立分区列表 mklabel gpt #(有不同选项，如MS-DOS gpt Mac) 3T/4T盘必须要手动建立分区列表 mkpart + Enter键 ext4 + Enter键 &quot;Start&quot;&quot; 2048s + Enter键 &quot;End&quot; -1s + Enter键 #（s是单位2048s留给分区列表） 可选步骤，对齐分区以最优化硬盘性能： align-check TYPE + Enter键 opt + Enter键 &quot;partition number?&quot; 1 + Enter键 mkfs.ext4 /dev/sdb/ # 格式化硬盘 mount # 挂载 123mkdir /home/your_name/backup #建立文件夹mount -t ext4 /dev/sdb /home/your_name/backup #挂载文件夹chown -R your_name:your_name /home/your_name/backup 修改/etc/fstab # 设置开机后自动挂载备份硬盘 得到硬盘的UUID： 12[root@node34 ~]$ uuidgen /dev/sdac6af66d2-f6dc-4a4b-8d83-40ce2b8d0b75 打开/etc/fstabe，加入备份盘的UUID： UUID=c6af66d2-f6dc-4a4b-8d83-40ce2b8d0b75 /home/your_name/backup/ ext4 defaults 1 2]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy notes]]></title>
    <url>%2Fnumpy%2F</url>
    <content type="text"><![CDATA[[TOC] The fundamental package for scientific computing with Python. Introduction Best tutorial: Quickstart tutorial Since pythoner usually do import numpy as np, in most scenes ‘np’ measn ‘numpy’ Note: an 1d array in numpy acts like a row vector in linear algebra, but most lienar algebra textbook are written in column form! In text book: matrix x column vector = column vector In numpy: row vector x matrix.T = row vector string type numpy array automatically encode the string to bytes! 1new_a = a.astype('U') # get string instead of bytes 帮助：np.info 例如np.info(np.random) broadcasting Broadcasting is one of most error-prone concept in numpy. When operating on two arrays, NumPy compares their shapes element-wise. It starts with the trailing dimensions, and works its way forward. Two dimensions are compatible when: they are equal, or one of them is 1 reshape can turn off the broadcast an telling example A (4d array): 8 x 1 x 6 x 1 B (3d array): 7 x 1 x 5 Result (4d array): 8 x 7 x 6 x 5 So for a single dimension, the broadcast means numpy will expand (6 x 1) to (6 x 5)， and then do element-wise operation. ndarray学习 numpy中的ndarray方法和属性 ndarray.mean(axis=None, dtype=None, out=None)：返回指定轴的数组元素均值 ndarray.var(axis=None, dtype=None, out=None, ddof=0)：返回数组的方差，沿指定的轴。 ndarray.std(axis=None, dtype=None, out=None, ddof=0)：沿给定的轴返回数则的标准差 注意std默认是除以N而不是N-1的，如果要除以N-1，将ddof设为1；另外，pandas中std是除以N-1的。 ndarray.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)：返回沿对角线的数组元素之和 ndarray.diagonal(offset=0, axis1=0, axis2=1)：返回对角线的所有元素。 最大/小值 ndarray.argmin(axis=None, out=None):返回指定轴最小元素的索引。 darray.min(axis=None, out=None)：返回指定轴的最小值 flat/flatten ndarray.flat 和 ndarray.T 一样不是函数调用 12345 &gt;&gt;&gt; x = X.flat &gt;&gt;&gt; x&lt;numpy.flatiter object at 0x9e82278&gt; # 不直接返回一维数组 # 但可直接索引 flatten()是函数调用，可以指定平坦化的参数。 ndarray.flatten(order='C') 可选参数，order： （1）’C’：C-style，行序优先 （2）’F’：Fortran-style，列序优先 （3）’A’：保持 （4）默认为’C’ ndarray.transpose(*axes) :返回矩阵的转置矩阵 ndarray.take(indices, axis=None, out=None, mode=’raise’):获得数组的指定索引的数据，如： 1234 &gt;&gt;&gt; a.take([1,3],axis=1) #提取1，3列的数据array([[ 1, 3],[ 5, 7],[ 9, 11]]) numpy.argmax(a, axis=None, out=None) 非常有用 Returns the indices of the maximum values along an axis. doc 构造矩阵 arange()/linspace() numpy.zeros，numpy.ones，numpy.eye, numpy.empty((2,3)), numpy.full((2,2),7) 123456789101112 &gt;&gt;&gt; print np.zeros((3,4))[[ 0. 0. 0. 0.] [ 0. 0. 0. 0.] [ 0. 0. 0. 0.]] &gt;&gt;&gt; print np.ones((3,4))[[ 1. 1. 1. 1.] [ 1. 1. 1. 1.] [ 1. 1. 1. 1.]] &gt;&gt;&gt; print np.eye(3)[[ 1. 0. 0.] [ 0. 1. 0.] [ 0. 0. 1.]] 矩阵indexing automatic reshaping 1234 &gt;&gt;&gt; a = np.arange(30) &gt;&gt;&gt; a.shape = 2,-1,3 # -1 means &quot;whatever is needed&quot; &gt;&gt;&gt; a.shape(2, 5, 3) Indexing with Arrays of Indices Suppose a and idx is a np.array, then a[i].shape == idx.shape Supose a, idx_i and idx_j is a np.array, if idx_i.shape == idx_j.shape, then a[i,j].shape == idx_i.shape, idx_i is the first axis index of array a, idx_j is the second axis index of array a. 12list_ij=[i,j]a[list_ij] == a[i,j] # this statement is true Indexing with Boolean Arrays12345678910111213 &gt;&gt;&gt; a = np.arange(12).reshape(3,4) &gt;&gt;&gt; b = a &gt; 4 &gt;&gt;&gt; b # b is a boolean with a's shapearray([[False, False, False, False], [False, True, True, True], [ True, True, True, True]], dtype=bool) &gt;&gt;&gt; a[b] # 1d array with the selected elementsarray([ 5, 6, 7, 8, 9, 10, 11]) &gt;&gt;&gt; a[b]=0 &gt;&gt;&gt; aarray([[0, 1, 2, 3], [4, 0, 0, 0], [0, 0, 0, 0]]) Note that a[b] is a 1d array! But a[b]=0 is a 2d array! This is because if you don’t assign a value to the ‘False’ element, there is no value for that element. 数据添加与拷贝 c=a.copy深拷贝 vstack和hstack函数： vstack、hstack是深拷贝 1234567 &gt;&gt;&gt; a = np.ones((2,2)) &gt;&gt;&gt; b = np.eye(2) &gt;&gt;&gt; print np.vstack((a,b))[[ 1. 1.] [ 1. 1.] [ 1. 0.] [ 0. 1.]] row_stack(matrix,a_row) 向二维矩阵尾部添加一行 numpy.linalg 12345 &gt;&gt;&gt; import numpy.linalg as nplg &gt;&gt;&gt; a = np.array([[1,0],[2,3]]) &gt;&gt;&gt; print nplg.eig(a)(array([ 3., 1.]), array([[ 0. , 0.70710678], [ 1. , -0.70710678]])) comparison a == b #逐个元素比较 a &lt; 2 np.array_equal(a,b) arithmetic operation +, -, *, / #element-wise np.dot(a,b) # matrix multiply I/O np.save(‘myarray’,a) np.savez(‘myarray.npz’,a,b) np.save(‘myarray.npy’,a) np.loadtxt/savetxt/genfromtxt Other np.newaxis 123456789a=np.array([1,2,3,4,5])b=a[np.newaxis,:]print(a.shape,b.shape)(5,) (1, 5)a=np.array([1,2,3,4,5])b=a[:,np.newaxis]print(a.shape,b.shape)(5,) (5, 1)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python notes]]></title>
    <url>%2Fpython_notes%2F</url>
    <content type="text"><![CDATA[[TOC] Python features a dynamic type system and automatic memory management and supports multiple programming paradigms.[1] Python Syntax Python doc Python doc builtin function builtin functions (import builtins) abs() dict() help() min() setattr() all() dir() hex() next() slice() any() divmod() id() object() sorted() ascii() enumerate() input() oct() staticmethod() bin() eval() int() open() str() bool() exec() isinstance() ord() sum() bytearray() filter() issubclass() pow() super() bytes() float() iter() print() tuple() callable() format() len() property() type() chr() frozenset() list() range() vars() classmethod() getattr() locals() repr() zip() compile() globals() map() reversed() __import__() complex() hasattr() max() round() delattr() hash() memoryview() set() dict mydict.items() 将项以list返回 for key,val in myd3.items(): check if dict has element Note: I think this method is not easy to read for noobs. 为了方便记忆，可以将bool()读作有东西，例如： if bool(mydict):可以独坐如果mydict中有东西; if not bool(mylist):可以独坐如果mylist中有东西 123 &gt;&gt;&gt; mydict = &#123;&#125; &gt;&gt;&gt; bool(mydict)False iteriterms()返回迭代器，节省内存 Only for python2 dict.pop() pop(key[,default]) key: 要删除的键值 default: 如果没有 key，返回 default 值 1mydict.pop('mykey', None) PS: 或者也可以: 12if key in mydict: del mydict[key] dict comprehension filter a dictionary according condition {k: v for k, v in points.items() if v[0] &lt; 5 and v[1] &lt; 5} dict.get() doc: dict.get(k[,d]) -&gt; dict[k] if k in dict, else d. d defaults to None. Note taht if k is not in dict, dict.get won’t add k to dict dict initialize Following two ways are equivalent: 12myd = dict(age=27)myd = &#123;"age":27&#125; tuple 123my_tuple = ('haha',) # This is the right way to initialize an one-element tuple var = ('haha')type(var) # result is string set 交集，并集，差集，对称差集: 1234s1 &amp; s2s1 | s2s1 - s2s1 ^ s2 max() max() max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable,key=keyfunc). 几个例子 all()/any() Return True if all elements of the iterable are true (or if the iterable is empty). Equivalent to: 12345def all(iterable): for element in iterable: if not element: return False return True eval/repr repr将obj转化为字符串格式。 obj==eval(repr(obj)) example of repr: 123 &gt;&gt;&gt; dict = &#123;'runoob': 'runoob.com', 'google': 'google.com'&#125;; &gt;&gt;&gt; repr(dict)"&#123;'google': 'google.com', 'runoob': 'runoob.com'&#125;" filter 把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。 python3起，filter 函数返回的对象从列表改为 filter object（迭代器）。 1234def is_odd(n): return n % 2 == 1[item for item in filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]) ] getattr()/setattr()/hasattr()/delattr() getattr(x, ‘foobar’) is equivalent to x.foobar All these function are similar. See docs for more. enumerate 如果mylist是一个二维数组： 12for i,line in enumerate(mylist): ... line是元组 next(iterator[, default]) print print(end='str') staticmethod(function) PS: @classmethod means: when this method is called, we pass the class as the first argument instead of the instance of that class (as we normally do with methods). This means you can use the class and its properties inside that method rather than a particular instance. @staticmethod means: when this method is called, we don’t pass an instance of the class to it (as we normally do with methods). This means you can put a function inside a class but you can’t access the instance of that class (this is useful when your method does not use the instance). classmethod涉及类，不涉及类的实例；staticmethod两者都不涉及，但与类有紧密的联系 ref: sum() sum(iterable[, start]) ，iterable vars() From python doc: Return the __dict__ attribute for a module, class, instance, or any other object with a __dict__ attribute. Python——类属性/实例属性 Python——类属性/实例属性 Python类属性，实例属性 #非常好 123456C.__name__ # 类C的名字（字符串）C.__doc__ # 类C的文档字符串C.__bases__ # 类C的所有父类构成的元组C.__dict__ # 类C的属性C.__module__ # 类C定义所在的模块C.__class__ # 实例C对应的类 module.file 含有module的路径！ file f.readline()/readlines()/write()/writelines() readline()#每次读入一行 readlines() #以list的形式存储每一行 write() #自动换行 writelines() #不自动换行 f.closed 注意closed是一个变量，值为True/False for line in f:用法 下面程序将打印出f的内容 12for line in f: print(line,end='') list comprehension two fold list comprehension 12content = f.readlines()word_list=[word for line in content for word in line.split()] 语法结构的理解： list comprehension是将： 123for ... for/if ... do something ... 写成为： do something ... for ... for/if ... string 1. strip(s[, chars]) 去掉首尾的字符 默认情况下strip() 去掉首尾的whitespace 【whitespace include \n, \t and \r】。 The charsargument is not a prefix or suffix; rather, all combinations of its values are stripped: 12 &gt;&gt;&gt; 'www.example.com'.strip('cmowz.') 'example' 2. format significant digital(有效数字) 12345678 &gt;&gt;&gt; format(12.456789, '.3g')'12.5' &gt;&gt;&gt; format(12.456789, '.3f')'12.457' &gt;&gt;&gt; format(12.456789, '.3e')'1.246e+01' &gt;&gt;&gt; format(12.456789, '.3%')'1245.679%' '{0:.2f} {1:s} {2:d}'.format( v0[,v1[v2...] ) '{:,.2f}'中逗号表示较大的数字用逗号分隔，比如100万: 1, 000, 000 可以使用关键词 应用时转化：{!s}、{!r} 旧式字符串格式化符号是 %，如：{0:%.4f} custom object(define __format__ in a class) 12345class HAL9000(object): def __format__(self, format): if (format == 'open-the-pod-bay-doors'): return "I'm afraid I can't do that." return 'HAL 9000' datetime 12from datetime import datetime'&#123;:%Y-%m-%d %H:%M&#125;'.format(datetime(2001, 2, 3, 4, 5)) Another Example: 123# expiry and timestamp is string like 2018-06-29T12:00:00.000Z and 2018-04-19T18:44:44.320ZFMT = '%Y-%m-%dT%H:%M:%S'time_delta = datetime.strptime(expiry, FMT) - datetime.strptime(timestamp, FMT) named placeholder use key to hold the place. input the dictionary as elements 1234data = &#123;'first': 'Hodor', 'last': 'Hodor!'&#125;'&#123;first&#125; &#123;last&#125;'.format(**data)# or'&#123;first&#125; &#123;last&#125;'.format(first='Hodor', last='Hodor!') Getitem and Getattr Parametrized formats 3. rjust(width[, fillchar]) 【ljust(), center() is similar】 4. zfill(n) 左侧填充0至n位 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串。如果指定的长度小于字符串的长度则返回原字符串。 5. split(str=&quot;&quot;, num=string.count(str)) # str and num is not a kewword num – 分割次数。 注意split后常会产生空字符 6. join 12out.write(" ".join(mylist))# 用" "链接mylist中的iterm elegant use 1out.write(" ".join( map(str,iterable) )) 7. encode()/decode() str.encode(encoding=“utf-8”, errors=“strict”) 设置不同错误的处理方案。默认为 ‘strict’,意为编码错误引起一个UnicodeError。 其他可能得值有 ‘ignore’, ‘replace’, ‘xmlcharrefreplace’, ‘backslashreplace’ 以及通过 codecs.register_error() 注册的任何值。 or / and operator ref: How do the “and” and “or” operators work in Python? two additional functionality: short circuiting(短路求值) 12if param is not None and param['foo'] == 3: pass becasue of short circuiting, even if param doesn’t exist, param['foo'] won’t report error. Objects can have a boolean value Objects can have a boolean value, and boolean operators respect that. 123my_list = ["abc", "123"]["abc", "123"] or [] &gt;&gt;&gt; ["abc", "123"] short circuiting when objects have a boolean value Still take a list as an example: 12345[] and ["abc", "123"] &gt;&gt;&gt; []#NOTE:[1, 2] and ["abc", "123"] &gt;&gt;&gt; ["abc", "123"] ternary operator 1result='5 is larger than 3' if 5&gt;3 else '5 is not larger than 3' deep copy import copy dict.copy(mydict) CLI python -c &quot;print('hello world')&quot; python -m mymodule sys.path is changed it’s equal to python mymodule.py other useful things try-exception ref: Is it a good practice to use try-except-else in Python? (Answer is: Yes) 这种用法是标准用法 so-called race-condition 如果用if语句，错误可能出现在你检测之后，问题才出现（比如你检查磁盘是否有足够空间，可能你检查之后，磁盘又没有空间了）。try-exception则没有这个问题。 try-exception is very efficient CPython already implements code for exception checking at every step, regardless of whether you actually use exceptions or not finally: 之后的语句一定会被执行，哪怕之前已经执行了return语句! [2] [3] finally will execute no matter what, even if another line is being evaluated with a return statement. e.g.[3]: 12345678try: try_this(whatever)except SomeException as the_exception: handle_SomeException(the_exception)else: return something()finally: return True NOTE: 这个过程中，something()将会被调用执行，但不会被返回！因为finally劫持了程序，最终返回值为True. raise or raise ... from! Don’t raise Error Always raise (not raise Error) because in this way stacktrace will be kept. Or raise ... from, this can preserve the backtrace with exception chaining too: 1234567try: try_this(whatever)except SomeException as the_exception: handle(the_exception) raise # simplly raise it to upper level. This can keep stacktrace # or do it like this: # raise DifferentException from the_exception args of error e.g.: 12345678910try: raise ValueError("Bala bala", 3.14)except ValueError as e: print(e.args) # output is "Bala bala", 3.14 # print traceback print(traceback.format_exc()) # or print(traceback.format_tb( sys.exc_info()[2] )) 注意raise，没有写raise相当于没有错误发生！例子如下： 12345try: ValueError("Bala bala", 3.14)except ValueError as e: print(e.args) # no output traceback123456try: raise ValueError("Bala bala", 3.14)finally: print(sys.exc_info()) # exc_info contains three object: a type object, a Error object and a traceback object # Note: if Error is catched by 'except' statement, then in 'finally:' statement `print(sys.exc_info())` has no output best practice ref: Error codes vs exceptions: critical code vs typical code 如果你真的对可能出现的错误了如指掌，这时候采用error code；一般情况下，都要用exception，它使你很容易debug。 TIPS Raising exceptions when an exception is already present in Python 3 ipython 入门 “?” 帮助与显示信息 ?save 会给出save命令的用法、对象的签名 ??your_function 显示源代码 !pwd 加!执行shell command %hist %edit 使用编辑器打开 %save your_filename 1-30 conda minicoda # pip install conda # does not work! You have to download miniconda to use conda as package manager. 使用conda管理python环境 anaconda Anaconda使用总结 conda install scipy #安装scipy conda install --download-only ipython-notebook conda install --offline -f ***.tar.bz2 离线安装 conda list #列出已安装的包 环境 conda create -n env_name python=2.7 # create new env conda env list # list all env conda env export &gt; environment.yml # export to file source activate your_env_name # enter your env. source activate root # to switch back update python major version Search a lot by google and finally I just rf -rf ~/Anaconda and re-install it. What was said in stackoverflow: How do I upgrade to Python 3.6 with conda? is true. It’s very hard to update python major version in-place. upgrade pip in anaconda! pip install --upgrade your_package 此时pip会试图更细，并删掉老版本pip。 然而mac上更新pip是需要root权限的！这就导致老版本被删掉，而新版本没有被安装！ 解决：easy_install pip pip Usage：pip --help for more info install centos7下使用yum安装pip 首先安装epel扩展源： yum -y install epel-release 更新完成之后，就可安装pip： yum -y install python-pip 安装完成之后清除cache： yum clean all 更新 pip install --upgrade your_package error Could not fetch URL https://pypi.python.org/simple/pytest-cov/… 123 Could not fetch URL https://pypi.python.org/simple/pytest-cov/: There was a problem confirming the ssl certificate: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:600) - skipping Could not find a version that satisfies the requirement pytest-cov (from versions: )No matching distribution found for pytest-cov 解决： 1pip install --trusted-host pypi.python.org pytest-xdist My Snippet translate in one line: Translate word by word: [ your_dict[i] if i in your_dict else i for i in some_words ] string to number: commas as thousands separators 1234import localelocale.setlocale( locale.LC_ALL, 'en_US.UTF-8' ) locale.atoi('1,000,000')locale.atof('1,000,000.53') 工具 circleci2.0 python标准库列表 工程能力 OOP 工厂函数 见python核心编程：工厂函数看上去有点像函数，实质上他们是类，当你调用它们时，实际上是生成了该类型的一个实例，就像工厂生产货物一样. e.g., list(), set()就是工厂函数，输入Iterable对象，它们就会生产出list或set的实例。 关联，聚合，组合三者的异同[4] [5] 相同点：都是说两个类的关系，下面以class A和class B为例。 不同点：A和B之间的依赖程度不同 关联 聚合 组合 依赖程度 A可以没有BB可以没有A A可以没有B A不可以没有B 例子 B是A的朋友AB为关联关系 B是A的衬衫AB为聚合关系 B是A的心脏AB为组合关系 __init__ Some people may think setting all instance variables in the __init__ is cleaner. However, notice that setting a class attribute will make this attribute accessible in the class, even if you just want this attribute accessible to some method. So my point is instance and initialize variables unless you need it. TIPS UML(Unified Modeling Language)本身很少有应用了，但是提出的概念广为人知，并且很有用。 best practice my_return= my_funct(para=para)是可以的 上面左边的para是参数名，右边的是变量名，这样写是可以的，而且是明了的。 debug 要融汇的方法[3]： 回答先在本地重现的就算了吧……那么容易就能重现通常说明最基本的代码逻辑覆盖测试都没做好。相比起C/C++来说，动态语言还是比较幸福的，异常都有详细的堆栈，只要打印到日志里就行了，错误信息通常也比较明确。要点在于该打印的日志一点都不能少，严禁在出现异常的时候只打印错误信息而不打堆栈。但归根结底来说，发现和解决bug靠的是良好的程序结构，必要的defensive（关键函数的参数合法性校验等），自动化的测试流程，线上调试只是亡羊补牢。 test pytest比较好！从它入门 ！ unittest vs pytest vs nose Pytest vs Unittest vs Nose 【详细的对比】 待读！： Writing unit tests in Python: How do I start? Improve Your Python: Understanding Unit Testing python自动化测试 【先读】 最完整的自动化测试流程 TIPS unrar file with password in python? IT IS VERY HARD! STOP IT. Just run unrar x 001.rar -ppassword in shell! pyunpack + patool + unrar (sucks!) To unrar a file, you need install 2 python lib and 1 shell command(unrar). And it comes to an end that you can’t unrar files with password! python缺点 efficiency slow than java global lock, which makes multi-threads suck hard to distribution (compare to JAVA et al., python is dependent to package) easily decompiled workaround Encapsulate the whole program to a web service; compile by cpython? (I’m not sure how this works) 和其他语言的对比 ruby ruby最大的优势在于Ruby on Rails 我的经验 都说python有很多包、方便，然而包里有可能有很多坑（bug or bad practice），比如Pillow中遇到过**karg的滥用。这些特点使得python很容易开发原型，但很难构建稳定、高效、一致的大型应用。 有不少不符合直觉的&quot;feature&quot;[2] 例如： 1234567 &gt;&gt;&gt; a = ([1], [2]) &gt;&gt;&gt; a[0] += [3]Traceback (most recent call last): File "", line 1, in TypeError: 'tuple' object does not support item assignment &gt;&gt;&gt; a([1, 3], [2]) reference Python ↩ 有哪些明明是 bug，却被说成是 feature 的例子？ ↩ ↩ 老程序员解bug有那些通用套路？ ↩ ↩ ↩ N Randhawa’s answer ↩ 关联，聚合，组合 ↩]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python modules]]></title>
    <url>%2Fpython_modules%2F</url>
    <content type="text"><![CDATA[[TOC] Python features a dynamic type system and automatic memory management and supports multiple programming paradigms. module Python 正则表达式 re 模块 asyncio ref1: Python Async/Await入门指南 Note: asynchronous generators and asynchronous comprehensions is added until python3.6 Python中常见的四种函数形式： 普通函数 生成器函数 在3.5过后，我们可以使用async修饰将普通函数和生成器函数包装成异步函数和异步生成器。 异步函数（协程） 异步生成器 coroutine 直接调用异步函数不会返回结果，而是返回一个coroutine对象： 12print(async_function())# &lt;coroutine object async_function at 0x102ff67d8&gt; 协程需要通过其他方式来驱动，因此可以使用这个协程对象的send方法给协程发送一个值： print(async_function().send(None)) 不幸的是，如果通过上面的调用会抛出一个异常： StopIteration: 1 因为生成器/协程在正常返回退出时会抛出一个StopIteration异常，而原来的返回值会存放在StopIteration对象的value属性中，通过以下捕获可以获取协程真正的返回值： 12345def run(coroutine): try: coroutine.send(None) except StopIteration as e: return e.value await await: suspends the execution of the coroutine until the awaitable it takes completes and returns the result. await语法只能出现在通过async修饰的函数中，否则会报SyntaxError错误。 原理： await后面的对象需要是一个Awaitable，或者实现了相关的协议。 查看Awaitable抽象类的代码，表明了只要一个类实现了__await__方法，那么通过它构造出来的实例就是一个Awaitable： Coroutine类继承了Awaitable，而且实现了send，throw和close方法。所以await一个调用异步函数返回的协程对象是合法的。 For more details see ref1. event run_until_complete 123loop = asyncio.get_event_loop() ...loop.run_until_complete() # it's blocking (阻塞) Event loop is closed Jupyter的一个project就是一个进程，而一个进程中默认只有一个event。例如： 1234567 &gt;&gt;&gt; import asyncio &gt;&gt;&gt; asyncio.get_event_loop().close() &gt;&gt;&gt; asyncio.get_event_loop().is_closed()True &gt;&gt;&gt; asyncio.get_event_loop().run_until_complete(asyncio.sleep(1)).....RuntimeError: Event loop is closed event loop在asyncio中有复杂的机制，引用Flask作者著名的文章I don’t understand Python’s Asyncio On the surface it looks like each thread has one event loop but that’s not really how it works. if you are the main thread an event loop is created when you call asyncio.get_event_loop() if you are any other thread, a runtime error is raised from asyncio.get_event_loop() You can at any point asyncio.set_event_loop() to bind an event loop with the current thread. Such an event loop can be created with the asyncio.new_event_loop() function. Event loops can be used without being bound to the current thread. asyncio.get_event_loop() returns the thread bound event loop, it does not return the currently running event loop. 更详细的讨论请参见原文，总之这里有许多问题。 如果想避免之前的示例问题，参考在一段Python程序中使用多次事件循环一文，可以如下操作： 我们可以使用asyncio.new_event_loop函数建立一个新的事件循环，并使用asyncio.set_event_loop设置全局的事件循环，这时候就可以多次运行异步的事件循环了，不过最好保存默认的asyncio.get_event_loop并在事件循环结束的时候还原回去。 1234567891011121314import asyncioasync def doAsync(): await asyncio.sleep(0) #...def runEventLoop() loop = asyncio.new_event_loop() asyncio.set_event_loop(loop) loop.run_until_complete(doAsync()) loop.close()if __name__ == "__main__": oldloop = asyncio.get_event_loop() runEventLoop() runEventLoop() asyncio.set_event_loop(oldloop) gather ref: Getting values from functions that run as asyncio tasks 12345loop = asyncio.get_event_loop()tasks = func_normal(), func_infinite()a, b = loop.run_until_complete(asyncio.gather(*tasks))print("func_normal()=&#123;a&#125;, func_infinite()=&#123;b&#125;".format(**vars())) # 这段输出的代买没看懂loop.close() 另外，run_until_complete也会返回函数结果： 1234done, _ = loop.run_until_complete(asyncio.wait(tasks))for fut in done: print("return value is &#123;&#125;".format(fut.result()))loop.close() Tips asyncio.run() is added in python3.7 asyncio.sleep(1) 异步 I/O 里面的 sleep() 方法, 它也是一个协程, 异步 I/O 里面不能使用 time.sleep(), time.sleep() 会阻塞整个线程 RuntimeError: This event loop is already running problem This problem happens because: The kernel itself runs on an event loop, and as of Tornado 5.0, it’s using the asyncio event loop. So the asyncio event loop is always running in the kernel. Can’t invoke asyncio event_loop after tornado 5.0 update Solvation: pip3 install tornado==4.5.3 and restart notebook aiohttp ref: 异步爬虫: async/await 与 aiohttp的使用，以及例子 get 12async with aiohttp.get('https://github.com') as r: await r.text() timeout 123with aiohttp.Timeout(0.001): async with aiohttp.get('https://github.com') as r: await r.text() session session可以进行多项操作，比如post, get, put, head等等 12345678910async def getPage(url,res_list): headers = &#123;'User-Agent':'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'&#125; ### example of proxy and cookie # conn = aiohttp.ProxyConnector(proxy="http://127.0.0.1:8087") # session.get(url,headers=headers, connector=conn) # async with ClientSession(&#123;'cookies_are': 'working'&#125;) as session: async with aiohttp.ClientSession() as session: async with session.get(url,headers=headers) as resp: assert resp.status==200 res_list.append(await resp.text()) atexit ref: 深入理解python中的atexit模块 非常好的简介，如果需要进一步了解，可以参考。 atexit 模块介绍 python atexit 模块定义了一个 register 函数，用于在 python 解释器中注册一个退出函数，这个函数在解释器正常终止时自动执行,一般用来做一些资源清理的操作。 atexit 按注册的相反顺序执行这些函数; 例如注册A、B、C，在解释器终止时按顺序C，B，A运行。 Note：如果程序是非正常crash，或者通过os._exit()退出，注册的退出函数将不会被调用。 heapq (Heap queue algorithm) nlargest/nsmallest 123456789101112nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]heapq.nlargest(3, nums)# or more complicated:portfolio = [ &#123;'name': 'IBM', 'shares': 100, 'price': 91.1&#125;, &#123;'name': 'AAPL', 'shares': 50, 'price': 543.22&#125;, &#123;'name': 'FB', 'shares': 200, 'price': 21.09&#125;, &#123;'name': 'HPQ', 'shares': 35, 'price': 31.75&#125;, &#123;'name': 'YHOO', 'shares': 45, 'price': 16.35&#125;, &#123;'name': 'ACME', 'shares': 75, 'price': 115.65&#125;]cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price']) re module compile [Python Regex Flags] (http://xahlee.info/python/python_regex_flags.html) compile(r’[0-9]+’) Usage: 123import repattern = re.compile(r'[0-9]+')frist_number = pattern.match(your_str).group(0) another example 1234import remys = 'abe(ac)ad)'p1 = re.compile(r'[(](.*?)[)]', re.S) match_list = re.findall(p1, mys) # findall return a list of matched string other func replace(str1, str2) split() string 对象的 split() 方法只适应于非常简单的字符串分割情形， 它并不允许有多个分隔符或者是分隔符周围不确定的空格。 123 &gt;&gt;&gt; line = 'asdf fjdk; afed, fjek,asdf, foo' &gt;&gt;&gt; re.split(r'[;,\s]\s*', line)['asdf', 'fjdk', 'afed', 'fjek', 'asdf', 'foo'] 当你使用 re.split() 函数时候，需要特别注意的是正则表达式中是否包含一个括号捕获分组。 如果使用了捕获分组，那么被匹配的文本也将出现在结果列表中。 123 &gt;&gt;&gt; fields = re.split(r'(;|,|\s)\s*', line) &gt;&gt;&gt; fields['asdf', ' ', 'fjdk', ';', 'afed', ',', 'fjek', ',', 'asdf', ',', 'foo'] sys module sys.version/version_info(version_info is a object) os module 1. about path os.path模块 about path 12345os.getcwd()os.chdir('../')os.listdir()os.chdir('../')os.path.exist #determine if a file or dir exists os.remove remove a file; if file does not exists, an Error will be throwed out. os.rmdir remove a dir os.path.splitext(path) Split the pathname path into a pair (root, ext) os.path.basename(your_path) 2. os.popen shell cmd is executed in background and you can’t change it inplemented by subprocess.Popen, so why not you use subprocess? python doc time &amp; calendar Python 日期和时间 runoob ‘datetime’ object &amp; ‘timedelta’ object 1234 &gt;&gt;&gt; datetime.strptime("2018-11-28T19:57:01.522Z",FMT)datetime.datetime(2018, 11, 28, 19, 57, 1, 522000) &gt;&gt;&gt; datetime.strptime("2018-11-28T19:56:55.557Z",FMT) - datetime.strptime("2018-11-28T19:57:01.522Z",FMT)datetime.timedelta(-1, 86394, 35000) time.time() Return the current time in seconds since the Epoch. mktime(tupletime) localtime() Convert seconds since the Epoch to a time tuple expressing local time. When ‘seconds’ is not passed in, convert the current time instead. strftime() strftime(format[, tuple]) # -&gt; string strptime() strptime(string, format) # -&gt; struct_time Parse a string to a time tuple according to a format specification. time.sleep(secs) calendar.isleap(year) calendar.weekday(year,month,day) subprocess module python doc 1. For cmd that needn’t stdout subprocess.run(&quot;cp standard_py/*py .&quot;, shell=True, check=True) shell=True you can use a string instead of a series of args! check=True throw an Error if shell cmd exit wrong! 2. For cmd needing stdout An example: 12ret = subprocess.run("ls standard_py/*py", shell=True, check=True, universal_newlines=True, stdout=PIPE)print(ret.stdout, end="") universal_newlines=True stdout Captured stdout from the child process. A bytes sequence, or a string if run() was called with universal_newlines=True. None if stdout was not captured. stdout=PIPE without this argument, stdout will be printed as stdout of python script, instead of captured, as from python doc: This(ct: means run) does not capture stdout or stderr by default. To do so, pass PIPE for the stdout and/or stderr arguments. glob module The glob module finds all the pathnames matching a specified pattern glob.glob(pathname, *, recursive=False) glob.iglob(pathname, recursive=False) Return an iterator which yields the same values as glob() collections module 廖雪峰 Counter 12 &gt;&gt;&gt; Counter([1,2,2,2,2,3,3,3,4,4,4,4])Counter(&#123;1: 5, 2: 3, 3: 2&#125;) deque (double-ended queue, pronounced as ‘Deck’) doc: deque([iterable[, maxlen]]) method: pop(popleft) / append / extend; clear / copy (It’s shadow copy ) / insert / remove; count / index ; reverse / rotate python doc: OrderedDict This dict will record the insert order! And this is the only difference between OrderedDict and dict NOTE: OrderedDict may looks like a list of tuple, but it’s definitely not! 123import collectionsdic = collections.OrderedDict()dic['k1'] = 'v1' Standard Usage: 1234# dictionary sorted by keyOrderedDict(sorted(d.items(), key=lambda t: t[0]))# dictionary sorted by valueod = OrderedDict(sorted(mydict.items(), key=lambda t: t[1], reverse=True)) PIL img = Image.open(‘origin.png’) #支持多种格式 注意：类似于.htm和.html，.jpg和.jpeg没有区别，只是两种写法 font font = ImageFont.truetype(&quot;FreeMono.ttf&quot;, 28, encoding=&quot;unic&quot;) img2.save('./test_image_data/cat_001_blur.jpeg','jpeg') #save(‘path’,‘format’) resize()、rotate()、convert(mode=‘your_mode’) Coordinates (0, 0) in the upper left corner. draw = ImageDraw.Draw(img) 123#img is from:#img = Image.open(&apos;./test_image_data/cat_001.jpg&apos;)draw.text((width - add_width, 0), number, font=font, fill=fillcolor) # first parameter is the start point of the draw random doc random.seed(a=None, version=2) functions for integers random.randrange(start, stop[, step]) random.randint(a, b) return a random integer N such that a &lt;= N &lt;= b. Alias for randrange(a, b+1). real-valued distributions random.random() Return the next random floating point number in the range [0.0, 1.0). random.uniform(a, b) random.gauss(mu, sigma) shutil The shutil module offers a number of high-level operations on files and collections of files. In particular, functions are provided which support file copying and removal. shutil.copyfile(src, dst) logging[1] [2] A sample example:[2] 123import logginglogging.warning('Watch out!') # will print a message to the consolelogging.info('I told you so') # will not print anything result is : WARNING:root:Watch out! Used in program: 1234567891011import logginglogger = logging.getLogger()handler = logging.StreamHandler()formatter = logging.Formatter( &apos;%(asctime)s %(name)-12s %(levelname)-8s %(message)s&apos;)handler.setFormatter(formatter)logger.addHandler(handler)logger.setLevel(logging.DEBUG)logger.debug(&apos;often makes a very good meal of %s&apos;, &apos;visiting tourists&apos;) logging.warn() vs. logging.warning() logging.warning() just logs something at the WARNING level, while logging.warn will raise an exception. ref: Python warnings.warn() vs. logging.warning() filter 一般都是用继承logging.Filter类的方法，再写filter method。 官方说3.2版本之后，用个函数就可以作为filter，但是没有示例程序。 functools wraps ref: What does functools.wraps do? 普通decorator，会导致被修改的函数的属性产生变化（比如func_1，加decorator后，名字会被修改）。 1234567from functools import wrapsdef logged(func): @wraps(func) # 只比正常的闭包多了这一句 def with_logging(*args, **kwargs): print func.__name__ + " was called" return func(*args, **kwargs) return with_logging 简而言之：decorator都需要functools.wraps pickle pickle.load是从file-like object中导入数据；对应的，pickle.dump也是针对file-like object。[3] TIPS 一个存有bs4.element.Tag类型的对象，并不一定能pickle。 因为pickle要求数据可以遍历，而bs4.element.Tag类型的对象可能有环？或者单纯是我的数据中，bs4.element.Tag类型的数量太多了？ BeautifulSoup4 beautifulsoup4 文档 find_all(text=&quot;your_text&quot;)不好用！ ‘html5lib’ engine is slower but more robust than ‘lxml’！ soup.prettify() and &lt;tag&gt;.prettify() Formatting html 四大对象种类[4] Tag: 通俗点讲就是 HTML 中的一个个标签 如何抓取超链接？ 因为超链接不是显示存储的。要想得到超链接的字符串，需要下面的操作： 12if isinstance(i, bs4.element.Tag) and i.has_attr('href'): con_str.append(i['href'] ) NavigableString: print(type(soup.p.string)), that’s it. BeautifulSoup: 一个文档的全部内容.大部分时候可以把它当作是一个特殊的 Tag Comment: 注释 Selenium initialize 12chromePath = r'/usr/local/bin/chromedriver'wd = webdriver.Chrome(executable_path= chromePath) usage 123wd.find_element_by_id('login_pwd')wd.find_element_by_class_name('radiocheck').click()wd.find_element_by_xpath('//*[@id="sendpck"]/img') NOTE: 1. you can search an element and then click() 2. you can get xpath in source code page. login website Please refer to login fucntion in download_voice.ipynb TIPS 断网 有时候断网后，selenium就一直无法重新连接，尽管你在浏览器中手动访问网站是可以的。 这时可以手动刷新一下selenium要访问的页面，问题可能就解决了。 我猜，这可能是因为selenium保留了上次访问的失败状态，这导致重新链接到网络后，selenium仍然无法正常工作。 reference THe hitchhiker’s guide to python ↩ Official Logging How to ↩ ↩ about pickle ↩ Beautiful Soup 的用法 ↩]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vmd笔记]]></title>
    <url>%2Fvmd%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[什么是VMD？[1] VMD is a molecular visualization program for displaying, animating, and analyzing large biomolecular systems using 3-D graphics and built-in scripting. VMD官网的图片示例展览 本文定位：本文不适合作为入门教程，适合于在进阶阶段作为参考。本文偏重于VMD脚本；图形界面(GUI)上的操作因为比较简单，讨论的较少。 显示 console中，输入命令且不加参数，就会显示帮助信息 tcl语言作为脚本语言，tcl语法可以参考TCL脚本入门教程【当然没必要学完】 如何进入console：Extension -&gt; Tk Console 例子： console% measure结果见图 console% mol pbc… pbc pbc是周期性边界条件的缩写（periodic boundary condition） pbc wrap -all 【将粒子折回盒子内】 pbc wrap -shiftcenterrel {-0.5 -0.5 -0.5} 我们希望wrap后坐标的中心在{0 0 0}处，然而，默认情况下，wrap的中心在{L/2 L/2 L/2}处，所以我们要将其平移回来！ pbc set {1308.998 1278.998 1281.998} -all：手动定义盒子 画盒子 pbc box -on 【画出盒子】 pbc box -center origin 【设定盒子中心的位置为{0 0 0}，而默认的盒子{0 0 0}点在盒子角上】 pbc box -center origin -style tubes -width 1 -color gray pbc join res -border 5 【接上由于pbc导致的盒子边界处的断键】 display display projection orthographic 【相当于在display选项卡中选择orthographic】 display distance x 设置东西与屏幕的距离，越大则分子离屏幕越近，相当于放大。不可太小比如几十，否则有凸镜的效果 背景设置为白色 （Graphics-&gt;Colors-&gt;Categories栏-&gt;选Display-&gt;再在name栏选Background）时，图像会显得比较浅。修正这个问题的方法是：去掉Display-&gt;Depth Cueing graphics graphics top list【to show a list of number, standing for the ID of each object】 graphics top text {40 0 20} “my drawing objects” # 文字 graphics top info ID # The detailed information about each object graphics top delete ID box is also considered as graphics in VMD draw shapes【画图形】[2] graphics top color COLORID【先设定颜色后画图形才能设定成功】【colorid for each color can be found in Graphics -&gt; Colors -&gt; menu 】 graphics top sphere {10 10 10} radius 10 resolution 80 graphics top line {10 0 0} {0 0 0} width 5 style dashed graphics top material transparent graphics top delete all/ID【delete shapes】 NOTE: vmd看gromacs文件（*.gro）时，会把单位自动换位埃，比如在.gro文件中，坐标为1，则vmd中坐标为10，画图形时，可能会用到 colorinfo colors 显示有多少种预置颜色，比如red 旋转 rotate x by/to 90 Script 基本命令 ~/.vmdrc ： 配置文件 logfile my.log 在console中输入此命令,可以将你在图形界面中的操作保存成脚本，存储在my.log中 有用又简单的命令 !!! console中导入脚本 source yourscript.tcl 不显示图形界面的执行脚本 sh$ vmd -dispdev none -e script.tcl 需要注意到的是，使用-dispdev none选项后，用pbc命令的脚本回报错： invalid command name &quot;pbc&quot; 在脚本中添加下列命令即可解决该错误： package require pbctools mol mol的用法帮助：如前面第0节所述，在console中输入mol并且不加参数，就会显示mol的用法。 这里要介绍VMD中两个重要的概念：molid（molecular ID）和repid（representation ID）。 molid：对单个frame，molid恒等于0 repid：打开一个frame，默认的repid为0 如果你想添加第二种呈现方式（representation），可以用：mol addrep 0向molid为0的图中，新增一种representation，这一representation的repid等于之前最大的repid+1。 GUI中，Graphics -&gt; Representations -&gt; Create Rep 就相当于下列命令： 12mol addrep 0mol modselect 1 0 "type 1" 注意：写脚本时，尤其要注意的一点是如果打开一个frame成功，会隐式的执行一次mol addrep 0！ 例如，我们将类型为A的原子显示成蓝色（ColorID 0）、将B类型的原子显示成红色（ColorID 1），脚本这样写： 123456789# mol addrep 0 # NOTE: VMD has execute this statement invisibly. If # you add this "mol addrep 0" manually, there will # be an error. mol modselect 0 0 "type A"mol modcolor 0 0 ColorID 0mol addrep 0# now there are two "rep". The index of second "rep" is 1.mol modselect 1 0 "type B"mol modcolor 0 0 ColorID 0 mol default style {CPK} 【相当于Graphical选项卡中选择Representations,再在Draw style中Drawing Method下选择CPK】 mol default material {Diffuse} 【相当于Graphical选项卡中选择Representations,再在Draw style中Material下选择Diffuse】 mol list 列出目前所有representation mol delrep 3 0 与mol addrep 0相对，删除molid=0，repid=3的mol molinfo list/num 显示全部分子的molid atomselect 例子： 1234567set particle [atomselect 0 "index&lt;13000"]$particle set resname CD #默认是空$particle set chain X$particle set resid 1 #默认是0$particle set radius 0.6$particle num # 输出particle中原子个数$particle delete atomselect有单独的编号 比如atomselect345，我们可以用编号atomselect345来调用它;它的各种信息都可以输出出来。 atomselect macro macro指的就是那些charged、acidic、amino之类的，比如atomselect charged会选择体系中带电荷的原子。蛋白质体系容易用到，聚合物体系不容易用到。 atomselect macro 显示所有macro atomselect keywords atomselect 3 &quot;resid 25&quot; frame last 选择molid为3、最后一帧的resid 25。molid可以是数字或者top，所选内容就是普通的selection，用双引号或者{}括住，帧号可以是数字、first、last、now。 atomselect list会列出所有的atomselect index 除了上文中set particle [atomselect 0 &quot;index&lt;13000&quot;]的筛选方法，index选择原子时还支持多种筛选方式： “(index&gt;100 &amp;&amp; index&lt;200) || index = 66” “index 1 3 5” &quot;index = [ expr 250 * $i ]&quot; # index 支持expr表达式求值，i为自定义变量 Script Syntax[3] 0. 注释 TCL中的注释符是’＃’，’＃’和直到所在行结尾的所有字符都被TCL看作注释，TCL解释器对注释将不作任何处理。不过，要注意的是，’＃’必须出现在TCL解释器期望命令的第一个字符出现的地方，才被当作注释。 例如： %＃This is a comment %set a 100 # Not a comment %set b 101 ; # this is a comment 1. for语句 12for &#123;set i 0&#125; &#123;$i &lt; [llength $list]&#125; &#123;incr i&#125; 2. list set list { Opaque Transparent ... } [llength $list] # get index [lindex $list $i] # reference the list 3. measure measure的功能非常多，从相对简单的求质心、几何中心、均方回转半径、RDF（vmd中叫gofr）、rmsd和rmsf(RMS fluctuation)，到比较专业的氢键分析、sasa（solvent-accessible surface area）等。 全部功能见图：https://res.cloudinary.com/do7yb5qw4/image/upload/v1506587376/杂/vmd_measure.jpg measure center $sel measure minmax $sel measure bond { index_1 index_2} GUI下 Mouse &gt; Label &gt; Bonds， 或是在激活3D 窗口的条件下按2 鼠标形状会变成+，然后依次点击2个原子即可， Graphics &gt; Label 可以进行更多的操作 4. xyz(coordinate) is storaged as list! When you get multiple atom attributes (in this case, x, y, and z), the result is always returned as a nested list, even if that list contains only one element. As somebody may think the code below is very intuitive: 12set sel [atomselect 0 "index = 250"]graphics top text [ $sel get &#123;x y z&#125; ] "words i want to say" However, $sel get {x y z} ] is actually a list, but there need a vector. It’s like you give： 1graphics top text &#123; &#123;1 2 3&#125; &#125; "words i want to say" But actually we need: 1graphics top text &#123;1 2 3&#125; "words i want to say" The solution is ugly: 123foreach coor [ $sel get &#123;x y z&#125; ] &#123; graphics top text $coor "words i want to say"&#125; Beside that, coordiante should be used like below: graphics top text [list $x $y $z] &quot;words i want to say&quot; source: vmd mailing list 5. get one coor of three(only one element in pxyz) 12set pxyz [atomselect top "index = [ expr 250 * $i ]" ]set px [$pxyz get x] vmd传参数 vmd本身是一个csh脚本! [lindex $argv 0] vmd -e yourscript.tcl -args your_first_arg env YOUR_ARG=&quot;ba la ba la&quot; vmd -e yourscript.tcl http://www.ks.uiuc.edu/Research/vmd/mailing_list/vmd-l/7839.html 存高质量图片[4] render TachyonInternal name.tga convert name.tga name.png 这样得到的图片效果有限 尝试了各种方法，似乎tga转换png的质量不能控制 要想得到高质量的图片，方法如下 File-&gt;render(这里有三行) (第一行选择)Tachyon (第三行加上，设置分辨率) -res 1024 1024 res代表resolution，设为1024*1024时，tga大小为3.1M，png大小为680K 最后convert vmdscene.tga vmdscene.png（转成jpg格式也可以） ambient occlusion（AO,环境光遮蔽）效果会很好 script: render Tachyon vmdscene.dat “/usr/local/lib/vmd/tachyon_LINUXAMD64” -aasamples 12 %s -format TARGA -res 1024 1024 -o %s.tga culling culling actually reduces performance on some hardware renderers[5] Depth Cueing Depth cueing causes distant objects to blend into the background color, in order to aid in 3-D depth perception 存动画 （1）进入 Extensions -&gt; Visualization -&gt; Movie Maker （2）Render -&gt; Tachyon （3）Movie Settings -&gt; Trajectory （4）Format -&gt; Animated GIF color scale【颜色梯度】 trajectory with color gradient load a trajectory 设置颜色随frame变化 Graphical -&gt; Representations -&gt; Draw style -&gt; Coloring method -&gt; Timestep Graphical -&gt; Representations -&gt; Trajectory -&gt; 选择&quot;update color every frame&quot;; 修改&quot;Color Scale Data Range&quot; 设置Color Scale Bar Extensions -&gt; Visuilizition -&gt; Color Scale Bar 选择颜色 Graphical -&gt; Colors -&gt; Color Scale -&gt; 这个设置还可以以&quot;RWB(Read Whie Blue) Offset -0.09, Midpoint 0.5 &quot; frame with color gradient load a frame 设置颜色随index变化 Graphical -&gt; Representations -&gt; Draw style -&gt; Coloring method -&gt; index Graphical -&gt; Representations -&gt; Trajectory -&gt; “Color Scale Data Range 0 ~ total_monomer_number” 设置Color Scale Bar和选择颜色与上面&quot;trajectory with color gradient&quot;相同 其他 compound（似乎没什么用） 只用于pbc中 supported compound types: segment, residue, chain, fragment, connected 问题 pbc join pbc join res -border 5 -sel “resname 0&quot;好使，但不明白为什么？ 但是注意，resname一个不存在的名字，比如&quot;resname 1000000”，也不会报错。 pbc join res -sel尝试了各种办法也没有成功 最后解决：还是在xml文件中删除多余的bond和angle，就是join的时候很慢，要等很久。 vmd有很多功能，如： VMD extensions: membrane builder Molecular Surface Representations 对vmd脚本的感觉 优点：vmd本身功能非常多，使用者多。 缺点：以tcl为基础的vmd脚本，坑很多，体现了很多动态弱类型语言的缺点。 reference VMD官网 ↩ VMD Tutorial ↩ VMD Tutorial: Scripting in VMD ↩ 非常好的效果的vmd作图 NOTE：该CBMSG网站还有很多有用的教程和资源（Computational Biophysics and Materials Science Group） ↩ manual culling ↩]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>画图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何快速的向Word格式的硕士/博士论文中，添加引用文献？]]></title>
    <url>%2FWord%E6%A0%BC%E5%BC%8F%E8%AE%BA%E6%96%87%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[通常，很多理工科硕士/博士的毕业论文，是将自己Paper翻译成汉语再稍作组织而写成的。由于论文要求是Word格式的，重新向Word中添加引用文献是一项繁琐的工作。这里我介绍一种方法，利用Latex写Paper时准备的bib文件，向Word中添加引用文献。该方法有几个好处: 几乎所有文献引用在.bib文件中都是现成的，不用再重新下载引用 latex中采用的bibtex key（“@article{paper_name,”中paper_name即为bibtex key）可以直接用到Word中。 不用跳转到EndNote等其他软件 必要软件bibtex4word的安装请参考： 用Bibtex4Word实现Word写作时参考文献的插入和排版 多数高校一般都要求采用《GB/T 7714-2005 文后参考文献著录规则》作为毕业论文的引文规则，上面连接中给出的下载已经不可用了，戳这里可以找到下载 至此，软件的准备工作就完成了。我们将我们几篇Paper中用到的.bib文件合并到一起（如果有少量重复的引用，手动删除就可以；重复引用较多的话，可以用bib文件管理软件删除，比如我用的JabRef），就可以愉快的插入文献啦。插入方法很简单，见Bibtex4Word的介绍。]]></content>
      <categories>
        <category>技术杂烩</category>
      </categories>
      <tags>
        <tag>office</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[专利申请]]></title>
    <url>%2F%E7%94%B3%E8%AF%B7%E4%B8%93%E5%88%A9%2F</url>
    <content type="text"><![CDATA[之前想把研究结果申请成专利(化工领域)，所以做了下列功课，在此分享给有相同需求的人。 在拿到专利申请号之前，相关论文是不能被公开发表的。而我们正好着急发论文，所以特意问了加急申请的费用和拿到专利号的时间。 申请专利的顺序 准备好纸面材料 一般长度为几页，需要介绍清楚相关的技术，让专利代理明白。 专利代理进行撰写 就算你选择加急，也需要至少一周时间。如果时间太短，可能会有写出来的文书的效果不好、专利保护范围不广等问题。 提交申请 材料都准备好之后，一到两天就能拿到专利申请号。 专利方面律师事务所 来源：中国在知识产权服务行业有哪些著名的公司？ 第一集团 柳沈律师事务所 2万包杆（包含全部费用），一个月内，加3000半个月。该律师建议我们可以先投文章，因为文章不可能在一个月之内发表的，另外拿到专利号的时间可以写在合同内。 联系方式：010-62681616 中国国际贸易促进委员会专利商标事务所 正常1.8万包杆，30个工作日，11-15工作日10%加急费，6-10工作日20%加急费。 联系方式：010-66046763 中国专利代理（香港）有限公司 香港公司，没有联系 第二集团 中科专利商标代理有限责任公司 给底稿到拿到申请号，需要一周时间，拿到专利号的时间可以写在合同内。价格为8000-10000(应该不是包杆，只是申请费，不包括官费等)。 联系方式：010-68619696 中原信达知识产权代理有限责任公司 10天，包杆一万八到一万九 联系方式：010-66576688 金杜 只做公司和机构 中咨 联系方式：010-66091188 至少15天。申请费120000，官费900高校优惠到300 另外费用2450高校优惠到700]]></content>
      <categories>
        <category>技术杂烩</category>
      </categories>
      <tags>
        <tag>专利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gnuplot笔记（下）]]></title>
    <url>%2Fgnuplot%E7%AC%94%E8%AE%B0%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[gnuplot笔记下半部分。 [TOC] gnuplot命令 1. terminal gnuplot可以将画出的结果输出到不同terminal中。所谓terminal，既可以是png、eps等图片格式，也可以是x11、qt等窗口格式。 x11 支持像素大小 set terminal x11 enhanced lw 3.0 dashlength 5.0 size 1080,755 可以使用interactive脚本 set terminal x11 font &quot;Helvetica,45&quot; 加上font后，就不能使用了 eps 不支持支持像素大小 eps默认是以inch为单位，默认大小是10,6；我的图因为还要放大1.8倍，所以是18,10.8 All PostScript printers or viewers should know about the standard set of Adobe fonts Times-Roman, Helvetica, Courier, and Symbol. eps ps、eps格式不支持transparent，png支持 eps不支持transparent ps、eps格式不支持transparent，可以用png格式。 2. 数据筛选/处理 2.1. awk等预处理 下面两条命令是等价的 plot 't1.dat' p '&lt; cat t1.dat' 我用过 p &quot;&lt;awk '{if(NR&gt;13) print}' q.log&quot; 2.2. pi（pointinterval） for linespoints plot 只用于linespoints plot。决定点的symbol的稀疏，用法例子：pi 2，“means that point symbols are drawn only for every Nth point” 2.3. every 注意every不能简写成e 5个冒号，最后一个数字之后的冒号必须要省略 正确写法是： p 'PS500_26w_1/msd-PS_1.dat'every 10::::90000 w l 而不是： p 'PS500_26w_1/msd-PS_1.dat'every 10::::90000: w l 意思是每10个数据点画一个，一共画到第九万个点 具体参看gnuplot5.0.1 P85或help every 2.4. index( column(-2) ) 用于一个文件中多块数据stackoverflow &quot;p = 0.1&quot; 1 1 3 3 4 1 &quot;p = 0.2&quot; 1 3 2 2 5 2 12plot &apos;test.dat&apos; i 0 u 1:2 w lines title columnheader(1),\ &apos;test.dat&apos; i 1 u 1:2 w lines title columnheader(1) 需要注意的是光用空格来分割两个data block是不够的。 column(-2)是Pseudocolumns，可以在manual中搜索是Pseudocolumns。 3. 保存交互模式下的命令为脚本 12gnuplot&gt; save &apos;name.plt&apos;gnuplot&gt; load &apos;name.plt&apos; 4. 函数及设置定义域 123g(x)=3*x**2 # 普通函数f(x,min,max)=( (x&gt;min &amp;&amp; x&lt;max) ? (3*x**2) : 1/0 ) # 定义一个带定义域的函数p f(x,1,100) w l # 在[1,100]的定义域内，画出3*x**2 f(x,min,max)=( (x&gt;min &amp;&amp; x&lt;max) ? (3*x**2) : 1/0 )的解释： min，max只是自定义的变量，? :是经典三元表达式，1/0在gnuplot中不会被画出。综合起来f(x,min,max)的定义相当于：如果(x&gt;min &amp;&amp; x&lt;max)，就画出3*x**2，否则不画。 这里用到的几个技巧很有用，不光可以用来定义域。 5. 自带函数 log() &amp; log10() exp sin()等三角函数 gamma() 6. fit 自变量要设定成x、y等，如f(x)=exp(-(x/tau)**beta)，因为gnuplot似乎对变量名敏感 fit范围 12f(x)=a*x**bfit [0:300] f(x) &apos;msd.dat&apos;u 1:5 via a,b 7. 传入参数到脚本 命令行（CLI）下， 1gnuplot -c script.plt hehestr1 str2 str3 “script.plt” 就是ARG0，以此类推&quot;hehestr1&quot;就是ARG1… 8. how to set the config file? show loadpath will show where the configuration file locate at gerenal configuration is in app-defaults dir. e.g., write set loadpath 'your_path' into .gnuplotrc will avoid every time work. 9. smooth csplines 可以解决由于点多画不出虚线的问题 少用的命令 Interactive label placing parametric mode 1234set parametricset trange [-pi:pi]plot sin(t),cos(t)unset parametric MOUSE_BUTTON 点左键 MOUSE_BUTTON==1； 中键 ==2； 右键 ==3; 光点击的话，其他三个自带变量（MOUSE_SHIFT,MOUSE_ALT,MOUSE_CTRL）==0 显示信息型命令 1. show show variables show all 2. history history 5 #显示最近5条命令 history ?load #显示所有以load开头的命令 history ?&quot;set label&quot; #显示所有以set label开头的命令 history !&quot;set label&quot; #执行所有以set label开头的命令 3. test test可以展示当前terminal或palette的画图效果 test (terminal | palette) 123gnuplot&gt; help test This command graphically tests or presents terminal and palette capabilities. ... x11 test test x11 eps test png test 各种plot multiplot 1234567891011 set size 3,1.5 set multiplot #set the parameter of 1st subfigure set origin 0,0 set size 1.5,1,5 p ......#set the parameter of 2nd subfigure set origin 1.5,0 set size 1.5,1,5 p ...... 对齐subfig 用set lmargin 进行对齐 调整所有subfig的scale大小 set tics scale 3 取消前面的设置 因为后面的subfig会继承前面subfig的设置，有时候需要取消前面的设置。 时常需要取消的有：label, arrow, scale等。 最常用的取消方式是unset 对于key–set key default 对于tics– set xtics autofreq 3D plot view view用来设定3d图的观察角度 set view &lt;rot_x&gt;, &lt;rot_z&gt; 默认值是： set view 60, 30 设置Z轴起点 set xyplane at 0.6 设置背景网格 set grid x y z back 自定义渐变色 set palette define (0.6 &quot;#FF0000&quot;,1.1 &quot;blue&quot;) External Link using gnuplot Plot functions using the special-filenames property colorbox 自定义colorbox： set colorbox vertical user origin 1.1,0.5 size .06,.4 设定colorbox的tics： set cbtics 0.1 set logscale cb set cbrange [0.001:1] filled curve plot 'silver.dat' u 1:2:3 w filledcu time series To plot data in time series, you need several special sets. From manual5.1 Xtics timedata In case of timeseries data, axis tic position values must be given as quoted dates or times according to the formattimefmt. If the , , form is used,andmust be given according to timefmt, but must be in seconds. Times will be written out according to the format given on set format, however. Example: 12345678set xdata timeset timefmt &apos;%Y-%m-%d&apos;set datafile separator &quot;,&quot; # data is from &quot;.csv&quot; fileset xrange [&quot;2012-06-01&quot;:]set format x &quot;%m\n%y&quot;set xtics 604800*26 #604800 is the number of second in a weekset xlabel &quot;month\nyear&quot; User-defined function auto name 12345# convert incoming parameter &quot;ARG1&quot; to eps name automatically.# e.g., if &quot;ARG1&quot; is &quot;price.plt&quot;, then automatic name is &quot;price.eps&quot; name_length=strlen(ARG1)-4 name=ARG1[:name_length] set output name.&quot;.eps&quot; save as eps with specific format 1234set size 1.8,1.8set termoption dashset terminal postscript eps enhanced color lw 4.0 dashlength 8.0 &quot;Helvetica,45&quot;call &quot;auto-eps-name.gnu&quot; ARG1 Add call &quot;size1.8-font45-lw4-eps.gnu&quot; ARG0 to your gnuplot script and that’s it! Error &amp; 问题： 输出文件的大小为0——解决方法： The eps file doesn’t get written until a plot command is specified after specifing the output. Possible solutions: Move your plot command after your set output command add a replot command to the end of your script Reference An amazing web: gnuplotting.org]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>画图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gnuplot笔记（上）]]></title>
    <url>%2Fgnuplot%E7%AC%94%E8%AE%B0%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[gnuplot笔记，包含中高级使用方法，方便入门之后的进阶学习。 [TOC] Note about Version 5 1. dashtype需要单独设置 与4.x版本不同，现在linetype画出的都是实线了。 例子：p sin(x) dt 2 #设为2型虚线 2. size的用法 eps to png when eps size is set to 1.0,1.0，png的像素为600,420 eps：size 1.8,1.8 那么png的像素为1080,755 x11 set terminal x11 size 600,420应该是默认大小 size 2,2 会导致图像超过窗口大小 3. 新加入几个命令 plot ... smooth mcsplines plot &lt;datafile&gt; skip N # skip lines at start of ascii data file set colorsequence default|classic|podo # colors used by successive plot elements 4. 变量的引用 For 4.6: 12var=123set label 1 &apos;var&apos; at 1,1 For 5.0: 12var=123set label 1 var at 1,1 format 1. set logscale y set logscale # x和y轴都设置成logscale 2. set format 设置坐标轴上数字的格式。 以1000为例： set format x &quot;10^{%L}&quot; 显示出来的格式为10^3 set format x &quot;%2.0t{\327}10^{%T}&quot; 显示为1×10^3 需要注意的是： {\327}是乘号，需要将编码指定为set encoding iso_8859_1才可以使用 %t与%T 比如1200, %t=1.2 %T=3。这种写法可以方便的描线性标度下的较大的刻度。 3. offset x,y 设置label到坐标轴的距离， 0,0 是默认距离 e.g. set xlabel &quot;123&quot; offset 1,0 4. set ticscale n m Command set ticscale n m changes the length (size) of tics. The major tics are multiplied by the provided value n, while the minor tics are multiplied by m. 只改major tics:set tic scale 2 5. 字体font: (1) gnuplot-5.0.1 manual: All PostScript printers or viewers should know about the standard set of Adobe fonts Times-Roman, Helvetica, Courier, and Symbol. 注意：TimesNewRoman和Times（又称TimesRoman）是几乎一样的 (2) TimesRoman和TimesNewRoman都是一样的 For other fonts, 尽管程序不会报错，但也显示不出来 但是可以加粗/斜体 （可以参看http://www.manpagez.com/info/gnuplot/gnuplot-4.4.0/gnuplot_390.php） 6. tc (textcolor) 7. border set border lw 3 只改变线的宽度 8. key set key height #调节key与坐标轴的距离 set key spacing 1.3 #调节两行之间的距离 set key maxcols/maxrow set key autotitle 9. label 设定位置时候，是设定的左下角的坐标 用法：·set label 1 ‘20%wt’ at graph 0.42,0.92 font ‘,50’· 10. arrow 控制起始/终止位置 set arrow from 坐标 to 坐标 e.g.: set arrow from 9.5,3.8 to 9.5,1.8 nohead lt 5 lc rgb &quot;black&quot; set arrow 1 from (log10(50000)),-1 to (log10(50000)),2 nohead lt 5 lc rgb &quot;black&quot; &quot;arrow 1&quot;中&quot;1&quot;是一个标记数组，方便arrow的管理，比如unset arrow 1就取消arrow 1。 控制head e.g.: set arrow from -4,-4 to 4,-4 head filled size screen 1,30,55 lw 2 lt 2 lc rgb &quot;cyan&quot; 其中head filled size 1,30,55 为控制head的格式。 size &lt;length&gt;,&lt;angle&gt;{,&lt;backangle&gt;} length是长度,加上screen是代表屏幕长度，也就是相对长度；后面两个是箭头与线的角度 11. lmargin rmargin tmargin bmargin(左右上下) 以lmargin为例，lmargin是左侧坐标轴到图左边边界的距离 style：颜色、形状等与审美相关的设置 1. line and point types gnuplot-line-and-point-types 2. most useful point type shape full id empty id square 5 64 sphere 7 65 up-tri 9 66 down-tri 11 67 diamond 13 68 pentagon 15 69 e.g.: p sin(x) w p pt 5 3. 点的颜色的设置方法： lc rgb &quot;red&quot;，或者ls 1也可以！ 4. several color set DSL(domain-specific language) in DSL 有时候一个图里可能有一次画10条线，如果一条一条的画太麻烦了。为此gnuplot内置了自己的DSL。包括循环、逻辑等语句。 0. for、字符串数组 for循环： p for [i = 1:9] sample.i.'.dat' u 1:2 w l ls i t 'p='.i #一次画九条先，每条线有不同的title和linesytle（sytle是自己定义的） 字符串数组 `a=&quot;2 3 4 6 8 9 12 16 24&quot; a被当成字符串数组,word(a,n)是字符串类型。整数可以除字符串，例如864/word(a,1)。sprintf内的变量也可以用864/word(a,1)。 **.**点：字符串连接操作符，只能用于处理字符串和变量，不能处理表达式！！！ 注意：sprintf与C++的sprintf一样，百分号的转义字符是%%。 总结：字符串和文件名都用sprinf；无论是字符类型还是数字类型，都可以用在ls，column这些地方，并且可以进行数学运算。例子可见Paper3_segMSD.plt 1. escape charactor In postscript eps enhanced terminal, use &quot;\\&quot; before an escape charactor to keep its basic form, e.g. , &quot;\\_&quot; representation &quot;_&quot;. 2.各种字符的表达方式，可以google “Syntax for postscript enhanced option” （0）例子：set terminal postscript eps enhanced color lw 3.0 dashlength 3.0 &quot;TimsRoman,50&quot; （1）PostScript Character Codes的模式是T模式；输入&quot;set encoding&quot;后是E模式 （2）希腊字母写法的例子：{/Symbol r} （3）上下标同时出现：t@^{\*}_{p}，多用了一个@字符 3. string 单引号内的字符串不转义，双引号内的字符串转义 set title noenhanced #让title的内容直接输出，不进行转义 “.”, “eq” and “ne&quot; Three binary operators require string operands: the string concatenation operator”.&quot;, the string equality operator&quot;eq&quot;and the string inequality operator&quot;ne&quot;. The following example will print TRUE. if (&quot;A&quot;.&quot;B&quot; eq &quot;AB&quot;) print &quot;TRUE&quot; 4.print &quot;hello world!&quot;]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>画图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim笔记]]></title>
    <url>%2Fvim%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[记录用过的命令，方便以后查找。不包含太简单的或太难的。 删除线代表已经非常熟练的掌握，不需要再看了。 vim下命令： (3) :.,$ s/str1/str2/g 用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1 其中.代表当前行，$代表最后一行，而.,$就代表从当前行到最后一行 也可以这样 :.,.+8 s/str1/str2/g， 其中.,.+8代表从当前行到从当前行开始下面第8行。 例如：如果当前行是第二行，那么:.,.+8 s/str1/str2/g等价于:2,10 s/str1/str2/g (4) s/\(love\)able/\1er/ # 会将loveable替换成lover，\1代表第一对小括号内的匹配项 (6) 读入文件 :23r input_file，在当前文件23行将input_file的内容插入近来 (7) &lt;leader&gt; is backlash (8) “+y 复制到系统剪贴板 (11) Vu(VU) # V mode下，大小写转换 (14) vim中的g(global)和%的区别： g:全局的 s/pattern/replacement/ : 替换行中出现的每一个pattern g/pattern/s/pattern/replacement/g : 开始处的g是全局命令，意味着对所有与地址匹配的行进行改变。结尾处的g是一个标志，意味着改变一行上的每个。 linux中的grep = g/rep/p %:代表这文件本身每一行 (15) 全部格式化: gg=G (16) vi如何关闭打开的多个文件中的一个? 切换到你想关闭的 文件窗口. 然后输入 :bd 即 : buffers delete 就可以关闭了. (17) 两条命令合在一起用 :%s/abc/def/ | wq (18) gd 全局搜索当前名字第一次出现的地方 移动 zz 光标所在行居中 20| 到第20列！【Normal mode】 多个文件同时处理 文件以tab打开 12:args *.c:tab all or vim -p *.h *cc Run a command in multiple buffers 将所有文件进行格式化，并写入所有文件 12:tabdo Autoformat:wa 替换、查找 去掉换行符^M: 输入以下字符串: %s/^M//g (注意，^M = Ctrl v + Ctrl m，而不是手动输入^M) 换行符可以用\n直接匹配，用\r添加 对文件内含有特定字符的行操作。 g/-/s/^/#/ 是把所有含‘-’的行注释掉 /open\c 其中 \c表示忽略大小写 vi（lzy0xa@192.9.207.102）的正则表达式中H[1-9]*并不能match H20 ,因为这里vi认为*是匹陪[1-9]中的数，而不是匹配所有的字符。要想匹配H20、H320、H308之类的字符串就需要用H[0-9]* 代码折叠 12345set foldmethod=indent set foldnestmax=10 set nofoldenable &quot; makes sure that when opening, files are &quot;normal&quot;, i.e. notfolded. set foldlevel=0 zM/zR zm/zr 大/小写 – 所有/逐层 m/r – 折叠/打开 （对当前折叠）zc/zo zC/zO 大/小写 – 所有/逐层 zf/zd 创建/删除折叠 zj/zk [z / ]z 到当前打开的折叠的开始/结尾处。 显示信息 历史命令 q:或:hist 是否具有某种特性 12:echo has('python3') #0 is false, 1 means true #判断是否支持python3:echo has('viminfo') shell cmd in vim :!pwd # Execute the pwd unix command, then returns to Vi !!pwd # Execute the pwd unix command and insert output in file :r !command :起始行号,结束行号 !command 将起始行号和结束行号指定的范围中的内容输入到shell命令command处理，并将处理结果替换起始行号和结束行号指定的范围中的内容 例如 :62,72 !sort #，将62行到72行的内容进行排序 :起始行号,结束行号 w !command 将起始行号和结束行号所指定的范围的内容作为命令command的输入。不会改变当前编辑的文件的内容 vimrc Plugin auto-pairs github readme里，有括号包裹单词这个功能，但我尝试多次也没有使用成功。 或对应这一功能（A means Alt, M means Meta, in present context Alt and Meta is the same ），但我在Xshell中用的时候，并没有激活auto-pairs，激活的是linux自带的快捷键–向右移动到词尾。 最终我输入单个括号是用：ctrl+v，（ markdown插件 vim-markdown http://www.jianshu.com/p/24aefcd4ca93 https://github.com/plasticboy/vim-markdown 有用的命令：c 1:Toc YouCompleteMe Mac下安装： 参考：Install YCM in Mac Note: 1/usr/bin/python install.py --clang-completer --system-libclang YCM does not work with Anaconda Python Anaconda is often incompatible with the pre-built libclang used by YCM and therefore is not supported. 需要进入bundle文件夹进行编译 错误YouCompleteMe unavailable: requires Vim compiled with Python (2.6+ or 3.3+) support 明明安装VIM时已经选择支持python3了，为什么还会报错？而且： 1:echo has('python3') #返回值为0，说明在vim中不能正常支持python 这很可能是因为：python运行时找不到库。解决方法就是添加python库的路径到LD_LIBRARY_PATH环境变量： 1export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/anaconda3/lib/ 然而，这样又会导致其他程序找到的是/opt/anaconda3/lib/里的库，而非系统自带的库，例如： 12$ evinceevince: symbol lookup error: /lib64/libgdk-3.so.0: undefined symbol: cairo_surface_set_device_scale 最终解决方法，是分别设置环境变量，例如： 1alias evince='LD_LIBRARY_PATH="" evince' 这样evince启动时，就不会去anaconda的路径里面找库了。 cmd 颜色 .vim/colors/中放置配置文件 :colo 查看当前颜色 noremap：绑定键的时候，不迭代绑定 五中模式代号：nvoic reference vim tutorial 超过130个你需要了解的vim命令 【好】 vim map nmap【非常好，介绍vimrc的一些基本命令】]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令记录]]></title>
    <url>%2Flinux_command%2F</url>
    <content type="text"><![CDATA[记录用过的命令，方便以后查找。不包含太简单的或太难的。 长度感人。 [TOC] 正则表达式 1.&lt; #匹配词头 &gt; #匹配词尾 2.+ 匹配1或多个 3.？ 匹配0或1个 4.x|y 匹配x或y 5.x{5,10} 匹配x出现5到10次 一句话介绍一个命令： shell 内置 --: a double dash (--) is used to signify the end of command options. 例如ls -- -l中会把-l当成文件名 echo $((a%b)): 余数 资源管理 ulimit: 管理用户占用的资源 nice &amp; renice 命令: 管理任务优先级 pkill -kill -t pts/5: 踢掉相应的用户 sudo sh -c &quot;echo 1 &gt; /proc/sys/vm/drop_caches&quot;: 清理硬盘 iostat -x sdb1 1 3: 显示sdb1的状态，每1秒显示一次，一共显示3次。 键盘 bind -p: 查看所有的键盘绑定 stty -a: 查看下默认的键位设置 toe /usr/share/terminfo/: supported terminal; you can compare two terminal by infocmp vt100 vt220 文本处理相关 tac: cat倒过来写，是将文件反向输出的命令 join命令: 横向连接文件，可以合并第一列 tee: tee file1 file2 - #将标准输出，输出到file1、file2和标准输出（“-”就是代表标准输出）（注意 该命令本身会向标准输出 输出一次，所以tee file1 file2 - 会将标准输出 输出两次） read: read -p &quot;make dir now?[y/n]:&quot; select#直接读入变量值 其他 basename &amp; dirname: 从路径名得到root部分和文件名部分 df -T: 显示硬盘分区类型 lsof: lsof -p 456,123 列出进程456和123所有打开的文件。lsof -i 6 列出所有IPv6协议的网络文件 env: 输出所有环境变量 ldd ./exe: 给出链接的库 systemctl start atd: arch中用at，需要开启 gimp: 看图png,jpg,bmp都能看 info &amp; whatis: they tell the information of a command; Note that in OS, info whatis will get “search database …” linux Command line Ctrl + a, Ctrl + e, alt + f 前进一个单词、alt + b(通过xshell并不好使): 谁用谁知道 Ctrl + f, Ctrl + b 前进一个字母/后退一个字母 Ctrl + 方向键左键 光标移动到前一个单词开头 Ctrl + 方向键右键 光标移动到后一个单词结尾 ^oldstr^newstr 替换前一次命令中字符串 同时head&amp;tail: ls | (head;tail) 或者 (head; tail) &lt; file !系列命令 !-n， 重复执行倒数第 n 条命令，n 为正整数； !!， 重复执行上一条命令。该命令等价于 !-1；!?str，重复执行最近一条包含字符串 str 的命令； !#，引用当前的命令行，例如：cp filename filename.bak 可以写为 cp filename !#:1.bak !^/!$ 重用上一条命令的第一个参数/最后一个参数； ls /usr/share/doc /usr/share/man; cd !^# 即 cd /usr/share/doc !* 重用上一条命令的所有参数； touch a.txt b.txt c.txt vim !* # 即 vim a.txt b.txt c.txt !!:n 重用上一条命令中的第 n 个参数，n 为正整数。 vim {a..c}.txt vim !!:2 # 即 vim b.txt !str:x-y 重用上一条以 str 开头的命令的第 x 到第 y 个参数； touch a.txt b.txt c.txt d.txt vim !touch:2-3 # 即 vim b.txt c.txt !?str:n* 重用上一条包含 str 的命令的从第 n 个到最后一个参数； vim foo.h foo.cc bar.h bar.cc wc !?vim:2*# 即 wc foo.cc bar.h bar.cc !(except_file) 有时候在一个文件夹下面，有几个废物的 a_file b_file except_file 参数的子字符串 利用 :h 截取路径开头，相当于 dirname 12ls /usr/share/fonts/truetype/dejavu cd !$:h # 即 cd /usr/share/fonts/truetype 利用 :t 截取路径结尾，相当于 basename tar zxf !$:t # 相当于 tar zxf nginx-1.4.7.tar.gz 利用 :r 截取文件名 12gunzip filename.gzipcd !$:r # 即 cd filename 利用 :e 截取文件扩展名 12ls file.jpgecho !$:e # 即 echo jpg&lt;b&gt; 简单记忆： h|t r|e 参数的补全 引子 我们用which &quot;command&quot;命令时，可能感觉到which后面的命令无法补全，很不方便，比如which python3就需要手动输入python3。因此我们不禁希望参数也可以用[tab]补全。 实际上，linux是可以补全参数的。比如zsh就自带补全参数。最主流的bash经过设置，也是可以补全参数的。 bash 中标准补全功能包含了[1]： 路径补全 文件名补全 变量补全 用户名补全 主机名补全 很多人比较熟悉的补全可能只有前两项。此外，我们还可以通过complete命令，自定义补全参数。 以which为例，$ complete -c which，就可将所有命令作为which的参数进行补全了。 complete具有强大的补全功能，更多设置可以参考[1]。 complete CentOS 7.3，在/etc/bash_completion.d/进行设置。 -F设定补全函数 alt 如果不是直接在终端上操作，alt键需要进行设置才能使用。**比如Xshell中，在“属性–键盘–将Alt键作为Meta仿真”打钩，才能使用；OS X上，无法用alt键。**PS：win键盘一般alt键当做Meta键；ALt GR：有些老键盘左边是Alt，右边是ALt GR键 Alt+./Esc+. (!^ !$): 将最近一条命令的参数输出 Alt+ f/b: 向前/后移动一个词 其他 Brace Expansion ls /usr/{,local}/bin，会列出&quot;/usr/bin&quot;和&quot;/usr/local/bin&quot; shell特殊变量 $0 当前shell程序的名字 $1 ~ $9 命令行上的第一到第九个参数 $# 命令行上的参数个数 $*, $@ 命令行上的所有参数 $? 上一条命令的退出状态 $$ 当前进程的进程标识号(PID) $! 最后一个后台进程的进程标识号 外部资源链接 更多牛逼命令： http://www.zhihu.com/question/20140085 http://www.zhihu.com/question/20273259 http://www.zhihu.com/question/25910725/answer/31951050 linux shell 快捷键: http://blog.chinaunix.net/uid-361890-id-342066.html 编码 ctrl+h；终端 F1 ascii中Backspace的值为010（八进制），而ASCII values can be represented in several equivalent ways. 而ctrl+h的值也为010。 terminal区分不了二者，因此输入以ascii编码，则ctrl+h变为Backspace；而输入不以ascii编码，Backspace也会显示成^H，即ctrl+h terminal类型的选择也会影响快捷键 Xshell中，文件–属性–键盘–功能键类型 选择xterm R6，则VIM中可以绑定F1；如果选linux，则不可以 系统信息： cpu information cat /proc/cpuinfo 列出内核版本、主机名等信息 uname -a 发行版信息 cat /etc/redhat-release alias命令： http://stackoverflow.com/questions/22537699/cannot-use-alias-while-executing-a-command-via-ssh Quoted from the man page of bash: Aliases are not expanded when the shell is not interactive, unless the expand_aliases shell option is set using shopt … apt-get Usage: 123apt-get update \ &amp;&amp; apt-get upgrade -y \ &amp;&amp; apt-get install -y \ update：第一步，获得最近的软件包的列表；列表中包含一些包的信息，比如这个包是否更新过。 upgrade：第二步，如果这个包没有发布更新，就不管它；如果发布了更新，就把包下载到电脑上，并安装。 apt-cache can search package common package name libboost-all-dev at命令： 介绍：定时执行一次命令。如果想周期地执行命令，请使用crontab at -f work.sh now +3 min 3分钟后执行脚本 work.sh -f指的是从文件读入命令 其他的时间表示法：at 17:30 2/24/99 atq （等于at -l） 查看at任务队列 atrm+任务号 似乎没有单命令行的用法，一般用法都是“at 时间”然后进入at命令，输入要执行的命令，然后退出 awk命令： 替换操作在awk中不易执行。 awk '/pattern/ {print $0 }' filename e.g. awk '/abc/ {print $0 }' filename, 则含有 abcde 的行也会被输出。 awk 'NR==2 {print $0}' aver.tmp awk '$1!~/match_str/ {print $0 }' filename 去掉重复的单词 123456789101112#!/bin/awk -f&#123; for (i = 1; i &lt;= NF; i++) &#123; ++word[$i] if (word[$i] == 1) printf("%s ", $i) &#125; printf("\n")&#125; awk script 1234567891011#!/usr/bin/awk -f#是注释符号BEGIN &#123;......&#125;&#123; #这个中括号不能省略......&#125;END &#123;......&#125; 引用外部变量的几种方式： 【来自：http://club.topsage.com/thread-393615-1-1.html】 （1）&quot;'&quot;var&quot;'&quot; ——错。应该是&quot;'&quot;$var&quot;'&quot; （2）awk '{print a, b}' a=111 b=222 yourfile （3）awk –v a=111 –v b=222 ‘{print a,b}’ yourfile （4）【ct】pid=$(ps -f | awk '/gpu='&quot;$gpu&quot;'/ &amp;&amp; !/awk/ {print $2}') ——在//之间，引用外部变量的正确方式是’&quot;$v&quot;’ 引用外部命令的两种方式：【http://hi.baidu.com/gubuntu/blog/item/050398ceb010513fb700c8d0.html】 例:awk '{if(/Beren/) {print $0 | &quot;cut -b 2-&quot; } else print $0}' job.plm 但糟糕的是，上面这条命令的输出顺序与你设想的并不一致 求最大值、最小值、求方差等 1234awk '&#123;if (max=="") &#123;max=$3&#125; else &#123;if ($3&gt;max) max=$3&#125;&#125; END &#123;print max&#125;' file1 awk '&#123;if (min=="") &#123;min=$2&#125; else &#123;if ($2&lt;min) min=$2&#125;&#125; END &#123;print min&#125;' file1 awk '&#123;sum+=$1; sumsq+=$1*$1&#125; END &#123;print sqrt(sumsq/NR-(sum/NR)**2)&#125;' file1 【注意】：中间不能有空行或短行，否则$3=null，而系统会认为null比负数还小，如果数列中含有负数，那么上式就会出现问题 求和 对六百列分别求和 1234for((i=1;i&lt;=600;i++))do awk '&#123;sum+=$'"$i"'&#125;END&#123;print sum/"'"$num_exc"'"&#125;' ttt1.tmp &gt;&gt; datadone 对行求和 12awk -v FS="," -v OFS="+" '&#123;$1="";system("echo $["$0"]")&#125;'awk -F',' '&#123;for(i=2;i&lt;=NF;i++)sum[NR]+=$i;print $1","sum[NR]&#125;' 【来自】http://bbs.chinaunix.net/thread-1384345-1-1.html printf用法 printf &quot;%s %s %s &quot;,$1,$2,$3 求最大值、最小值、求方差等 1234awk '&#123;if (max=="") &#123;max=$3&#125; else &#123;if ($3&gt;max) max=$3&#125;&#125; END &#123;print max&#125;' file1 awk '&#123;if (min=="") &#123;min=$2&#125; else &#123;if ($2&lt;min) min=$2&#125;&#125; END &#123;print min&#125;' file1 awk '&#123;sum+=$1; sumsq+=$1*$1&#125; END &#123;print sqrt(sumsq/NR-(sum/NR)**2)&#125;' file1 【注意】：中间不能有空行或短行，否则$3=null，而系统会认为null比负数还小，如果数列中含有负数，那么上式就会出现问题 awk中 ‘’ 和 “” 【单引号和双引号】 &quot;&quot;是直接输出 ’'是转义输出,'C1’就有特殊的含义 gawk 4.1.0之后才可以原位修改文件 bc命令： 1.m的n次方 echo &quot;m^n&quot;|bc 2.计算π： echo &quot;scale=100; a(1)*4&quot; | bc -l 【附一部分man】 MATH LIBRARY If bc is invoked with the -l option, a math library is preloaded and the default scale is set to 20. The math functions will calculate their results to the scale set at the time of their call. The math library defines the following functions: s (x) The sine of x, x is in radians. 正玄函数 c (x) The cosine of x, x is in radians. 余玄函数 a (x) The arctangent of x, arctangent returns radians. 反正切函数 l (x) The natural logarithm of x. log函数(以2为底) e (x) The exponential function of raising e to the value x. e的指数函数 j (n,x) The bessel function of integer order n of x. 贝塞尔函数 3.做加减法时（比如a*b+c）bc不会读入scale信息，所以要想设定scale，可以写成(a*b+c）/1,除法是一定会读入scale的。（(a*b+c）*1）没有效果，但a*b有效果） 【第二次测试，不存在这个问题了】 bc不能识别形式为科学计数法的输入，如1.2345e+06 compgen 123456compgen -c # will list all the commands you could run.compgen -a # will list all the aliases you could run.compgen -b # will list all the built-ins you could run.compgen -k # will list all the keywords you could run.compgen -A function # will list all the functions you could run.compgen -A function -abck # will list all the above in one go. convert命令： convert ${i%plt}eps -density 100x100 ${i%plt}tif convert ${i%plt}eps -density 300 ${i%plt}png #300代表dpi convert -loop 1中loop是播放次数；0代表无限循环 -pause 200：暂停200毫秒，再进行下一轮播放。 animated gif convert -delay 120 -loop 0 *.png animated.gif The delay parameter specifies the delay between frames in 0.01s, while the loop parameter determines how many times the animation runs (the 0 value will run the loop infinitely). source cp命令： cp自动创建层级结构 例子: cp --parents parentdir1/parentdir2/sourcefile destdir/ cut命令： cut命令很好用 awk '/Beren/ {print $0}' tt1 | cut -b 2-cut部分的意思是截取第二个到最后一个字符。 diff命令 1.对比两个文件夹的不同 diff -ruN tmp_galamost-3.0.6/ galamost-3.0.6_origin/ &gt; diff_text echo命令： -e 开启反斜杠转义字符 -E 关闭反斜杠转义字符 -n 去掉echo默认输出的换行符 测试 1234$ echo -e "a\tb\tc\n"a b c$ echo -E "a\tb\tc\n"a\tb\tc\n gprof： http://blog.csdn.net/linquidx/article/details/5916701 http://blog.csdn.net/stanjiang2010/article/details/5655143 gprof -b -A -p -q test gmon.out &gt; x -b选项的作用是输出程序说明，对比加-b选项和不加的情况就明白了 grep命令： -i： 忽略大小写 -v： 不显示匹配的项 同时匹配str1或str2: grep &quot;str1\|str2&quot; 同时匹配str1与str2: grep str1 filename | grep str2 # I tried, but there's no elegant way to do this. kill命令： 后台运行恢复到前台 如果要让它恢复到后台，用kill -CONT 1234 （很多在前台运行的程序这样是不行的） kill -STOP 1234 如果要恢复到前台，请在当时运行该进程的那个终端用jobs命令查询暂停的进程 signal kill -9: 发送SIGKILL，必杀型signal。该信号作用是杀掉进程 kill -15: 发送SIGTERM。该信号作用是终止当前运行的软件。当程序接收到该signal后，将会发生以下的事情: 程序立刻停止 当程序释放相应资源后再停止 程序可能仍然继续运行 ls命令： 1.只显示文件 ls -l | grep ^- | awk '{print $9}' ls -1 -F | grep -v [/$] 2.只显示文件夹 只显示文件夹： ls -d */ -d的意义: 显示目录本身的信息，而不是列出目录下的文件 ls *： 显示所有文件、文件夹及其中的文件(文件夹) ls -d *: 显示所有文件、文件夹 查看linux进程的执行文件路径 1、以超级用户登陆 2、进入/proc目录 3、ps查看所有符合./cmd的进程，找出其对应的PID进程号 4、用ll命令： ll 进程号 如下显示一个示例： [root@Cluster1 proc]# ll 22401 (proc文件夹中有对应PID码的文件名,进入即可) total 0 -r--r--r-- 1 zhouys zhouys 0 Dec 11 11:10 cmdline -r--r--r-- 1 zhouys zhouys 0 Dec 11 11:10 cpu lrwxrwxrwx 1 zhouys zhouys 0 Dec 11 11:10 cwd -&gt; /home/zhouys/sbs/bin -r-------- 1 zhouys zhouys 0 Dec 11 11:10 environ lrwxrwxrwx 1 zhouys zhouys 0 Dec 11 11:10 exe -&gt; /home/zhouys/sbs/bin/cbs (deleted) dr-x------ 2 zhouys zhouys 0 Dec 11 11:10 fd -r-------- 1 zhouys zhouys 0 Dec 11 11:10 maps -rw------- 1 zhouys zhouys 0 Dec 11 11:10 mem -r--r--r-- 1 zhouys zhouys 0 Dec 11 11:10 mounts lrwxrwxrwx 1 zhouys zhouys 0 Dec 11 11:10 root -&gt; / -r--r--r-- 1 zhouys zhouys 0 Dec 11 11:10 stat -r--r--r-- 1 zhouys zhouys 0 Dec 11 11:10 statm -r--r--r-- 1 zhouys zhouys 0 Dec 11 11:10 status /proc文件系统下的 进程号目录 下面的文件镜像了进程的当前运行信息， 从中可以看到： cwd符号链接的就是进程22401的运行目录； exe符号连接就是执行程序的绝对路径； cmdline就是程序运行时输入的命令行命令；本例为：./cbs cpu记录了进程可能运行在其上的cpu；显示虚拟的cpu信息 environ记录了进程运行时的环境变量 fd目录下是进程打开或使用的文件的符号连接 ... 通过cwd直接进入进程运行目录，通过查看相关信息就可以定位此目录对应那个端口号，以及 定位是那个应用才使用此服务程序。 5、`ps -aux` 命令 ps也可打印其路径,但不是万能的,有些路径只能使用以上两种方法取得 ln ln source target hard link hard link是两个文件共享一个inode，然而各种编辑器编辑文件时（例如vi, Mou），是会重新生成一个文件并删除老文件的，这导致inode变化。所以hard link是几乎没用的功能：因为文件的inode经常会变。 删除文件夹的软链接 例如mydir是一个文件夹的软链接，如果想删除软链接，我们一般的操作为，rm my[tab]以补全文件名，结果为： rm mydir/ 然而这样删除会提示：rm: cannot remove ‘test’: Is a directory。 这时候千万不能加上-r，如果加上，会把软链接的源文件删除掉！ 正确删除文件夹软链接的命令为：rm mydir mkdir命令： 在预设情况下目录得一层一层的建立，但通过-p参数，就可以之间建立。 netstat Settings -t/-u: tcp protocol/udp protocol -r: display routing table Common command netstat -nr show IP routing table netstat -tnpl show the listened port od cat &quot;ace&quot; | od -A n -t x1 将字符串转为十六进制 openssl cipher a file openssl aes-128-cbc -salt -in test.txt -out test.txt.aes decipher: openssl aes-128-cbc -d -salt -in test.txt.aes -out test.txt.out ping Check connection of whole web segment. ping 192.9.204.$i -c2 | grep -q &quot;ttl=&quot; &amp;&amp; echo &quot;$i yes&quot; || echo &quot;$i no&quot; printf命令： 1.补零 printf &quot;%05d&quot; 123 结果是：00123 参考：http://blog.csdn.net/truelie/article/details/1692942 ps命令 linux查看进程启动时间(运行多长时间) ps -eo pid,lstart,etime | grep your_pid scp命令 scp与软链接 会把软链接的文件都拷贝过去！正确的拷贝方法为：123sudo tar -czvf test.tgz testscp ~/test.tgz sudo tar -xzvf test.tgz -C . sed命令： sed命令详解 抓取第m 到 第n行： sed -n &quot;m,np&quot; filename sed -n &quot;$[$fl*($i-1)+1],$[$fl*$i]p&quot; ../../precopy/h-tail-10 &gt; frame$i 在file1第3行之后插入file2: sed '3 r file2' file1 将“vel[i].x vel[i].y vel[i].z”替换成“velx[i] vely[i] velz[i]” s/\[i\]\.\([xyz]\)/\1[i]/g &amp;字符 : 代表其前 pattern 字串 例：sed -e 's/test/&amp; my car/'替换后变为：test my car 在有字符串33的行的行首，添加 sed -i '/33/s/^/#&amp;/' t1.plm 注意为什么要有^： 有“^”，“&amp;”代表的是有字符串33存在的整行 没有“^”，“&amp;”代表的是字符串33 将原来的所有空行删除并在每一行后面增加一空行 sed '/^$/d;G' file3 在指定(export)行前面加行 sed '/export/i xxx' file或sed '/export/i \xxx' file 在指定(export)行前面后行 sed '/export/a xxx' file或sed '/export/a \xxx' file 单引号的转义 '\'' sed 's/'\''//g'# 将单引号替换为空格 匹配空行 正常匹配空行是^$；但是对于从windows拷贝过来的文件，要用^.$匹配 而vim（版本8.0）内置的sed，不论文件来自哪种系统，都可以用^$匹配 sed '/^[[:space:]]*$/d' file 可以去掉由空格、Tab和换行组成的空行! 指定行添加内容 sed -i '1 i \#!/home/ct/bin/gnuplot5/bin/gnuplot5/' gnu.plt 外部变量 sed 's/standard/'&quot;$i&quot;'/' sed -i会使软链接失效 --follow-symlinks可以保持软连接 同时取代多个字符串 sed -e 's/str1//;s/str2//' filename 删除 linux下使用sed 命令来删除指定行 删除第N行 sed 'Nd'filename 删除第M到第N行 sed 'M,Nd'filename 从第三行开始,每隔一行删除 sed '3~2d' filename 删除匹配行和之后两行 sed '/Storage/,+2d' sed问题 sed 's/,\&quot;\&quot;$//' export-0xa6214.csv无效； 然而，sed 's/,\&quot;\&quot;\r//' export-0xa6214.csv有效； 用vim打开，也找不到\r字符； 实际上，用od命令看16进制文件后，会发现确实存在\r； vim找不到\r是因为，打开的vim会自动把\r去掉了，但是注意没有把文件中的\r去掉 set命令 set is important, but always neglected! set -u: if a varible does not exist, report an error. set -x: print the corresponding command before output. set -e: stop the script when an error is encountered. set -o pipefail: Without this option, the error during a pipeline will not be reported. These 4 setting should be used at all times. In script: add set -euxo pipefail in the beginning of script. In cli: $ bash -euxo pipefail script.sh bash option -l: Make bash act as if it had been invoked as a login shell. the profile file will be loaded! E.g., /etc/profile. sort命令 按第二行排序 sort -n -k2 file ssh命令 ssh -X: Enables X11 forwarding然后就可以用vmd、gnuplot等软件了。 通过ssh执行命令时，由于没有登录，是不会执行source .bash_profile的。可以手动执行解决这个问题： 例如：sshpass -p 'password' ssh -o StrictHostKeyChecking=no -l lzy&quot;$i&quot; 192.9.207.204 &quot;source .bash_profile;/opt/sge/sge6_2u4/bin/lx24-amd64/qstat&quot; su命令： 1.关于login （1）.直接登录root （2）.由其他用户名登录到root: su -，否则就是没有login （3）su -c 'command' time命令 time ./program 参数：-p 以秒为默认单位来进行输出 top命令： 1.查看内存 可以直接使用top命令后，查看%MEM的内容 查看用户ct的进程的内存： top -u ct 查看特定进程的内存：top -d 1 -p pid [,pid ...] //设置为delay 1s，默认是delay 3s；如果想根据内存使用量进行排序，可以shift + m（Sort by memory usage） uniq命令 uniq -c 在每行行首加上本行在文件中出现的次数(count)。它可取代-u加-d。 unzip unzip -O GBK you_zip_file.zip For more ways to tickle with gibberish: [Linux文件乱码]](https://zhuanlan.zhihu.com/p/25988628) xargs命令 &amp; find命令： awk '{print }' filenames | xargs du -h 文件filenames中存储了一些文件名，用这种方式，可以看到每个文件的大小 find . -name &quot;pa*.xml&quot; | xargs -n 10000 rm -f find + xargs 是“Argument list too long”问题的标准解决方法，find命令是持续输出的，而xargs再将find的出处分成若干段，再进行下一步处理 `find -name *.dcd | tee -a dcd_name | xargs rm &amp; 删除文件，并将删除的文件的路径输入到dcd_name中 批量转换文件格式1ls *.jpg | xargs -I&#123;&#125; -P 8 convert "&#123;&#125;" `echo &#123;&#125; | sed 's/jpg$/png/'` 其中-P代表进程数； -i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给{}，可以用{}代替。” 在当前这个命令下，以tmp.jpg为例，实际上执行的是 convert tmp.jpg tmp.png yum命令 yum install foo yum remove foo yum search *foo* yum info *foo* yum list *foo* # the available packages yum localinstall foo.rpm yum install -y --downloadonl --downloaddir=/opt But by this method, if the newest package has been installed, then nothing will be done. To solve this problem, you can do : yum install yum-utils yumdownloader &lt;package&gt; # will download directly. package name and virsion name should be concatenated by ‘-’ install openmpi yum install -y openmpi openmpi-dev update &amp; upgrade yum -y update 升级所有包，改变软件设置和系统设置，系统版本内核都升级 yum -y upgrade 升级所有包，不改变软件设置和系统设置，系统版本升级，内核不改变 Note! apt-get的update、upgrade与yum的非常不同。 yum whatprovides autoconf wget https://lug.ustc.edu.cn/wiki/_export/code/mirrors/help/centos?codeblock=3 CentOS yum中科大源 其他 逻辑表达式与&amp;&amp;和||： 逻辑表达式 （1）C语言中写法： if (a == b &amp;&amp; a == c) shell 中的写法： if ([ $a -eq $b ] &amp;&amp; [ $a -eq $c ]); then (2) C 语言中的写法： if (a == b &amp;&amp; a == c &amp;&amp; b == c) shell 中的写法： if [ $a -eq $b -o $a -eq $c -o $b -eq $c ]; then if [ $a -eq $b ] &amp;&amp; [ $a -eq $c ] &amp;&amp; [ $b -eq $c ]; then 注意：“[”或“]”与表达式之间必须要有空格。 [[ ]] vs. [ ] [2] [ ]是shell built-in，而[[ ]]不属于POSIX； [ ]会展开a*，所以用它的时候需要加双引号：[ &quot;$var&quot; ]；[[ ]]不需要 [ ]会fork a new process，[[ ]]不会 &amp;&amp;和|| &amp;&amp;和||与逻辑表达式表面相似，实则完全不同，如果混淆了会导致严重的错误。 command1 &amp;&amp; command2，如果command1返回值为真（$?==0），才会执行command2。一般命令正确执行了，都会返回0。 command1 || command2则是command1返回值为假（$? != 0）才执行command2。 关于这两个算符，还有个隐僻但重要的问题是command1 &amp;&amp; command2的返回值，如果command1返回值为假，整个表达式的返回值也为假，表达式所在的脚本的返回值也为假！。 有不少人认为[ ... ] &amp;&amp; ...和if语句效果一样但更简洁，这种想法是错误的，因为前一种用法会影响程序返回值，而if语句不会。如果在脚本中用前一种方法，会莫名其妙的导致返回值为假又没有任何报错。 \r\n和\r Windows采用前者，mac、unix采用后者； \r和\n的16进制代码分别是0d和0a 含空格的变量 含有空格的变量可以这样写: 123mypath="/home/my path"mypath='/home/my path'mypath=/home/my\ path 但需要注意的是，引用时一定要加双引号： ls &quot;$mypath&quot; Always quote variable dereferences. Otherwise, the shell confuses the spaces in the variable’s value as spaces separating multiple values. 脚本注意事项： declare -A var # 声明为关联数组 declare -a var # 声明为数组 二者很不同 关联数组定义的后面不能加# 例如：array=([seg]=100)# 这样会出问题 命令中blank space是不能随便加的 Because blank space is usually used as the separater of command or agruments. &lt;&lt;block #&lt;&lt; 和 block之间不能有空格 脚本的长度 不要把不同功能写到一个脚本中，尤其是脚本较大的时候。 即使你可以非常顺利的写出脚本的每一句，也不意味着你的脚本可以正常执行。 所以要分块编写:12345!/bin/sh part1.sh part2.sh part3.shexit 优点： 这样编写把part1-3的内容写在一个脚本里执行起来是一样的，但是，像这样将脚本分割，有利于调试脚本。由于脚本过于灵活，所以非常容易出错，而出错几率是和大小成指数关系的。所以要把脚本分化，使每一部分都有明确的意义，一来方便检查脚本是否有误，二来增加代码的重复利用率。 缺点： 传递参数麻烦。 常见错误 循环变量的错误使用 比如说循环变量i，在其他地方是否被改动了？ 这种错误shell是不会检查出来的 Linux 中 10 个有用的命令行补全例子 ↩ ↩ Is double braket preferable over single braket in Bash? ↩]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python mechanism]]></title>
    <url>%2Fpython_mechanism%2F</url>
    <content type="text"><![CDATA[[TOC] 0. is 与 ==的区别 python对象有三个要素：id、type、value。is 比较的是id；==比较的是value 而id实际上是内存地址，(ob1 is ob2) 等价于 (id(ob1) == id(ob2)) 另外，一些具体的问题，结果不确定，比如用python.py： 1234 &gt;&gt;&gt; x = 500 &gt;&gt;&gt; y = 500 &gt;&gt;&gt; x is yTrue 然而用python或者IPython，结果为False NOTE: The result of 5 == 5.0 is True! [1] 1. mutable &amp; immutable 不可变（immutable）：int、字符串(string)、float、（数值型number）、元组（tuple) 可变（mutable）：字典型(dictionary)、列表型(list) 2. with 语句 自动进行对象的生命周期进行管理 Python中的with语句中要求对象实现__enter__和__exit__函数。调用with语句时，会先分析该语句，执行__enter__函数，然后在当前suite退出时，会调用__exit__函数。__exit__函数中除了可以做释放资源的操作之外，同时也是异常处理的地方。如果当前suite正常退出，没有抛出任何异常，__exit__的几个参数均为None。否则，则将此异常的type、value、traceback作为参数传递给__exit__函数，同时，如果__exit__返回false，此异常会再次抛出，上一级代码suite可以继续处理，如果__exit__返回true，那么此异常就不会被再次抛出了。 同时打开多个文件 12345with open(filename1, 'rb') as fp1, open(filename2, 'rb') as fp2, open(filename3, 'rb') as fp3: for i in fp1: j = fp2.readline() k = fp3.readline() print(i, j, k) 3. list参数传递 python中的默认变量是定义时得到的，类似于static，其它的时候无论调用几次函数，如果没有传参进来，就会一直用这个默认参数了。 正确做法： 12345def add(element, mylist=None): if mylist is None: mylist = [] mylist.append(element) return mylist 4*. Python中函数的参数传递与可变长参数 【tricky】可变长度参数：*tupleArg,**dictAr 廖雪峰的更详细的介绍 需要注意python函数参数种类比较多，分类方法杂。下面我试图清晰的分类： 零、 “关键字参数”这个名字，在不同语境下，所指是不同的，及其容易弄混 一、 从实参的角度看 参数只分为位置参数和关键字参数。 所谓关键字参数，就是值和形参名字绑定在一起。 剩下的就是位置参数。 实参传递时，位置参数要在关键字参数之前。 以上四条就是实参传递的所有规则。 12def func(x, y=1): print(x,y) 二、 从形参的角度看 形参是用来接收实参的值的。 下面按照形参接受实参的顺序排序（注意形参接受实参的顺序不等于形参定义时应该遵从的顺讯）。 首先，最先接收的是实参的关键字参数（也就是实参中指定了形参参数名）。 然后，接收的是实参的位置参数。接收方法就是依次绑定。 第三，默认（形参）参数，也是接收实参的位置参数，只不过对应的实参如果不存在，就用默认参数。正因为默认参数所对应的实参可有可无，所以它在形参中，应该放在位置参数之后。另外，就是著名的python坑，“默认参数一定要指向不变对象”。 PS：其机理是，默认参数是在函数声明时，将默认值的地址绑定到函数的默认参数。因而，如果默认参数是一个可变对象，那么这个可变参数的地址就永远绑定到函数的默认参数上了。之后，每次调用函数，不会改变可变参数的地址，只会改变可变参数的内容。 第四，剩下的实参被可变长度参数（或称可变参数）捕获为tuple。 注意，在未被捕获的实参中，默认参数会先捕获，剩下的才被可变参数捕获。 123456 &gt;&gt;&gt; def func(x,y=-1,*args): print(x,y) print(args) &gt;&gt;&gt; func(1,3,5,7)1 3(5,7) 第五，剩下的实参关键字参数被形参关键字参数捕获 如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下： 12def person(name, age, *, city, job): print(name, age, city, job) 机理是，所有位置参数都已经被星号及其之前的形参接受，所以剩下的必须用关键字参数接收。 形参定义时，因该遵从的顺序 参数定义的顺序必须是：必选参数–&gt;默认参数–&gt;可变参数–&gt;命名关键字参数–&gt;关键字参数 关键字参数一定是放在最后的。 reference Python中位置参数、默认参数、可变参数、命名关键字参数、关键字参数的区别 5. generator 最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。 generator is an iterator! official doc: generator: A function which returns a generator iterator. Python之生成器详解: 我们常说的生成器,就是带有yield的函数,而generator iterator则是generator function的返回值,即一个generator对象,而形如mygenerator=(elem for elem in [1, 2, 3])括号中的表达式,称为generator expression,实际使用与generator无异。 iterator是消耗型的,用一次少一次 调用send(value)时要注意,要确保,generator是在yield处被暂停了,如此才能向yield表达式传值,否则将会报错(如上所示),可通过next()方法或send(None)使generator执行到yield. send(none)起的作用相当于next() generator可以用于for循环，例如：for i in mygenerator: # mygenerator的定义见上文 6. zip() &amp; Unpacking Argument Lists——&quot;*&quot; &amp; “**” The implementation of zip is very beautiful： 来自python doc 123456789101112131415def zip(*iterables): # zip('ABCD', 'xy') --&gt; Ax By sentinel = object() # ct: iterators is a "Iterator" point to the "Iterator" of different parameters(形参) # e.g., at first, iterators is the "Iterator" of 'ABCM'; # iterators.next() is the "Iterator" of 'xy'; iterators = [iter(it) for it in iterables] while iterators: result = [] for it in iterators: elem = next(it, sentinel) if elem is sentinel: return result.append(elem) yield tuple(result) 123456789 #zip() in conjunction with the * operator can be used to unzip a list: &gt;&gt;&gt; x = [1, 2, 3] &gt;&gt;&gt; y = [4, 5, 6] &gt;&gt;&gt; zipped = zip(x, y) &gt;&gt;&gt; list(zipped)[(1, 4), (2, 5), (3, 6)] &gt;&gt;&gt; x2, y2 = zip(*zip(x, y)) &gt;&gt;&gt; x == list(x2) and y == list(y2)True Unpacking Argument Lists 12345 &gt;&gt;&gt; list(range(3, 6)) # normal call with separate arguments[3, 4, 5] &gt;&gt;&gt; args = [3, 6] &gt;&gt;&gt; list(range(*args)) # call with arguments unpacked from a list[3, 4, 5] 7. Iterable和Iterator Iterable 凡是可作用于for循环的对象都是Iterable类型，它有__getitem__()方法； 集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。 Iterator Iterator is Iterable! 凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列，它有__next__()和__iter__()方法 理解：想一想C++中的Iterator，它就是个指针。 Iterator是消耗型的,即每一个值被使用过后,就消失了，但是最终它并不等于None。 while my_iterator（参见zip的实现） iterator最终会返回StopIteration对象，而while可以对其进行判断。 8. for Python的for循环本质上就是通过不断调用next()函数实现的，例如： for x in [1, 2, 3, 4, 5]: pass 实际上完全等价于： 首先获得Iterator对象: it = iter([1, 2, 3, 4, 5]) 然后在循环: 123456while True: try: # 获得下一个值: x = next(it) except StopIteration: # 遇到StopIteration就退出循环break NOTE: The implement of for directly influence the corresponding results, e.g.: example of for 1234some_string = "wtf"some_dict = &#123;&#125;for i, some_dict[i] in enumerate(some_string): pass Output of some_dict: {0: 'w', 1: 't', 2: 'f'} NOTE: This is because during for statement, dummy variables(e.g., i and some_dict[i] in present case) will be assigned in each loop. 8. 内存 8.1. 释放内存 先del再gc.collect() 9. Python类 9.1. 和静态语言不同，Python允许对实例变量绑定任何数据 也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同： 123456789 &gt;&gt;&gt; bart = Student('Bart Simpson', 59) &gt;&gt;&gt; lisa = Student('Lisa Simpson', 87) &gt;&gt;&gt; bart.age = 8 &gt;&gt;&gt; bart.age8 &gt;&gt;&gt; lisa.ageTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute 'age' 9.2. Python的伪私有属性 Note that user defined attributes shall not end with __ 9.3. 私有变量的访问方法 不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量。 注意下面的这种错误写法： 123456 &gt;&gt;&gt; bart = Student('Bart Simpson', 98) &gt;&gt;&gt; bart.get_name()'Bart Simpson' &gt;&gt;&gt; bart.__name = 'New Name' # 设置__name变量！ &gt;&gt;&gt; bart.__name'New Name' 表面上看，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量不是一个变量！内部的__name变量已经被Python解释器自动改成了_Student__name，而外部代码给bart新增了一个__name变量。 9.4. 特殊函数__call__模糊了对象与函数的区别 9.5. 类类型的检查–不检查 静态语言 vs 动态语言 对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。 对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了： 12class Timer(object):def run(self): print('Start...') 这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。 Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。 18. namespace and scope What is the relationship between scope and namespaces in Python? Difference between Scopes and Namespaces in python? namespace A namespace is a dictionary, mapping names (as strings) to values. When you do an assignment, like a = 1, you’re mutating a namespace. When you make a reference, like print(a), Python looks through a list of namespaces to try and find one with the name as a key. namespaces is a dict in deepdown. We can picture a namespace as a Python dictionary structure, where the dictionary keys represent the names and the dictionary values the object itself (and this is also how namespaces are currently implemented in Python), e.g., a_namespace = {'name_a':object_1, 'name_b':object_2, ...} scope A very good explanation (A Beginner’s Guide to Python’s Namespaces, Scope Resolution, and the LEGB Rule): The “scope” in Python defines the “hierarchy level” in which we search namespaces for certain “name-to-object” mappings. 123456789i = 1def foo(): i = 5 print(i, 'in foo()')print(i, 'global')foo() In above scope, there are two namespaces. A bad explanation: You can think of “scope” as being the set of names that you have access to from a particular point in the code. LEGB rule Local -&gt; Enclosed -&gt; Global -&gt; Built-in example (I’m not sure it’s right) 1234567891011x = 1y = 2def foo(): z = 3 + y # P1 point !'''Here, I have access to `x, y, foo` -- They are in the current scope.`z` is not in the current scope. It is in the scope of `foo`.'''a = x + y # P2 point ! At ‘P1’ point: scope: scope includes x, y, foo and z, but not a. namespace: At foo namespace, foo includes z At ‘P2’ point: scope: scope includes x, y, foo and a, but not z. namespace: namespace of this module/file includes x, y, foo and a, but not z. NOTE: In ‘P2’ point, scope and namespace has the same included object. 16. 闭包 谈谈自己的理解:python中闭包，闭包的实质 example 1： 12345678def outer( a ): b = 10 # inner是内函数 def inner(): #在内函数中 用到了外函数的临时变量 print(a+b) # 外函数的返回值是内函数的引用 return inner 内函数外函数在英文中也会写作enclosing function和enclosed function. 闭包中内函数修改外函数局部变量 example 2: 123456789101112131415def outer( a ): # outer是外部函数 a和b都是外函数的临时变量 b = 10 # a和b都是闭包变量 c = [a] #这里对应修改闭包变量的方法2 def inner(): #内函数中想修改闭包变量 # 方法1 nonlocal关键字声明 nonlocal b b+=1 # 方法二，把闭包变量修改成可变数据类型 比如列表 c[0] += 1 print(c[0]) print(b) # 外函数的返回值是内函数的引用 return inner my example: 12345678910111213141516def record_order_to_csv(logger, order_in_pair_utctime, filename): def decorate(func): @wraps(func) def wrapper(*args, **kwargs): res = func(*args, **kwargs) # in here, an error will be raised. To avoid that, aclaim nonlocal b, or just change the name : `fn = get_csv_name(filename)` filename = get_csv_name(filename) with open(filename, 'a+') as f: f.write(', '.join(["some ", "thing"]) + "\n") return res return wrapper return decorate 变量绑定给内函数 每次调用外函数，它都创建一个内函数，虽然代码一样，但是却创建了不同的对象 临时变量会绑定给内函数，再把内函数引用返回! 以example 1的代码为例，调用两次outer，两次返回inner都绑定了同一个变量b，而不是两个b的值！ 这是一个经典的大坑！ 123456789101112131415funcs = []results = []for x in range(7): def some_func(): return x funcs.append(some_func) results.append(some_func())funcs_results = [func() for func in funcs] #Output: &gt;&gt;&gt; results[0, 1, 2, 3, 4, 5, 6] &gt;&gt;&gt; funcs_results[6, 6, 6, 6, 6, 6, 6] 这就是因为所有的some_func都绑定到了变量x上，而x的值是会变的。 解决方案： 12def some_func(x=x): return x 这样x就会变成some_func的内部变量，值就会传进来（我们知道，python中函数的默认值只是在定义时传入一次）。 有什么用？ 做装饰器 对已有的函数添加功能（以及变量） 面向对象 将外函数的临时变量和内函数绑定，和面向对象中将变量和方法绑定，是如出一辙 10. 为什么 Python 的类不构成作用域（scope）？ 待深入 10.1 scope search order: 顺序可以简记为legb(local, enclosing, global, built-ins) Search the local scope Search the scope of any enclosing functions Search the global scope Search the built-ins Only classes, functions, and modules provide scope in Python, so anything declared in an if block has the same scope as anything decleared outside the block. 10.2 the scope of a variable initialized in an if statement In python the scope of a variable is veeery different with other languages. Python variables are scoped to the innermost function, class, or module in which they’re assigned. Control blocks like if and while blocks don’t count, so a variable assigned inside an if is still scoped to a function, class, or module. (Implicit functions defined by a generator expression or list/set/dict comprehension do count, as do lambda expressions. You can’t stuff an assignment statement into any of those, but lambda parameters and for clause targets are implicit assignment.) e.g.: 1234for i in range(10): x = 5print(x) # x is equal to 5! 10.3 exec与eval的奇特之处 1234567def f(): #运行抛异常 a = 123 def g(): ¦ exec("print(a)") g() f() 然而： 12345678def f(): #运行正常 a = 123 def g(): ¦ exec("print(a)") ¦ print(a) g() f() 10.4 注意区分list comprehension与generator！ list comprehension是当时计算的 而list(a+i for i in range(10))中，里面属于generator，是一个匿名函数。 10.5 类的方法与普通函数的区别 运行到class这句的时候，会先将class下面的代码块“假装”当成一个函数来执行，但语法上和正常函数有一些区别： 无输入参数 不能显式return 类代码块中定义的函数，不视为类代码块的闭包，具体例子如下：12345class A: a = 123 def g(): print a g() 会报错，函数g找不到a。 正常的闭包： 12345def func(): a = 123 def g(): print a g() 结果就不会报错 11. super and MRO MRO: Method Resolution Order. For more details see this great introdcution: Python: 你不知道的 super super 的一个最常见用法可以说是在子类中调用父类的初始化方法了，比如： 1234class A(Base): def __init__(self, a, b, c): super(A, self).__init__(a, b) # Python3 可使用 super().__init__(a, b) self.c = c 实际上，super(cls, inst) 获得的是 cls 在 inst 的 MRO 列表中的下一个类。 12. Python Interpreter CPython IPython based on CPython, and is enhanced in interactive. PyPy Use Jit, and can be different with CPython. Jython Compile python to Java bytecode. IronPython Compile python to .net bytecode 13. Python3 String 13.1 unicode All the python3 string is unicode string. e.g.: print('\u5730\u5740\u9519\u8bef')会显示地址错误 NOTE: Unicode is different from utf-8 code! Unicode编码及其实现：UTF-16、UTF-8 Real Unicode Many introduction about unicode is wrong, even for the Baidu Encyclopedia. Japanese: unicode 3040-31FF Unicode(UTF-8, UTF-16)令人混淆的概念 must be read very carefully. Unicode涉及到两个步骤,首先是定义一个规范，第二步才是怎么把字符对应的数字保存在计算机中。 UTF-16就是任何字符对应的数字都用两个字节来保存 UTF-8,这里的8非常容易误导人，用UTF-8时表示一个字符是可变的,有可能是用一个字节表示一个字符,也可能是两个,三个.当然最多不能超过3个字节了。 UTF-32就是把所有的字符都用32bit. UCS就是前面说的ISO制定的标准,和Unicode是完全一样的,只不过名字不一样.ucs-2对应utf-16,ucs-4对应UTF-32.UTF-8是没有对应的UCS. BeautifulSoup4 will automatically find the encoding of HTML page (based on the info in the HTML head), and use this encoding to decode the r.text. However, if encoding is not found, encoding will be considered as “ISO-8859-1”, whether it’s because of failing parse or non-existence, 1234print(r.encoding)text = r.texttext.encode("ISO-8859-1","ignore") == r.content # result is "ISO-8859-1" and "True" two examples: &quot;严&quot;字 &quot;き&quot;字 For “き”: It’s python3 source code is u&quot;\u304D&quot; utf-8 is 0xE3 0x81 0x8D (e3818d); utf-16 is 0x304D (304d); utf-32 is 0x0000304D (304d) HTML Entity (hex) &amp;#x304d; code 123one_char = 'き'print(one_char, one_char.encode("utf-8"),one_char.encode("utf-16"), one_char.encode("utf-32"))print(one_char.encode('unicode_escape'), one_char.encode('unicode_escape').decode('unicode_escape')) 结果如下： 12き b'\xe3\x81\x8d' b'\xff\xfeM0' b'\xff\xfe\x00\x00M0\x00\x00'b'\\u304d' き 13.2 hex decode a hex string 十六进制可以看成一种编码方式。实际使用中，我们一般用到的是hex string，比如ethereum RPC的返回值: res = '0x000000a2' 以res为例，所谓hex string，就是说res在python中的类型还是string，但显然它是一个16进制编码过的string。 那么我们要得到真实信息，就需要解码；要解码，就需要知道res原本是什么类型。(比如0x41，解码成整数，那就是整数65；但按照解码ascii，第65个ascii字符，就是小写字母a) HexBytes type to hex string HexBytes is a built-in type, e.g.: 123from web3 import Web3# web3.__version__ == '4.4.1'res = Web3.sha3(text="numberOfProposals()") The type of res is HexBytes. To get a hex string, just use res.hex(), then a string will be returned. 14. python path There’re two kind of path: executing path (EP) and python file path (PFP). e.g.: 12$ ls test/test_all.py Then EP is ., PFP is ./test/! The sys.path contains PFP, not EP. In from * import *, PEP is used, i.e., it’s ‘from’ ./test/ dir. 一个module应该只有一种方式import 有一种说法是：python中的包只会被import一次 但是，from logger import logger和from log.logger import logger明明是一个module，python却会导入两次！ ref: python中的module不一定是单例，有可能会被多次import成多个module 15. __slots__ First of all, python allow run-time adding attributes and methods to a defined class or a instance of defined class. e.g.: 12345678 # Student is a defined classdef set_score(self, score): self.score = scoreStudent.set_score = set_scores = Student()s.set_score = set_score Then to restrict the attributes, __slots__ is defined so that only the attributes in __slots__ can be defined in class. e.g.: __slots__ = ('name', 'age') # name and age can be defined in present class __slots__ = () # none attribute can be defined. 使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的 除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。 17. myth of code object 探索 Python 代码对象 三个层次：function object -&gt; code object -&gt; stack-based bytecode(字节码) CPython 实现了一个执行基于栈的字节码 (stack-based bytecode) 的虚拟机。 在运行时，任何可执行的东西 (函数、方法、模块、类主体 (class body)、Lambda 式、语句、表达式等等) 都以字节码的形式由 Python 虚拟机执行。 12def f(a = b): print a f的代码块在编译时被编译为一个code object放在字节码中，然后执行到这里的时候，根据这个code object构建一个function object，然后，将这个function object赋值给f这个变量。 function object还含有一些动态的信息，比如函数参数默认值（上面的b），或是否闭包的信息（若f是一个闭包函数）等 19. decorator Decorator is just a syntactic sugar: 12@my_decoratordef func: Above code is just the same as: func = my_decorator(func) basic version 123456789101112131415import timefrom functools import wrapsdef timethis(func): ''' Decorator that reports the execution time. ''' @wraps(func) def wrapper(*args, **kwargs): start = time.time() result = func(*args, **kwargs) end = time.time() print(func.__name__, end-start) return result return wrapper 机理的理解： decorator实际相当于：new_func = timethis(func) timethis返回了wrapper函数，所以new_func实际上就是timethis中的wrapper函数 调用new_func时的参数都传给了wrapper 调用未包装的原始函数： 使用了@wraps或者直接设置了__wrapped__属性，那么new_func.__wrapped__就是原函数 如果有多个包装器，那么访问__wrapped__属性的行为是不可预知的，应该避免这样做。 在Python3.4中，它会如我们预期的一样。 在Python3.3中，它会略过所有的包装层。 Style guide argument **kwargs is a bad practice: you don’t know how **kwargs affect. wrong keywrod arguments is no longer reported by the interpreter. TypeError 'x' is an invalid keyword argument for this function reference:The Use and Abuse of Keyword Arguments in Python 逻辑判断 布尔测试应该很简单,如果它们很复杂的话,你需要将它们的运算事先放到一个变量里,并 且为变量取一个好名字 – [learn python the hard way] add static variable to function There are many different ways to add a static variable in a function. Below one happens to be a good way: 123def func(): if not hasattr(func, 'x'): func.x = "lala" TIPS you need to flush stdout periodically (e.g. sys.stdout.flush()). Python doesn't automatically do this even with print until the program exits. id(WTF()) == id(WTF()) result is True [1] id(WTF()) will (1) instantiate a WTC object and (2) get the id of this object and (3) destroy this object. Hence this two objects has same id. Evaluation time discrepancy 非常重要！ 123456array = [1, 8, 15]g = (x for x in array if array.count(x) &gt; 0)array = [2, 8, 22] #Output: &gt;&gt;&gt; print(list(g))[8] A tic-tac-toe where X wins in the first attempt! 12345678910111213'''我们先初始化一个变量row'''row = [""]*3 #row i['', '', '']board = [row]*3 # 并创建一个变量board #Output: &gt;&gt;&gt; board[['', '', ''], ['', '', ''], ['', '', '']] &gt;&gt;&gt; board[0][0]'' &gt;&gt;&gt; board[0][0] = "X" &gt;&gt;&gt; board[['X', '', ''], ['X', '', ''], ['X', '', '']] Right way to do it is : &gt;&gt;&gt; board = [['']*3 for _ in range(3)] ==的优先级高于not unbounded method不太懂，不过在python3中已经完全抛弃了 check whether a variable is a function isinstance(func, (types.FunctionType, types.BuiltinFunctionType, functools.partial)) thinking Abstact leak永远会存在。 换言之，永远都需要向下一层，去理解当前用到的技术是如何实现的。 以Evaluation time discrepancy为例: for statement has a simple implement, in statement has a simple implement too. 然而，当几个简单的语句组合在一起，复杂性就产生了。除了语言的自洽性和正确性，又需要考虑到性能、异步等问题。 For more: [我眼中一个好的Pythoneer应该具备的品质]*(https://zhuanlan.zhihu.com/p/33266239) Python进阶 - gitbook What the f*ck Python! ↩ ↩]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人工智能简介]]></title>
    <url>%2F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[备忘 三巨头介绍[1]：Geoffrey Hinton、Yann LeCun、Yoshua Bengio（年级由大到小） Hinton 多伦多大学 DBN LeCun CNN Bengio attention、GAN 神经网络简介 技术特点和技巧的备忘 单层线性、双层非线性[2] 隐藏层的参数矩阵的作用就是使得数据的原始坐标空间从线性不可分，转换成了线性可分。 层数的影响[2] 参数数量一样的情况下，更深的网络往往具有比浅层的网络更好的识别效率。这点也在ImageNet的多次大赛中得到了证实。从2012年起，每年获得ImageNet冠军的深度神经网络的层数逐年增加，2015年最好的方法GoogleNet是一个多达22层的神经网络。在最新一届的ImageNet大赛上，目前拿到最好成绩的MSRA团队的方法使用的更是一个深达152层的网络！关于这个方法更多的信息有兴趣的可以查阅ImageNet网站。 BP的缺点[3] 基于梯度下降的反向传播法很容易在训练网络参数时收敛于局部极小值。此外，反向传播法训练网络参数还存在很多实际问题，比如需要大量的标签样本来训练网络的权值，多隐含层的神经网络权值的训练速度很慢，权值的修正随着反向传播层数的增加逐渐削弱等。 面对采用反向传播法来训练具有多隐含层的深度网络的网络参数时存在的缺陷，一部分研究人员开始探索通过改变感知器的结构来改善网络学习的性能，由此产生了很多著名的单隐含层的浅层学习模型，如SVM、logistic regression、Maximum entropy model和朴素贝叶斯模型等。浅层学习模型能够有效地解决简单或者具有复杂条件限制的问题，但受限于只含一个隐含层，所以浅层学习模型特征构造的能力有限，不能有效处理包含复杂特征的问题。 LSTM LSTM只能避免RNN的梯度消失（gradient vanishing）；梯度膨胀(gradient explosion)不是个严重的问题，一般靠裁剪后的优化算法即可解决，比如gradient clipping（如果梯度的范数大于某个给定值，将梯度同比收缩）。[4] 历史节点 1943 W.Pitts &amp; W.McCulloch: Concept of ANN(Artificial Neural Network)[3] 1949 D. Olding Hebb: math model 1957 F.Rosenblatt: Perceptron 1969 arvin Minsky &amp; Seymour Papert: Perceptron’s inability of XOR &amp; limitation of computing power 1974 Paul Werbos: BP(Back Propagation) 1980 Hinton: MLP(Multi_Layer Perceptron) 1982 John Hopfield: Hopfield Network(pioneer RNN) 1998 LeCun: CNN(Convoluted Neural Network) 2006 Hinton, &lt;&gt; DBN(Deep Belief Networks) 2012[2] 深度学习技术又在图像识别领域大展拳脚。Hinton与他的学生在ImageNet竞赛中，用多层的卷积神经网络成功地对包含一千类别的一百万张图片进行了训练，取得了分类错误率15%的好成绩，这个成绩比第二名高了近11个百分点， Jeff Dean &amp; Andrew Ng in GoogleBrain: “the Cat” 名词概念 activation function[2] 【示意效果】 capcity[2] 更多的参数意味着其模拟的函数可以更加的复杂，可以有更多的容量（capcity）去拟合真正的关系。 curse of dimensionality（维数灾祸）[5] 在机器学习里是指随着样本空间和参数空间维数的增加，潜在参数组合的数量指数型增长，相同精确度的预测会需要多得多的训练样本。当训练样本不变时，预测的精度与空间维数的增加成反比。 DBN(深度信念网络) generalization[2] 提升模型在测试集上的预测效果的主题叫做泛化 Grid Search（网格搜索：用尝试的方法选择中间层的节点数）[2] regularization[2] 相关方法被称作正则化。神经网络中常用的泛化技术有权重衰减等。 schools of AI(译为学派)[6] 符号主义(symbolicism)，又称为逻辑主义(logicism)、心理学派(psychologism)或计算机学派(computerism)，其原理主要为物理符号系统(即符号操作系统)假设和有限合理性原理。认为人工智能源于数理逻辑。 连接主义(connectionism)，又称为仿生学派(bionicsism)或生理学派(physiologism)，其主要原理为神经网络及神经网络间的连接机制与学习算法。认为人工智能源于仿生学，特别是对人脑模型的研究。 行为主义(actionism)，又称为进化主义(evolutionism)或控制论学派(cyberneticsism)，其原理为控制论及感知-动作型控制系统。认为人工智能源于控制论。(认为人工智能源于仿生学，特别是对人脑模型的研究。) Training Set, Validation Set and Testing Set; Ground Truth 验证数据用于最小化过拟合(overfitting)。 这数据不调整权重和偏差。在基于训练数据调整权重之后，如果基于训练数据的准确度增加了，而基于验证数据的准确度没有增加或反而下降了，则表明过拟合（overfitting）了，需要立即停止训练。[7] Ground Truth: 正确标注的数据是Ground Truth， 错误的标记则不是。（也有人将所有标注数据都叫做Ground Truth）[7] NN RNN 什么是 LSTM RNN 更多介绍 DNN optimization 待读 link link tips About Why pretraining for DNN is not specified in keras? framework &amp; software Deepchem Developed by Vijia Panda &amp; Schrodinger Company. deepcheem Modeling Small Molecule Toxicity with Graph Convolutions (An Official Example) 刚看完In [2]:部分。 DeepMD-kit 技术评论 技术成熟的条件 Andrew Ng[8] 一个新科技的出现要掐着时间，不能太早也能太晚。比如说iphone，2007年才是它发布的正确时间，而不是在1993年，因为那时的芯片，电池，屏幕技术还没到位。 另外一个极端的例子是达芬奇发明直升机，他发明直升机的时间是1480年代，而飞机引擎技术在1900年代才出现。 还有自动驾驶技术，2007年研究自动驾驶技术还太早，因为AI要用到的传感器还没生产出来。2015年以后，整个自动驾驶的生态系统才算比较完善。 同样在1990年代，网络，视频流还不足以支撑慕课问世，到2011年，整个网络基础建设才为在线视频教育提供了较好的环境。 深度学习也是，90年代数据/计算比较小，浅层算法效果更好。从2007开始，有了大数据做基础，深度学习才取得了更好的效果。 但是，我们还是要感谢历史中所有的革新者，包括早期的那些人，他们的工作对后来的发展进步也非常具有影响和帮助。【现在不叫座，以后可能叫好】 《Deep learning》（花书）笔记 第二章 线性代数 总结： 2.8 SVD、2.10 trace的性质不熟悉；2.9 Moore-Penrose很难理解；2.11 PCA是从“压缩”这个目的，推导出方法，很难；如果从PCA方法出发来看其目的，则很简单，但是花书没有这样做，这对入门的人并不友好。 关于迹 迹是特征值的和； 迹是一种线性算子： tr(A + B) = tr(A) + tr(B) tr(rA) = r tr(A) 几何上 迹的几何意义是什么？ - 傅渥成的回答 - 知乎： Geometrically, the trace can be interpreted as the infinitesimal change in volume (as the derivative of the determinant), which is made precise in Jacobi’s formula. 以三维矩阵为例： $$V=aX_1\cdot bX_2 \cdot cX_3$$，那么 $$ \sum_{i=1}^{3} \frac{\partial V}{\partial X_i}=a + b + c $$ 第三章 概率与信息论 reference 历史 a brief history of maching learning(机器学习简史) 【已读】 可读 colah blog book: Deep learning(Ian. Goodfellow) [book: Neural networks and deep learning(Michael Nielsen)] (www.deeplearningbook.org/) Yoshua Bengio为什么能跟Hinton、LeCun相提并论？ 包含学术传承与贡献的讨论 ↩ 历史|从神经元到深度学习 【可再读】 ↩ ↩ ↩ ↩ ↩ ↩ ↩ ↩ 深度学习技术发展历史及应用现状如何？ ↩ ↩ LSTM如何来避免梯度弥散和梯度爆炸？ ↩ 神经网络的历史？ ↩ 人工智能学派简介 ↩ Training Set, Validation Set 和Testing Set之间的差别及关系 ↩ ↩ 【干货|持更】人工智能产业的相关资料及入门指南 【已读】 ↩]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shadownsocks备忘]]></title>
    <url>%2Fshadowsocks%E5%A4%87%E5%BF%98%2F</url>
    <content type="text"><![CDATA[备忘 官网 OS X: 用ShadowsocksX iOS: Wingy windows: Shadowsocks-Qt，可以用二维码进行设置 PAC 代理自动配置（Proxy auto-config，简称PAC）是一种网页浏览器技术，用于定义浏览器该如何自动选择适当的代理服务器来访问一个网址。 用户规则会在在线更新PAC时自动添加，如果不能在线更新，还是直接加在gfwlist.js文件里[1]。然而我的Mac上加在gfwlist.js文件里也不好使。 只是把规则写到了用户规则文件user-rule.txt，但是并没有写到PAC文件gfwlist.js文件里呀，那要如何才能写到PAC文件里呢？简单，在线更新一次PAC文件即可，每次在线更新PAC文件，都会把用户规则文件的内容，写入PAC规则的末尾。 optimization for Debian sysctl -p /etc/sysctl.d/local.conf sysctl --system reference 各种系统下Shadowsocks客户端的安装与配置 Shadowsocks-GUI For Mac OS使用指南 ↩]]></content>
      <categories>
        <category>shadownsocks</category>
      </categories>
      <tags>
        <tag>shadownsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git笔记]]></title>
    <url>%2Fgit%2F</url>
    <content type="text"><![CDATA[git 开始 非常好的入门: 非常好的入门1[1]: 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 非常好的入门2 help git help &lt;verb&gt; init config 123git config --global user.name "your name"git config --global user.email "your email"git config --global core.editor "vim #set vim as editor 列出设置的config git config --list difftool git config --global diff.tool bc3 没有默认的difftool，如果首次输入命令git difftool，CentOS会自动推荐kompare。 12Viewing: &apos;particles/BinReader.cc&apos;Launch &apos;kompare&apos; [Y/n]: y kompare的效果非常好。 completion by bash-completion[2] 操作 add filename commit git commit -m &quot;your message&quot; Amending the most recent commit message[3] git commit --amend will open your editor, allowing you to change the commit message of the most recent commit. Additionally, you can set the commit message directly in the command line with: git commit --amend -m &quot;New commit message&quot; …however, this can make multi-line commit messages or small corrections more cumbersome to enter. Make sure you don’t have any working copy changes staged before doing this or they will get committed too. (Unstaged changes will not get committed.) clone git clone /path/to/repository 如果是远端服务器上的仓库，你的命令会是这个样子： git clone username@host:/path/to/repository git clone git@github.com:dunitian/Windows10.git &quot;F:/Work/WP/Windows10&quot; #到指定文件夹 git clone -b your_branch your_repo #指定branch push git push origin master:master origin is the remote server; the branch name before the colon is local branch name, and that after the colon is remote branch name. e.g.: 12git push origin HEAD:refs/for/branch1 # push HEAD branch to a remote branch git push origin :refs/for/branch1 # delete remote branch checkout git checkout hexo myfile 从hexo分支得到myfile git checkout -b dev #-b参数表示创建并切换 git checkout -b dev your_SHA1 # 创建并切换到your_SHA1 commit git checkout master git checkout --track local_branch origin/remote_branch create a local branch based on a remote-tracking branch. (In recent versions of git the “–track” option is actually unnecessary since it’s implied when the final parameter is a remote-tracking branch, as in this example.)][4] The “–track” option sets up some configuration variables that associate the local branch with the remote-tracking branch. These are useful chiefly for two things: They allow git pull to know what to merge after fetching new remote-tracking branches. If you do git checkout to a local branch which has been set up in this way, it will give you a helpful message such as: Your branch and the tracked remote branch 'origin/master’ have diverged, and respectively have 3 and 384 different commit(s) each. stash[5] 储藏会处理工作目录的脏的状态 - 即，修改的跟踪文件与暂存改动 - 然后将未完成的修改保存到一个栈上，而你可以在任何时候重新应用这些改动。 git stash 临时存储当前状态 git stash list git stash apply (--index) 找回临时存储的状态 git stash drop 删除stash branch git merge dev 合并指定分支到当前分支 git branch -d dev #删除 git branch -r/-a # 查看远程/所有分支； git branch 查看本地分支 git checkout mybfranch # shift to another branch pull git pull origin master相当于git fetch origin # fetch to local repo加上git merge origin/master # origin master shall be in local repo fetch git fetch origin hexo从remote repo获取名为hexo的branch 丢弃 git rm (then git commit) git rm --cached file_a 从stage中删除 git rm file_a 从stage中删除，同时删除物理文件 git mv file_a file_b git checkout -- file (other functions about checkout is discribed above ) git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： git checkout -- test.txt 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 reset git reset --hard HEAD^ git reset --hard 3628164 显示状态 status log git log --oneline --decorate # 加上--decorate 时，我们可以看到我们的标签 git log remotename/branchname # get remote commit. e.g., git log origin/hexo Will display the log of a given remote branch in that repository, but only the logs that you have “fetched” from their repository to your personal “copy” of the remote repository. reflog 查看历史命令 与git log的区别：显示整个本地仓储的commit, 包括所有branch的commit, 甚至包括已经撤销的commit, 只要HEAD发生了变化, 就会在reflog里面看得到。 git log只包括当前分支的commit. remote 看当前配置有哪些远程仓库，可以用命令 git remote 执行时加上 -v 参数，你还可以看到每个别名的实际链接地址。 git ls-files #ls files in present branch git ls-files -u #显示冲突的文件，-s是显示标记为冲突已解决的文件 diff git diff #对比工作区和stage文件的差异 git diff --cached 对比stage和branch之间的差异 git diff master remotes/origin/hexo #对比本地“master” branch和远程 &quot;remotes/origin/hexo&quot; branch git diff origin/hexo #对比当前working tree和远程branch rebase git rebase 用法 stackoverflow Git-rebase 小筆記 很好 git rebase --skip git rebase --continue #use this when you solved conflicts. git rebase --abort #放弃当前rebase tag git tag &lt;tagname&gt; git tag &lt;tagname&gt; -a add an annotated tag git push origin --tags show git show HEAD~4:altcoin_spot_future_hedging.py 显示HEAD之前的第四个commit中altcoin_spot_future_hedging.py文件的内容 其他概念与原理 conflict Resolving a merge conflict using the command line remote remote是一个相对的概念，一个存储在本地其他文件夹的repo也可以是remote[4] “remotes” are just nicknames for other repositories, synonymous with a URL or the path of a local directory – you can set up extra remotes yourself with “git remote”, but “git clone” by default sets up “origin” for you. origin It’s a repo! 顾名思义，origin就是一个名字，它是在你clone一个托管在Github上代码库时，git为你默认创建的指向这个远程代码库的标签。 git remote add https://github.com/TimChen314/TimChen314.github.io.git # You can set # set origin by yourself (远程仓库名)/(分支名) 这样的形式表示远程分支 Note that when git branch -a is used, there is ‘remote’ in front of branch name, e.g.: 1234$ git branch -r orgin/master $ git branch -a remote/origin/master local_branch_name:remote_branch_name # 这是push，pull的时候顺序反过来 远程分支和本地分支的名字相同，可以省略远程分支的名字 refspec &lt;source-name&gt;:&lt;destination-name&gt; is a refspec upstream vs. origin upstream vs. origin This should be understood in the context of GitHub forks (where you fork a GitHub repo at GitHub before cloning that fork locally) upstream generally refers to the original repo that you have forked (see also “Definition of “downstream” and “upstream”” for more on upstream term) origin is your fork: your own repo on GitHub, clone of the original repo of GitHub branch &amp; hash[6] you need to understand that branch and tag names are just pointers to hash values, which represent a single commit only two types of branches, and they are storaged in[4]: 12.git/refs/heads/ #[for local branches] **only hash in the file**.git/refs/remotes/ #[for tracking branches] Local branches Remote-tracking branches tips git clone下载慢 git config --global http.postBuffer 524288000 hub 在终端中输入 $ hub browse，它将直接在浏览器中自动地打开 git 仓库的 URL。Boom！ Make the current commit the only (initial) commit in a Git repository? about github [how to bring up an issue?](hoomd Build_NP_reaction.shhoomd Build_NP_reaction.sh) 错误 prompt to input passphrase time and time again: Git enter long passphrase for every push Note that you can use ssh-key only if you use ssh to build remote connections. git remote -v should looks like: origin git@github.com:TimChen314/MDTackle.git (fetch) but not: origin https://github.com/TimChen314/MDTackle.git Can’t push to GitHub because of large file which I already deleted A git branch is a chain of commits, e.g., c-base -&gt; c1 -&gt; c2 -&gt; c3 … If uploading c1 failed, then even you fix the problem in c2 and c3, the uploading will still fail because of c1. reference 超好: git cheatsheet 常用git Removing sensitive data from a repository Git 工作区、暂存区和版本库 ↩ git命令自动补全 ↩ How to modify existing, unpushed commits? ↩ GIT: FETCH AND MERGE, DON’T PULL ↩ ↩ ↩ 6.3 Git 工具 - 儲藏 ↩ What’s the difference between git reset --hard master and git reset --hard origin/master? ↩]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdf5简介]]></title>
    <url>%2Fhdf5%2F</url>
    <content type="text"><![CDATA[HDF5 可以存储不同类型的图像和数码数据的文件格式，同时还有统一处理这种文件格式的函数库。 历史 HDF(Hierarchical Data File)是美国国家高级计算应用中心(National Center for Supercomputing Application,NCSA)为了满足各种领域研究需求而研制的一种能高效存储和分发科学数据的新型数据格式。1998年，发布HDF5版本。迄今为5.1版，已经非常稳定。 特性 自述性 对于一个HDF文件里的每一个数据对象，有关于该数据的综合信息（元数据）。在没有任何外部信息的情况下，HDF允许应用程序解释HDF文件的结构和内容。 通用性 许多数据类型都可以被嵌入在一个HDF文件里。例如，通过使用合适的HDF数据结构，符号、数字和图形数据可以同时存储在一个HDF文件里。 灵活性 HDF允许用户把相关的数据对象组合在一起，放到一个分层结构中，向数据对象添加描述和标签。它还允许用户把科学数据放到多个HDF文件里。 扩展性 HDF极易容纳将来新增加的数据模式，容易与其他标准格式兼容。 跨平台性 现代性 支持并行I/O，线程和其他一些现代系统和应用要求。 解决我的trajectory程序的问题：自述性、通用性、扩展性 Why HDF? 有专门的维护： hdfgroup.org NASA’s Earth Observing System等等官网介绍 Caffe等机器学习、深度学习框架原生支持 文档 sphinx 它能够把一组 reStructuredText 格式的文件转换成各种输出格式，而且自动地生成交叉引用，生成目录等。也就是说，如果有一个目录，里面包含一堆reST格式的文档（可能子目录里面也同样存在reST格式的文档），Sphinx能够生成一个漂亮的组织结构以及便于浏览和导航的HTML 文件（这些文件在其他的文件夹中）。 Sphinx介绍：https://zhuanlan.zhihu.com/p/25688826 中文文档：https://zh-sphinx-doc.readthedocs.io/en/latest/index.html# 再通过github部署（专门为生成程序介绍页而设计的功能）：https://segmentfault.com/a/1190000002765287]]></content>
      <categories>
        <category>技术杂烩</category>
      </categories>
      <tags>
        <tag>技术杂烩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Story of Terminal]]></title>
    <url>%2FStory_of_Terminal%2F</url>
    <content type="text"><![CDATA[总结 从本地到远程sever，经过了多个编码环节。从按下一个键到远程server最终反应，经历的过程： 本地terminal类型和编码 -&gt; linux下terminal类型和编码 ctrl+h的编码 ascii中Backspace的值为010（八进制），而ASCII values can be represented in several equivalent ways. 而ctrl+h的值也为010。 terminal区分不了二者，因此输入以ascii编码，则ctrl+h变为Backspace；而输入不以ascii编码，Backspace也会显示成^H，即ctrl+h F1键 terminal类型的选择也会影响快捷键。 Xshell中，文件–属性–键盘–功能键类型 选择xterm R6，则VIM中可以绑定F1；如果选linux，则不可以 问题： 为什么BS无法删除，而是想左移动？ 为什么在执行程序进行输入时，按下BS显示的是^H? vimrc 123set fileencodings=utf-8,gb2312,gb18030,gbk,ucs-bom,cp936,latin1set encoding=utf-8set termencoding=utf-8 In debian (My Japan VPS), you must relog to enable this. 答案 知乎： 1早在 VT100终端时代，^H（ASCII码 0x08）表示&lt;BS&gt; 而 ^? （ASCII码 0x7f）表示&lt;DEL&gt;。过去 0x7f是留给 DELETE键使用的。而到了 VT220时代，DELETE已经变为 ^[[3~ （ASCII 码 0x1b, 0x5b, 0x33, 0x7e 共4个字节），而 ^? 的 0x7f 换给了我们的&lt;BS&gt;，有些老点版本的终端软件，默认 &lt;BS&gt;还是使用 VT100的 ^H，比如 Xshell 4 Build 0142以前的版本，默认&lt;BS&gt;是发送^H。SecureCRT直到6.x版本还在默认发送 VT100的 ^H。 Terminal VT100 Xterms on the other hand, emulate the vt100 terminal, which didn’t have a [Delete]. 123456789101112VT100Key KeySymName Console characters -------------------------------------------------- Ctrl+H ---&gt; Control_H ---&gt; ASCII BS (0x08) [&lt;---] ---&gt; Backspace ---&gt; ASCII DEL (0x7F) --------------------------------------------------Xterm&apos;s emulation of VT100Key KeySymName Console characters -------------------------------------------------- Ctrl+H ---&gt; Control_H ---&gt; ASCII BS (0x08) [&lt;---] ---&gt; Backspace ---&gt; ASCII BS (0x08) [Delete] ---&gt; Delete ---&gt; ASCII DEL (0x7F) VT series have their own keyboard: http://www.vt100.net/ wikipedia: A personal computer can run** terminal emulator** software that replicates the function of a terminal, sometimes allowing concurrent use of local programs and access to a distant terminal host system.]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>编码</tag>
        <tag>Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo]]></title>
    <url>%2Fhexo%2F</url>
    <content type="text"><![CDATA[memo 这个网站可以作为参考www.ezlippi.com npm i(nstall) hexo-generator-json-content --save Fix error to ensure “all article” works normally. hexo-footnote(已不再维护) npm install hexo-footnotes --save 如果Hexo不能自动发现插件，则需要手动安装插件5，编辑_config.yml文件： 12plugins: - hexo-footnotes 安装hexo-renderer-marked以支持更多Markdown特性 123npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --savenpm install markdown-it-emoji --save 设置文章置顶 &amp; Cloudinary在线图片服务[1] top: 3 # 数字越大越靠前，默认为0 除了在本地存储图片，还可以将图片上传到一些免费的CDN服务中。比如Cloudinary提供的图片CDN服务，在Cloudinary中上传图片后，会生成对应的url地址，将地址直接拿来引用即可。 在Cloudinary申请账号，上传图片(注意把upload选项中的unsigned signature选上) Cloundinary的免费存储空间还是非常大的cloudinary价格 我的cloudinary 使用方法： 点击图片 点击url 拷贝链接 hexo个人命令 用hexol/hexod命令一次性完成本地/远程预览 配置.bash_profile: 1234export HEXO='/Users/Aether/Documents/hexo_file'export HEXOMD='/Users/Aether/Documents/hexo_file/source/_posts/'alias hexod='cd $HEXOMD &amp;&amp; sh tackle_md.sh &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo deploy'alias hexol='cd $HEXOMD &amp;&amp; sh tackle_md.sh &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo s' tackle_md.sh自动调整缩进、设置部分显示(for next theme) 1234#!/bin/shsh indent.shsh read_more.sh 其中，indent.sh: 12345#!/bin/sh# indent for code blocksed -i 's/^```[a-z]/ &amp;/g' *.md# indent for quotesed -i 's/^&gt;/ &amp;/g' *.md read_more.sh: 12345678910#!/bin/sh# if no "&lt;!-- more --&gt;" in *.md file, adding it into the file.for md_file in $(ls *md)do stat=$(grep "&lt;!-- more --&gt;" $md_file) if [ -z "$stat" ];then sed -i '20a &lt;!-- more --&gt;' $md_file fidone yilia theme image file path hexo_file/themes/hexo-theme-yilia/source/img theme-yilia yilia next theme 要想显示标签页，需要手动操作，详见[2] 添加搜索[3] 在os X safari上无法正常使用，原因不明；在os X chrome上和win7 chrome上都可以正常使用 12npm install hexo-generator-search --savenpm install hexo-generator-searchdb --save 如何设置页面文章的篇数？[4] 123npm install --save hexo-generator-indexnpm install --save hexo-generator-archivenpm install --save hexo-generator-tag 设置social_icons next是通过FontAwesome进行图标设计的，FA支持的图标都在主页上。 目前FA不支持知乎，所以随便选了个fa-bed作为icons。设置中写为zhihu: bed 设置文章标题的格式[5] 直接用html就可以 title: &lt;font size=6&gt;&lt;b&gt;人工智能简介 next themes的配置文件在themes/next/source/css/_variables/custom.styl 12$font-size-headings-base = 28px$font-size-headings-step = 2px mathjax hexo-renderer-mathjax: haven’t maintained since 2016. npm install hexo-math --save Example: Simple inline $a_{i} = b_{i} + c_{i}$. $$\frac{\partial u}{\partial t} = h^2 \left( \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} + \frac{\partial^2 u}{\partial z^2}\right)$$ more available setting Hexo文章简单加密访问 静态网站计数 hexo bug Error: Cannot find module './build/Release/DTraceProviderBindings' in OS X npm install hexo --no-optional doesn’t work npm un hexo-cli &amp;&amp; npm i hexo-cli -g still encounts bugs, and it’s about dtrace-provider. Then we try to install dtrace-provider: Error: Python executable anaconda3/bin/python is v3.5.2, which is not supported by gyp. If PYTHON=python2.7 npm install dtrace-provider --save is used then a new bug will be reported: xcode-select: error: tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instance This is an error about Xcode, solution link Finally, this DTrace error is solved. References: HEXO搭建个人博客 2个小时教你hexo博客添加评论、打赏、RSS等功能 从搭建hexo个人博客过程中理解学习DNS解析 Hexo Configuration ↩ Next-主题配置 ↩ 参考：Hexo博客添加站内搜索 ↩ Next-常见问题 ↩ set title size ↩]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>yilia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云邮箱设置记录]]></title>
    <url>%2Fali_mail_set%2F</url>
    <content type="text"><![CDATA[正文 在阿里云买了域名，阿里云正好（2017-07）有免费赠邮箱服务，所以想把这个邮箱服务用起来。 登录阿里云–&gt;控制台–&gt;域名与网站(左侧菜单栏中)–&gt;企业邮箱–&gt;登录管理员账号(用postmaster@yoursite.com这个账号登录https://qiye.aliyun.com/admin/,这里是负责管理邮箱系统) qiye.aliyun.com/admin/中会显示 邮箱登录地址:http://mail.timchen314.com 访问http://mail.timchen314.com: 温馨提醒：该页面暂时无法访问 尊敬的用户： 您好！ 根据《非经营性互联网信息服务备案管理办法》第十八条法规，您的域名尚未进行备案，暂时无法访问。请参考工信部相关备案流程进行相关操作。 所以，必须要备案后才能使用邮箱服务。 ICP备案是：[1] ICP备案的含义是主机、站长（个人或者法人）、域名和网站经营内容四者的一个绑定认证关系 如果使用了github作为托管主机，是无法备案的。如何选择备案产品类型 如您购买的是其他服务商空间，请联系对应的空间提供商备案；如自己架设服务器，需要联系您服务器的网络供应商，即提供您服务器上网服务的运营商，如电信、联通等。 可能有用[2] reference 阿里云个人网站备案过程全记录 ↩ 可能有用：本博客阿里云配置过程（一）服务器及域名备案篇 ↩]]></content>
      <categories>
        <category>技术杂烩</category>
      </categories>
      <tags>
        <tag>技术杂烩</tag>
        <tag>邮箱设置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown in hexo-render-markdown-it]]></title>
    <url>%2Fmarkdown_in_hexo%2F</url>
    <content type="text"><![CDATA[The implementation of Markdown in different software are always different here or there. To testify the implementation of hexo, syntax page of Mou is pasted in here for comparison. In summary, only inline image is unavailable. PS: spacing can add indent; and code block &amp; quote wouldn’t indent automatically. so indent.sh is used Could add spacing manually by &amp;nbsp; #半角的不断行的空白格 (it works in header, too) &lt;br/&gt; as line break Bug 有时候ordered list序号大于等于10，缩进会失效。 目录不能正常显示，如vim笔记.md Mou Overview Mou, the missing Markdown editor for web developers. Syntax Strong and Emphasize strong or strong ( Cmd + B ) emphasize or emphasize ( Cmd + I ) Sometimes I want a lot of text to be bold. Like, seriously, a LOT of text Blockquotes Right angle brackets &gt; are used for block quotes. Links and Email An email example@example.com link. Simple inline link http://chenluois.com, another inline link Smaller, one more inline link with title Resize. A reference style link. Input id, then anywhere in the doc, define the link with corresponding id: Titles ( or called tool tips ) in the links are optional. Images An inline image , title is optional. A reference style image. Inline code and Block code Inline code are surround by backtick key. To create a block code: Indent each line by at least 1 tab, or 4 spaces. var Mou = exactlyTheAppIwant; Ordered Lists Ordered lists are created using “1.” + Space: Ordered list item Ordered list item Ordered list item Unordered Lists Unordered list are created using “*” + Space: Unordered list item Unordered list item Unordered list item Or using “-” + Space: Unordered list item Unordered list item Unordered list item Hard Linebreak End a line with two or more spaces will create a hard linebreak, called &lt;br /&gt; in HTML. ( Control + Return ) Above line ended with 2 spaces. Horizontal Rules Three or more asterisks or dashes: Headers Setext-style: This is H1 This is H2 atx-style: This is H1 This is H2 This is H3 This is H4 This is H5 This is H6 Extra Syntax Footnotes Footnotes work mostly like reference-style links. A footnote is made of two things: a marker in the text that will become a superscript number; a footnote definition that will be placed in a list of footnotes at the end of the document. A footnote looks like this: That’s some text with a footnote.[1] Strikethrough Wrap with 2 tilde characters: Strikethrough Fenced Code Blocks Start with a line containing 3 or more backticks, and ends with the first line with the same number of backticks: 123Fenced code blocks are like Stardard Markdown’s regular codeblocks, except that they’re not indented and instead rely ona start and end fence lines to delimit the code block. Tables A simple table looks like this: First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell If you wish, you can add a leading and tailing pipe to each line of the table: First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell Specify alignment for each column by adding colons to separator lines: First Header Second Header Third Header Left Center Right Left Center Right More test for hexo-renderer-markdown-it hexo-renderer-markdown-it uses plugins such as markdown-it-sup to implement superscript. all plugins to use a plugin you need npm i plugin-name --save add plugin-name into _config.yml in plugins: part of markdown-it config example superscript: 29^th^ -&gt; 29th subscript: H~2~O -&gt; H2O ==highlight== -&gt; highlight ++inserted++ -&gt; inserted abbrevation The HTML specification is maintained by the W3C And that’s the footnote. ↩]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>