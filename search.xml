<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Story of Terminal]]></title>
    <url>%2F2017%2F07%2F29%2FStory_of_Terminal%2F</url>
    <content type="text"><![CDATA[总结 从本地到远程sever，经过了多个编码环节。从按下一个键到远程server最终反应，经历的过程： 本地terminal类型和编码 -&gt; linux下terminal类型和编码 ctrl+h的编码 ascii中Backspace的值为010（八进制），而ASCII values can be represented in several equivalent ways. 而ctrl+h的值也为010。 terminal区分不了二者，因此输入以ascii编码，则ctrl+h变为Backspace；而输入不以ascii编码，Backspace也会显示成^H，即ctrl+h F1键 terminal类型的选择也会影响快捷键。 Xshell中，文件–属性–键盘–功能键类型 选择xterm R6，则VIM中可以绑定F1；如果选linux，则不可以 问题： 为什么BS无法删除，而是想左移动？ 为什么在执行程序进行输入时，按下BS显示的是^H? 答案 知乎： 1早在 VT100终端时代，^H（ASCII码 0x08）表示&lt;BS&gt; 而 ^? （ASCII码 0x7f）表示&lt;DEL&gt;。过去 0x7f是留给 DELETE键使用的。而到了 VT220时代，DELETE已经变为 ^[[3~ （ASCII 码 0x1b, 0x5b, 0x33, 0x7e 共4个字节），而 ^? 的 0x7f 换给了我们的&lt;BS&gt;，有些老点版本的终端软件，默认 &lt;BS&gt;还是使用 VT100的 ^H，比如 Xshell 4 Build 0142以前的版本，默认&lt;BS&gt;是发送^H。SecureCRT直到6.x版本还在默认发送 VT100的 ^H。 Terminal VT100 Xterms on the other hand, emulate the vt100 terminal, which didn’t have a [Delete]. 123456789101112VT100Key KeySymName Console characters -------------------------------------------------- Ctrl+H ---&gt; Control_H ---&gt; ASCII BS (0x08) [&lt;---] ---&gt; Backspace ---&gt; ASCII DEL (0x7F) --------------------------------------------------Xterm&apos;s emulation of VT100Key KeySymName Console characters -------------------------------------------------- Ctrl+H ---&gt; Control_H ---&gt; ASCII BS (0x08) [&lt;---] ---&gt; Backspace ---&gt; ASCII BS (0x08) [Delete] ---&gt; Delete ---&gt; ASCII DEL (0x7F) VT series have their own keyboard: http://www.vt100.net/ wikipedia: A personal computer can run** terminal emulator** software that replicates the function of a terminal, sometimes allowing concurrent use of local programs and access to a distant terminal host system.]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>编码</tag>
        <tag>Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdf5简介]]></title>
    <url>%2F2017%2F07%2F29%2Fhdf5%2F</url>
    <content type="text"><![CDATA[HDF5 可以存储不同类型的图像和数码数据的文件格式，同时还有统一处理这种文件格式的函数库。 历史 HDF(Hierarchical Data File)是美国国家高级计算应用中心(National Center for Supercomputing Application,NCSA)为了满足各种领域研究需求而研制的一种能高效存储和分发科学数据的新型数据格式。1998年，发布HDF5版本。迄今为5.1版，已经非常稳定。 特性 自述性 对于一个HDF文件里的每一个数据对象，有关于该数据的综合信息（元数据）。在没有任何外部信息的情况下，HDF允许应用程序解释HDF文件的结构和内容。 通用性 许多数据类型都可以被嵌入在一个HDF文件里。例如，通过使用合适的HDF数据结构，符号、数字和图形数据可以同时存储在一个HDF文件里。 灵活性 HDF允许用户把相关的数据对象组合在一起，放到一个分层结构中，向数据对象添加描述和标签。它还允许用户把科学数据放到多个HDF文件里。 扩展性 HDF极易容纳将来新增加的数据模式，容易与其他标准格式兼容。 跨平台性 现代性 支持并行I/O，线程和其他一些现代系统和应用要求。 解决我的trajectory程序的问题：自述性、通用性、扩展性 Why HDF? 有专门的维护： hdfgroup.org NASA’s Earth Observing System等等官网介绍 Caffe等机器学习、深度学习框架原生支持 文档 sphinx 它能够把一组 reStructuredText 格式的文件转换成各种输出格式，而且自动地生成交叉引用，生成目录等。也就是说，如果有一个目录，里面包含一堆reST格式的文档（可能子目录里面也同样存在reST格式的文档），Sphinx能够生成一个漂亮的组织结构以及便于浏览和导航的HTML 文件（这些文件在其他的文件夹中）。 Sphinx介绍：https://zhuanlan.zhihu.com/p/25688826 中文文档：https://zh-sphinx-doc.readthedocs.io/en/latest/index.html# 再通过github部署（专门为生成程序介绍页而设计的功能）：https://segmentfault.com/a/1190000002765287]]></content>
      <categories>
        <category>技术杂烩</category>
      </categories>
      <tags>
        <tag>技术杂烩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shadownsocks备忘]]></title>
    <url>%2F2017%2F07%2F29%2Fshadowsocks%E5%A4%87%E5%BF%98%2F</url>
    <content type="text"><![CDATA[备忘 官网 OS X: 用ShadowsocksX iOS: Wingy windows: Shadowsocks-Qt，可以用二维码进行设置 reference 各种系统下Shadowsocks客户端的安装与配置]]></content>
      <categories>
        <category>shadownsocks</category>
      </categories>
      <tags>
        <tag>shadownsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人工智能简介]]></title>
    <url>%2F2017%2F07%2F29%2F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[备忘 三巨头介绍[1]：Geoffrey Hinton、Yann LeCun、Yoshua Bengio（年级由大到小） Hinton 多伦多大学 DBN LeCun CNN Bengio attention、GAN 神经网络简介 技术备忘 单层线性、双层非线性[2] 隐藏层的参数矩阵的作用就是使得数据的原始坐标空间从线性不可分，转换成了线性可分。 层数的影响[2] 参数数量一样的情况下，更深的网络往往具有比浅层的网络更好的识别效率。这点也在ImageNet的多次大赛中得到了证实。从2012年起，每年获得ImageNet冠军的深度神经网络的层数逐年增加，2015年最好的方法GoogleNet是一个多达22层的神经网络。在最新一届的ImageNet大赛上，目前拿到最好成绩的MSRA团队的方法使用的更是一个深达152层的网络！关于这个方法更多的信息有兴趣的可以查阅ImageNet网站。 BP的缺点[3] 基于梯度下降的反向传播法很容易在训练网络参数时收敛于局部极小值。此外，反向传播法训练网络参数还存在很多实际问题，比如需要大量的标签样本来训练网络的权值，多隐含层的神经网络权值的训练速度很慢，权值的修正随着反向传播层数的增加逐渐削弱等。 面对采用反向传播法来训练具有多隐含层的深度网络的网络参数时存在的缺陷，一部分研究人员开始探索通过改变感知器的结构来改善网络学习的性能，由此产生了很多著名的单隐含层的浅层学习模型，如SVM、logistic regression、Maximum entropy model和朴素贝叶斯模型等。浅层学习模型能够有效地解决简单或者具有复杂条件限制的问题，但受限于只含一个隐含层，所以浅层学习模型特征构造的能力有限，不能有效处理包含复杂特征的问题。 历史节点 1943 W.Pitts &amp; W.McCulloch: Concept of ANN(Artificial Neural Network)[3] 1949 D. Olding Hebb: math model 1957 F.Rosenblatt: Perceptron 1969 Marvin Minsky &amp; Seymour Papert: Perceptron’s inability of XOR &amp; limitation of computing power 1974 Paul Werbos: BP(Back Propagation) 1980 Hinton: MLP(Multi_Layer Perceptron) 1982 John Hopfield: Hopfield Network(pioneer RNN) 1998 LeCun: CNN(Convoluted Neural Network) 2006 Hinton, &lt;&gt; DBN(Deep Belief Networks) 2012[2] 深度学习技术又在图像识别领域大展拳脚。Hinton与他的学生在ImageNet竞赛中，用多层的卷积神经网络成功地对包含一千类别的一百万张图片进行了训练，取得了分类错误率15%的好成绩，这个成绩比第二名高了近11个百分点， Jeff Dean &amp; Andrew Ng in GoogleBrain: “the Cat” 名词概念 Grid Search（网格搜索：用尝试的方法选择中间层的节点数）[2] generalization[2] 提升模型在测试集上的预测效果的主题叫做泛化 regularization[2] 相关方法被称作正则化。神经网络中常用的泛化技术有权重衰减等。 capcity[2] 更多的参数意味着其模拟的函数可以更加的复杂，可以有更多的容量（capcity）去拟合真正的关系。 DBN(深度信念网络) activation function[2] 【示意效果】 the curse of dimensionality（维数灾祸）[4] 在机器学习里是指随着样本空间和参数空间维数的增加，潜在参数组合的数量指数型增长，相同精确度的预测会需要多得多的训练样本。当训练样本不变时，预测的精度与空间维数的增加成反比。 技术成熟的条件 Andrew Ng[5] 一个新科技的出现要掐着时间，不能太早也能太晚。比如说iphone，2007年才是它发布的正确时间，而不是在1993年，因为那时的芯片，电池，屏幕技术还没到位。 另外一个极端的例子是达芬奇发明直升机，他发明直升机的时间是1480年代，而飞机引擎技术在1900年代才出现。 还有自动驾驶技术，2007年研究自动驾驶技术还太早，因为AI要用到的传感器还没生产出来。2015年以后，整个自动驾驶的生态系统才算比较完善。 同样在1990年代，网络，视频流还不足以支撑慕课问世，到2011年，整个网络基础建设才为在线视频教育提供了较好的环境。 深度学习也是，90年代数据/计算比较小，浅层算法效果更好。从2007开始，有了大数据做基础，深度学习才取得了更好的效果。 但是，我们还是要感谢历史中所有的革新者，包括早期的那些人，他们的工作对后来的发展进步也非常具有影响和帮助。【现在不叫座，以后可能叫好】 reference 历史 a brief history of maching learning(机器学习简史) 【已读】 可读 colah blog book: Deep learning(Ian. Goodfellow) [book: Neural networks and deep learning(Michael Nielsen)] (www.deeplearningbook.org/) Yoshua Bengio为什么能跟Hinton、LeCun相提并论？ 包含学术传承与贡献的讨论 ↩ 历史|从神经元到深度学习 【可再读】 ↩ ↩ ↩ ↩ ↩ ↩ ↩ ↩ 深度学习技术发展历史及应用现状如何？ ↩ ↩ 神经网络的历史？ ↩ 【干货|持更】人工智能产业的相关资料及入门指南 【已读】 ↩]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python mechanism]]></title>
    <url>%2F2017%2F07%2F28%2Fpython_mechanism%2F</url>
    <content type="text"><![CDATA[[TOC] 0. is 与 ==的区别 python对象有三个要素：id、type、value。is 比较的是id；==比较的是value 而id实际上是内存地址，(ob1 is ob2) 等价于 (id(ob1) == id(ob2)) 另外，一些具体的问题，结果不确定，比如用python.py： 12345 &gt;&gt;&gt; x = 500 &gt;&gt;&gt; y = 500 &gt;&gt;&gt; x is yTrue ```language 然而用python或者IPython，结果为False 1. mutable &amp; immutable 不可变（immutable）：int、字符串(string)、float、（数值型number）、元组（tuple) 可变（mutable）：字典型(dictionary)、列表型(list) 2. with 语句 自动进行对象的生命周期进行管理 Python中的with语句中要求对象实现__enter__和__exit__函数。调用with语句时，会先分析该语句，执行__enter__函数，然后在当前suite退出时，会调用__exit__函数。__exit__函数中除了可以做释放资源的操作之外，同时也是异常处理的地方。如果当前suite正常退出，没有抛出任何异常，__exit__的几个参数均为None。否则，则将此异常的type、value、traceback作为参数传递给__exit__函数，同时，如果__exit__返回false，此异常会再次抛出，上一级代码suite可以继续处理，如果__exit__返回true，那么此异常就不会被再次抛出了。 同时打开多个文件 12345with open(filename1, 'rb') as fp1, open(filename2, 'rb') as fp2, open(filename3, 'rb') as fp3: for i in fp1: j = fp2.readline() k = fp3.readline() print(i, j, k) 3. list参数传递 python中的默认变量是定义时得到的，类似于static，其它的时候无论调用几次函数，如果没有传参进来，就会一直用这个默认参数了。 正确做法： 12345def add(element, mylist=None): if mylist is None: mylist = [] mylist.append(element) return mylist 4*. Python中函数的参数传递与可变长参数 【tricky】可变长度参数：*tupleArg,**dictAr 廖雪峰的更详细的介绍 ct总结：参数绑定优先级： 指定参数名 顺序 不符合前两条的可以被可变长度参数捕捉 可变长度参数是通过拷贝传到函数内的！与一般机制不同 限制关键字参数的名字 如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下： 12def person(name, age, *, city, job): print(name, age, city, job) 5. generator 最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。 6. zip() &amp; Unpacking Argument Lists——&quot;*&quot; &amp; “**” The implementation of zip is very beautiful： 来自python doc 123456789101112131415def zip(*iterables): # zip('ABCD', 'xy') --&gt; Ax By sentinel = object() # ct: iterators is a "Iterator" point to the "Iterator" of different parameters(形参) # e.g., at first, iterators is the "Iterator" of 'ABCM'; # iterators.next() is the "Iterator" of 'xy'; iterators = [iter(it) for it in iterables] while iterators: result = [] for it in iterators: elem = next(it, sentinel) if elem is sentinel: return result.append(elem) yield tuple(result) 123456789#zip() in conjunction with the * operator can be used to unzip a list: &gt;&gt;&gt; x = [1, 2, 3] &gt;&gt;&gt; y = [4, 5, 6] &gt;&gt;&gt; zipped = zip(x, y) &gt;&gt;&gt; list(zipped)[(1, 4), (2, 5), (3, 6)] &gt;&gt;&gt; x2, y2 = zip(*zip(x, y)) &gt;&gt;&gt; x == list(x2) and y == list(y2)True Unpacking Argument Lists 12345 &gt;&gt;&gt; list(range(3, 6)) # normal call with separate arguments[3, 4, 5] &gt;&gt;&gt; args = [3, 6] &gt;&gt;&gt; list(range(*args)) # call with arguments unpacked from a list[3, 4, 5] 7. Iterable和Iterator 凡是可作用于for循环的对象都是Iterable类型，它有__getitem__()方法； 凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列，它有__next__()和__iter__()方法； 集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。 Python的for循环本质上就是通过不断调用next()函数实现的，例如： for x in [1, 2, 3, 4, 5]: pass 实际上完全等价于： 首先获得Iterator对象: it = iter([1, 2, 3, 4, 5]) 循环: 123456while True: try: # 获得下一个值: x = next(it) except StopIteration: # 遇到StopIteration就退出循环break while my_iterator（参见zip的实现） iterator最终会返回StopIteration对象，而while可以对其进行判断。 8. 内存 8.1. 释放内存 先del再gc.collect() 9. Python类 9.1. 和静态语言不同，Python允许对实例变量绑定任何数据 也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同： 123456789 &gt;&gt;&gt; bart = Student('Bart Simpson', 59) &gt;&gt;&gt; lisa = Student('Lisa Simpson', 87) &gt;&gt;&gt; bart.age = 8 &gt;&gt;&gt; bart.age8 &gt;&gt;&gt; lisa.ageTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute 'age' 9.2. Python的伪私有属性 Note that user defined attributes shall not end with ‘__’ 9.3. 私有变量的访问方法 不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量。 注意下面的这种错误写法： 12345 &gt;&gt;&gt; bart = Student('Bart Simpson', 98) &gt;&gt;&gt; bart.get_name()'Bart Simpson'&gt;&gt;&gt; bart.__name = 'New Name' # 设置__name变量！ &gt;&gt;&gt; bart.__name'New Name' 表面上看，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量不是一个变量！内部的__name变量已经被Python解释器自动改成了_Student__name，而外部代码给bart新增了一个__name变量。 9.4. 特殊函数__call__模糊了对象与函数的区别 9.5. 类类型的检查–不检查 静态语言 vs 动态语言 对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。 对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了： 12class Timer(object):def run(self): print('Start...') 这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。 Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。 Style guide argument **kwargs is a bad practice: you don’t know how **kwargs affect. wrong keywrod arguments is no longer reported by the interpreter. TypeError 'x' is an invalid keyword argument for this function reference:The Use and Abuse of Keyword Arguments in Python]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git笔记]]></title>
    <url>%2F2017%2F07%2F26%2Fgit%2F</url>
    <content type="text"><![CDATA[git 开始 非常好的入门: 非常好的入门1[1]: 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 非常好的入门2 init config 123git config --global user.name "your name"git config --global user.email "your email"git config --global core.editor "vim #set vim as editor 列出设置的config git config --list difftool 没有默认的difftool，如果首次输入命令git difftool，CentOS会自动推荐kompare。 12Viewing: &apos;particles/BinReader.cc&apos;Launch &apos;kompare&apos; [Y/n]: y kompare的效果非常好。 help git help &lt;verb&gt; 操作 add filename commit git commit -m &quot;your message&quot; Amending the most recent commit message[2] git commit --amend will open your editor, allowing you to change the commit message of the most recent commit. Additionally, you can set the commit message directly in the command line with: git commit --amend -m &quot;New commit message&quot; …however, this can make multi-line commit messages or small corrections more cumbersome to enter. Make sure you don’t have any working copy changes staged before doing this or they will get committed too. (Unstaged changes will not get committed.) reset git reset --hard HEAD^ git reset --hard 3628164 reflog 查看历史命令 clone git clone /path/to/repository 如果是远端服务器上的仓库，你的命令会是这个样子： git clone username@host:/path/to/repository git clone git@github.com:dunitian/Windows10.git &quot;F:/Work/WP/Windows10&quot; #到指定文件夹 push git push origin master:master origin is the remote server; the branch name before the colon is local branch name, and that after the colon is remote branch name. e.g.: 12git push origin HEAD:refs/for/branch1 # push HEAD branch to a remote branch git push origin :refs/for/branch1 # delete remote branch git checkout hexo myfile 从hexo分支得到myfile stash[3] 储藏会处理工作目录的脏的状态 - 即，修改的跟踪文件与暂存改动 - 然后将未完成的修改保存到一个栈上，而你可以在任何时候重新应用这些改动。 git stash 临时存储当前状态 git stash list git stash apply (--index) 找回临时存储的状态 git stash drop 删除stash branch git checkout -b dev #-b参数表示创建并切换 git checkout master git merge dev 合并指定分支到当前分支 git branch -d dev #删除 git branch -r/-a # 查看远程/所有分支； git branch 查看本地分支 git checkout mybfranch # shift to another branch pull git pull origin master相当于git fetch加上git merge fetch git fetch origin hexo从remote repo获取名为hexo的branch 丢弃 git rm (then git commit) git checkout -- file git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： $ git checkout -- test.txt 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 显示状态 status log git log --oneline --decorate # 加上–decorate 时，我们可以看到我们的标签 remote 看当前配置有哪些远程仓库，可以用命令 git remote 执行时加上 -v 参数，你还可以看到每个别名的实际链接地址。 git ls-files #ls files in present branch git ls-files -u #显示冲突的文件，-s是显示标记为冲突已解决的文件 diff git diff #对比工作区和stage文件的差异 git diff --cached 对比stage和branch之间的差异 git diff master remotes/origin/hexo #对比本地“master” branch和远程“remotes/origin/hexo” branch git diff origin/hexo #对比当前working tree和远程branch rebase git rebase 用法 stackoverflow git rebase --skip git rebase --continue #use this when you solved conflicts. git rebase --abort #放弃当前rebase tag git push origin --tags 其他概念与原理 origin It’s a repo! 顾名思义，origin就是一个名字，它是在你clone一个托管在Github上代码库时，git为你默认创建的指向这个远程代码库的标签 (远程仓库名)/(分支名) 这样的形式表示远程分支 Note that when git branch -a is used, there is ‘remote’ in front of branch name, e.g.: 1234$ git branch -r orgin/master $ git branch -a remote/origin/master local_branch_name:remote_branch_name # 这是push，pull的时候顺序反过来 远程分支和本地分支的名字相同，可以省略远程分支的名字 upstream vs. origin This should be understood in the context of GitHub forks (where you fork a GitHub repo at GitHub before cloning that fork locally) upstream generally refers to the original repo that you have forked (see also “Definition of “downstream” and “upstream”” for more on upstream term) origin is your fork: your own repo on GitHub, clone of the original repo of GitHub branch &amp; hash[4] you need to understand that branch and tag names are just pointers to hash values, which represent a single commit 错误 prompt to input passphrase time and time again: Git enter long passphrase for every push Note that you can use ssh-key only if you use ssh to build remote connections. git remote -v should looks like: origin git@github.com:TimChen314/MDTackle.git (fetch) but not: origin https://github.com/TimChen314/MDTackle.git reference 待读 超好: git cheatsheet 常用git Git 工作区、暂存区和版本库 ↩ How to modify existing, unpushed commits? ↩ 6.3 Git 工具 - 儲藏 ↩ What’s the difference between git reset --hard master and git reset --hard origin/master? ↩]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云邮箱设置记录]]></title>
    <url>%2F2017%2F07%2F21%2Fali_mail_set%2F</url>
    <content type="text"><![CDATA[正文 在阿里云买了域名，阿里云正好（2017-07）有免费赠邮箱服务，所以想把这个邮箱服务用起来。 登录阿里云–&gt;控制台–&gt;域名与网站(左侧菜单栏中)–&gt;企业邮箱–&gt;登录管理员账号(用postmaster@yoursite.com这个账号登录https://qiye.aliyun.com/admin/,这里是负责管理邮箱系统) qiye.aliyun.com/admin/中会显示 邮箱登录地址:http://mail.timchen314.com 访问http://mail.timchen314.com: 温馨提醒：该页面暂时无法访问 尊敬的用户： 您好！ 根据《非经营性互联网信息服务备案管理办法》第十八条法规，您的域名尚未进行备案，暂时无法访问。请参考工信部相关备案流程进行相关操作。 所以，必须要备案后才能使用邮箱服务。 ICP备案是：[1] ICP备案的含义是主机、站长（个人或者法人）、域名和网站经营内容四者的一个绑定认证关系 如果使用了github作为托管主机，是无法备案的。如何选择备案产品类型 如您购买的是其他服务商空间，请联系对应的空间提供商备案；如自己架设服务器，需要联系您服务器的网络供应商，即提供您服务器上网服务的运营商，如电信、联通等。 可能有用[2] reference 阿里云个人网站备案过程全记录 ↩ 可能有用：本博客阿里云配置过程（一）服务器及域名备案篇 ↩]]></content>
      <categories>
        <category>技术杂烩</category>
      </categories>
      <tags>
        <tag>技术杂烩</tag>
        <tag>邮箱设置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo]]></title>
    <url>%2F2017%2F07%2F21%2Fhexo%2F</url>
    <content type="text"><![CDATA[memo 这个网站可以作为参考www.ezlippi.com npm i(nstall) hexo-generator-json-content --save Fix error to ensure “all article” works normally. hexo-footnote(已不再维护) npm install hexo-footnotes --save 如果Hexo不能自动发现插件，则需要手动安装插件5，编辑_config.yml文件： 12plugins: - hexo-footnotes 安装hexo-renderer-marked以支持更多Markdown特性 123npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --savenpm install markdown-it-emoji --save 设置文章置顶 &amp; Cloudinary在线图片服务[1] top: 3 # 数字越大越靠前，默认为0 除了在本地存储图片，还可以将图片上传到一些免费的CDN服务中。比如Cloudinary提供的图片CDN服务，在Cloudinary中上传图片后，会生成对应的url地址，将地址直接拿来引用即可。 在Cloudinary申请账号，上传图片(注意把upload选项中的unsigned signature选上) Cloundinary的免费存储空间还是非常大的cloudinary价格 我的cloudinary 使用方法： 点击图片 点击url 拷贝链接 hexo个人命令 用hexol/hexod命令一次性完成本地/远程预览 配置.bash_profile: 1234export HEXO='/Users/Aether/Documents/hexo_file'export HEXOMD='/Users/Aether/Documents/hexo_file/source/_posts/'alias hexod='cd $HEXOMD &amp;&amp; sh tackle_md.sh &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo deploy'alias hexol='cd $HEXOMD &amp;&amp; sh tackle_md.sh &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo s' tackle_md.sh自动调整缩进、设置部分显示、修改文章标题大小(for next theme) 12345678#!/bin/shsh indent.shsh read_more.shfor mdfile in $(ls *.md)do awk -f ./title_size.awk $mdfile &gt; /tmp/$mdfile &amp;&amp; mv /tmp/$mdfile $mdfiledone 其中，indent.sh: 12345#!/bin/sh# indent for code blocksed -i 's/^```[a-z]/ &amp;/g' *.md# indent for quotesed -i 's/^&gt;/ &amp;/g' *.md read_more.sh: 12345678910#!/bin/sh# if no "&lt;!-- more --&gt;" in *.md file, adding it into the file.for md_file in $(ls *md)do stat=$(grep "&lt;!-- more --&gt;" $md_file) if [ -z "$stat" ];then sed -i '20a &lt;!-- more --&gt;' $md_file fidone title_size.awk: 1234567891011121314#!/usr/bin/awk -f&#123; if(/^title:/&amp;&amp;!/font/) &#123; for(i=1;i&lt;=NF;++i) &#123; printf $i" "; if(i==1) printf " &lt;font size=6&gt;&lt;b&gt;"; else if(i==NF) printf "&lt;/b&gt;&lt;/font&gt;\n" ; &#125; &#125; else print $0;&#125; yilia theme image file path hexo_file/themes/hexo-theme-yilia/source/img theme-yilia yilia next theme 要想显示标签页，需要手动操作，详见[2] 添加搜索[3] 在os X safari上无法正常使用，原因不明；在os X chrome上和win7 chrome上都可以正常使用 12npm install hexo-generator-search --savenpm install hexo-generator-searchdb --save 如何设置页面文章的篇数？[4] 123npm install --save hexo-generator-indexnpm install --save hexo-generator-archivenpm install --save hexo-generator-tag 设置social_icons next是通过FontAwesome进行图标设计的，FA支持的图标都在主页上。 目前FA不支持知乎，所以随便选了个fa-bed作为icons。设置中写为zhihu: bed 设置文章标题的格式 直接用html就可以 title: &lt;font size=6&gt;&lt;b&gt;人工智能简介&lt;/b&gt;&lt;/font&gt; References: HEXO搭建个人博客 2个小时教你hexo博客添加评论、打赏、RSS等功能 从搭建hexo个人博客过程中理解学习DNS解析 Hexo Configuration ↩ Next-主题配置 ↩ 参考：Hexo博客添加站内搜索 ↩ Next-常见问题 ↩]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>yilia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown in hexo-render-markdown-it]]></title>
    <url>%2F2017%2F07%2F21%2Fmarkdown_in_hexo%2F</url>
    <content type="text"><![CDATA[The implementation of Markdown in different software are always different here or there. To testify the implementation of hexo, syntax page of Mou is pasted in here for comparison. In summary, only inline image is unavailable. PS: spacing can add indent; and code block &amp; quote wouldn’t indent automatically. so indent.sh is used Could add spacing manually by &amp;nbsp; #半角的不断行的空白格 (it works in header, too) &lt;br/&gt; as line break Mou Overview Mou, the missing Markdown editor for web developers. Syntax Strong and Emphasize strong or strong ( Cmd + B ) emphasize or emphasize ( Cmd + I ) Sometimes I want a lot of text to be bold. Like, seriously, a LOT of text Blockquotes Right angle brackets &gt; are used for block quotes. Links and Email An email example@example.com link. Simple inline link http://chenluois.com, another inline link Smaller, one more inline link with title Resize. A reference style link. Input id, then anywhere in the doc, define the link with corresponding id: Titles ( or called tool tips ) in the links are optional. Images An inline image , title is optional. A reference style image. Inline code and Block code Inline code are surround by backtick key. To create a block code: Indent each line by at least 1 tab, or 4 spaces. var Mou = exactlyTheAppIwant; Ordered Lists Ordered lists are created using “1.” + Space: Ordered list item Ordered list item Ordered list item Unordered Lists Unordered list are created using “*” + Space: Unordered list item Unordered list item Unordered list item Or using “-” + Space: Unordered list item Unordered list item Unordered list item Hard Linebreak End a line with two or more spaces will create a hard linebreak, called &lt;br /&gt; in HTML. ( Control + Return ) Above line ended with 2 spaces. Horizontal Rules Three or more asterisks or dashes: Headers Setext-style: This is H1 This is H2 atx-style: This is H1 This is H2 This is H3 This is H4 This is H5 This is H6 Extra Syntax Footnotes Footnotes work mostly like reference-style links. A footnote is made of two things: a marker in the text that will become a superscript number; a footnote definition that will be placed in a list of footnotes at the end of the document. A footnote looks like this: That’s some text with a footnote.[1] Strikethrough Wrap with 2 tilde characters: Strikethrough Fenced Code Blocks Start with a line containing 3 or more backticks, and ends with the first line with the same number of backticks: 123Fenced code blocks are like Stardard Markdown’s regular codeblocks, except that they’re not indented and instead rely ona start and end fence lines to delimit the code block. Tables A simple table looks like this: First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell If you wish, you can add a leading and tailing pipe to each line of the table: First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell Specify alignment for each column by adding colons to separator lines: First Header Second Header Third Header Left Center Right Left Center Right And that’s the footnote. ↩]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>